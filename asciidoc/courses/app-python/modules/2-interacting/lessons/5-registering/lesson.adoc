= Registering a User
:type: challenge
// :branch: 03-registering-a-user
:branch: main
:test-filename: 03_registering_a_user__test

Now that you have read data from the database, you are now ready to write data to the database.

In this challenge, you will rewrite the `register()` method in the link:{repository-blob}main/api/dao/auth.py[`AuthDAO`^] to do the following:

1. <<Create the Unit of Work function>>
2. <<Execute the function within a new Write Transaction>>
3. <<Return the Result>>


== Registering Users

A key piece of functionality that the application should provide is for new users to be able to register themselves with the site.
This functionality is already built into the front end, but at the moment the credentials are hard coded in the API.
This might be fine for demo purposes, but limiting the number of users to one is bad for Neoflix's bottom line.

The dummy register logic is already written into the `register()` method of the `AuthDAO` at `api/dao/auth.py`.  As we can see from the snippet below, at the moment it will only accept an email address of `graphacademy@neo4j.com`.


[source,python,indent=0]
.api/dao/auth.py
----
include::{repository-raw}/main/api/dao/auth.py[tag="register"]
----

From the last line, you can see that an additional `token` property is added to the return.
This represents the JWT token required to authenticate the user on any future requests.
This token is generated further down within this class.

You will replace these `TODO` comments with working code to complete the challenge.


== Implementing Write Transactions

You will follow similar steps to the previous challenge, with the one change that the Cypher query will be executed within a Write Transaction.

To do so, you will need to call the `write_transaction()` method on the `session` object with a function to represent unit of work.

Here are the steps to complete the challenge.

=== Create the Unit of Work function

Next, define a new function which will call the `tx.run()` method.
The call to `tx.run()` should include:

1. The Cypher query as a parameterized string passed as the first argument.
2. The parameters used in the query passed as named parameters: `email`, `encrypted` password and `name`.  These will be referenced in the query prefixed with a dollar sign (eg. `$email`).
3. The query will return a single result, so you can call the `.single()` method directly on the object to return a single result.

.Unit of Work
[source,python,indent=0]
----
include::{repository-raw}/{branch}/api/dao/auth.py[tag="create",indent=0]
----

=== Execute the function within a new Write Transaction

Next, open a new session and use the `session.write_transaction()` method to execute this unit of work.

.Unit of Work
[source,python,indent=0]
----
include::{repository-raw}/{branch}/api/dao/auth.py[tag="call_create"]
----


=== Return the Result

The call above above returns the newly-created `:User` node as `u`.
As this query creates a single node, it will only ever return one result, so the `u` value may be taken from the first row.

Use square brackets to extract the `u` node returned by the Cypher query above.

The method expects a JWT token to be returned along with the user's information.
The token can be generated by passing a selection of the user's properties, including the `id` property, to the `_generate_token` method.


[source,python,indent=0]
----
include::{repository-raw}/{branch}/api/dao/auth.py[tag="extract"]
----




== Working Solution

.Click here to reveal the fully-implemented `register()` method.
[%collapsible]
====
[source,python,indent=0]
----
include::{repository-raw}/{branch}/api/dao/auth.py[tag="register"]
----
====

include::../../../../includes/test.adoc[]


include::./questions/verify.adoc[leveloffset=+1]


[.summary]
== Lesson Summary

In this Challenge, you wrote the code to create a new User node to Neo4j.

We still have `TODO` comments in the query for handling unique constraint violations in the database, so let's learn about that in the next lesson.
