= Defining Properties
:type: lesson
:order: 5


[.slide.discrete]
== Understanding Properties

In the previous lesson, you learned about nodes, labels, and relationships that form the structure of your graph.
Now you will learn about properties, which store the actual data about your entities and relationships.


In this lesson, you will learn what properties are, how to define them for nodes and relationships, and the properties you will use for the Northwind dataset.


[.slide]
== What are Properties?

**Properties** are key-value pairs that store attributes on nodes and relationships.
They hold the actual data in your graph.


Properties can store:

* Strings
* Numbers (integers, floats)
* Booleans
* Dates and times
* Lists


[.slide.discrete]
== Node Properties

Nodes of the same label can have different properties.
This flexibility is powerful but requires planning.


**Customer Properties:**


[options="header"]
|===
| Property | Type | Description

| `customerId` | String | Unique identifier
| `companyName` | String | Company name
| `contactName` | String | Contact person
| `contactTitle` | String | Contact's job title
| `address` | String | Street address
| `city` | String | City
| `region` | String | State/province
| `postalCode` | String | Postal code
| `country` | String | Country
| `phone` | String | Phone number
| `fax` | String | Fax number
|===


**Product Properties:**


[options="header"]
|===
| Property | Type | Description

| `productId` | Integer | Unique identifier
| `productName` | String | Product name
| `quantityPerUnit` | String | Package size
| `unitPrice` | Float | Price per unit
| `unitsInStock` | Integer | Current stock
| `unitsOnOrder` | Integer | Units ordered
| `reorderLevel` | Integer | Reorder threshold
| `discontinued` | Boolean | Is discontinued?
|===


**Order Properties:**


[options="header"]
|===
| Property | Type | Description

| `orderId` | Integer | Unique identifier
| `orderDate` | Date | When order was placed
| `requiredDate` | Date | Required delivery date
| `shippedDate` | Date | Actual ship date
| `freight` | Float | Shipping cost
| `shipName` | String | Ship to name
| `shipAddress` | String | Ship to address
| `shipCity` | String | Ship to city
| `shipCountry` | String | Ship to country
|===


**Category, Supplier, and Employee Properties:**

**Category:**

* `categoryId` - Integer
* `categoryName` - String
* `description` - String


**Supplier:**

* `supplierId` - Integer
* `companyName` - String
* `contactName` - String
* `contactTitle` - String
* `address`, `city`, `region`, `postalCode`, `country`
* `phone`, `fax`


**Employee:**

* `employeeId` - Integer
* `lastName`, `firstName` - String
* `title`, `titleOfCourtesy` - String
* `birthDate`, `hireDate` - Date
* `address`, `city`, `region`, `postalCode`, `country`
* `homePhone` - String
* `extension` - String
* `notes` - String


[.slide.discrete]
== Relationship Properties

The `ORDERS` relationship stores order-specific product information:


```mermaid
graph LR
    A[Order] -->|"ORDERS<br/>quantity: 10<br/>unitPrice: 18.00<br/>discount: 0.05"| B[Product]
```


[options="header"]
|===
| Property | Type | Description

| `quantity` | Integer | Units ordered
| `unitPrice` | Float | Price at time of order
| `discount` | Float | Discount percentage (0.00-1.00)
|===


**Why Store Price on Relationship?**


Product prices change over time.
By storing `unitPrice` on the `ORDERS` relationship, you preserve the historical price:


```mermaid
graph TB
    A[Product: Chai<br/>currentPrice: 20.00]

    B[Order 2023] -->|"ORDERS<br/>unitPrice: 18.00"| A
    C[Order 2024] -->|"ORDERS<br/>unitPrice: 19.00"| A
    D[Order 2025] -->|"ORDERS<br/>unitPrice: 20.00"| A
```


This pattern is common when modeling time-varying data.


[.slide.discrete]
== Property Naming Conventions

* **Use camelCase** - `firstName`, `orderDate`, `unitPrice`
* **Be descriptive** - `orderDate` not `date`
* **Avoid abbreviations** - `quantity` not `qty` (unless standard)
* **Consistent names** - Use `customerId` everywhere, not mixing with `customerID`


[.slide.discrete]
== Unique Identifiers

Each node type should have a unique identifier property:


* Customer: `customerId`
* Order: `orderId`
* Product: `productId`
* Category: `categoryId`
* Supplier: `supplierId`
* Employee: `employeeId`


These IDs will be used to:

* Create uniqueness constraints
* Match and merge data during import
* Reference nodes in queries


[.slide.discrete]
== Property vs Node Decision

Sometimes you need to decide whether something should be a property or a separate node.


**Why make `country` a property instead of a node?**

In Northwind, customers have a country. You could model this two ways:


*Option 1: Country as property*

----
Customer {
  customerId: 'ALFKI'
  country: 'Germany'
}
----

*Option 2: Country as node*

----
(Customer)-[:LOCATED_IN]->(Country {name: 'Germany'})
----

**When to use a property:**

* **Simple value** - Country is just text describing the customer
* **No shared attributes** - You don't need GDP, population, or other country data
* **Filtering, not navigation** - You want to filter customers by country, not navigate from country to customers
* **Storage efficiency** - Properties are faster to read than traversing relationships


**When to use a node:**

* **Has its own attributes** - If you need country population, region, timezone
* **Central to queries** - If you often ask "What customers are in this country?"
* **Relates to multiple entities** - If both customers AND suppliers have countries, and you want to query "All entities in Germany"
* **Shared reference data** - If country data should be consistent and managed centrally


**In Northwind:**

* `country` is a property because it's a simple descriptor used for filtering
* `Category` is a node because it has its own description and relates to many products


**Think about your queries:**

* "Find customers in Germany" → Property works great: `WHERE c.country = 'Germany'`
* "Find all products in the Beverages category" → Need a node: `MATCH (cat:Category {name: 'Beverages'})<-[:PART_OF]-(p:Product)`


The difference: Category is queried **from** (start point), while country is queried **for** (filter condition).


[.summary]
== Summary

In this lesson, you learned:


* **Properties** - Key-value pairs that store attributes on nodes and relationships
* **Data types** - Properties can store strings, numbers, booleans, dates, and lists
* **Node properties** - Each entity type (Customer, Product, Order, Category, Supplier, Employee) has specific properties for storing data
* **Relationship properties** - The `ORDERS` relationship stores quantity, unitPrice, and discount
* **Historical data** - Storing unitPrice on relationships preserves historical pricing
* **Naming conventions** - Use camelCase, descriptive names, and consistent identifiers
* **Unique identifiers** - Each node type has a unique ID property for constraints and matching
* **Property vs node decision** - Use properties for simple values, nodes for entities with their own attributes and relationships


In the next lesson, you will learn how to test your data model with sample data before importing the full dataset.
