= Testing Your Data Model
:type: lesson
:order: 6


[.slide.discrete]
== Testing Your Data Model


In the previous lesson, you defined your graph data model with nodes, labels, relationships, and properties. Before importing large amounts of data, you need to verify the model answers your use cases efficiently.


In this lesson, you will learn how to test your data model with sample data and validate it against your use cases.


[.slide]
== Why Test Your Model?


Before importing large amounts of data, you should test your data model with sample data to verify it:

* Answers all use cases efficiently
* Performs well with realistic queries
* Is intuitive and easy to work with
* Scales appropriately


[.slide]
== Creating sample data


Create a small instance model with representative data:

```mermaid
graph TB
    C1[Customer: ALFKI<br/>Alfreds] -->|PLACED| O1[Order: 10248<br/>1996-07-04]
    C2[Customer: BONAP<br/>Bon app] -->|PLACED| O2[Order: 10249<br/>1996-07-05]
    
    O1 -->|ORDERS<br/>qty: 12<br/>price: 18.00| P1[Product: Chai<br/>Beverages]
    O1 -->|ORDERS<br/>qty: 10<br/>price: 9.80| P2[Product: Chang<br/>Beverages]
    O2 -->|ORDERS<br/>qty: 9<br/>price: 18.60| P3[Product: Aniseed<br/>Condiments]
    
    P1 -->|PART_OF| Cat1[Category:<br/>Beverages]
    P2 -->|PART_OF| Cat1
    P3 -->|PART_OF| Cat2[Category:<br/>Condiments]
    
    E1[Employee: Nancy<br/>Sales Rep] -->|SOLD| O1
    E1 -->|SOLD| O2
    E1 -->|REPORTS_TO| E2[Employee: Andrew<br/>Sales Manager]
```


This sample includes:
* 2 customers with different countries
* 2 orders with different dates
* 3 products in 2 categories
* 2 employees with reporting relationship


[.slide]
== Testing use cases


Test each use case with Cypher queries:


[.slide.discrete]
=== Use Case 1: Orders by Customer


What orders did customer 'ALFKI' place?


Cypher Pattern:


```cypher
MATCH (c:Customer {customerId: 'ALFKI'})-[:PLACED]->(o:Order)
RETURN c.companyName, o.orderId, o.orderDate
```


The model supports this efficiently with a direct relationship.


[.slide.discrete]
=== Use Case 2: Products in an Order


What products were in order 10248?


Cypher Pattern:


```cypher
MATCH (o:Order {orderId: 10248})-[rel:ORDERS]->(p:Product)
RETURN p.productName, rel.quantity, rel.unitPrice
```


The model supports this efficiently with a direct relationship and properties on the relationship.


[.slide.discrete]
=== Use Case 3: Products by Category


What products are in the Beverages category?


Cypher Pattern:


```cypher
MATCH (cat:Category {categoryName: 'Beverages'})<-[:PART_OF]-(p:Product)
RETURN p.productName, p.unitPrice
```


The model supports this efficiently with a direct relationship.


[.slide.discrete]
=== Use Case 4: Employee Hierarchy


Who reports to Andrew?


Cypher Pattern:


```cypher
MATCH (e:Employee)-[:REPORTS_TO]->(m:Employee {firstName: 'Andrew'})
RETURN e.firstName, e.lastName, e.title
```


The model supports this efficiently with a direct relationship.


[.slide.discrete]
=== Use Case 5: Customer Purchase History


What products has customer 'ALFKI' purchased?


Cypher Pattern:


```cypher
MATCH (c:Customer {customerId: 'ALFKI'})-[:PLACED]->(:Order)-[:ORDERS]->(p:Product)
RETURN DISTINCT p.productName
```


The model supports this with a simple two-hop traversal.


[.slide]
== Evaluating performance


When testing, consider:


[.slide.discrete]
=== Query Complexity


* Most queries should be 1-3 relationship hops
* Deep traversals (5+ hops) may need optimization
* Consider adding direct relationships for common paths


[.slide.discrete]
=== Fanout


How many relationships does a node have?


Neo4j handles high fanout well, but be aware of:


* Popular products with thousands of orders
* Active customers with hundreds of orders


[.slide.discrete]
=== Index Usage


Ensure you're using indexed properties for lookups.


Always start queries with indexed properties. You will add these during import.


[.slide]
== Reviewing test results


After testing with sample data:

[options="header"]
|===
| Use Case | Supported? | Performance | Notes

| Orders by customer | ✓ | Fast | Direct relationship
| Products in order | ✓ | Fast | Direct relationship
| Products by category | ✓ | Fast | Direct relationship
| Employee hierarchy | ✓ | Fast | Direct relationship
| Customer purchase history | ✓ | Fast | 2-hop traversal
| Supplier products | ✓ | Fast | Direct relationship
| Order totals | ✓ | Fast | Aggregate relationship properties
|===


All use cases are well-supported by the model.


[.slide]
== Identifying when to refactor


You might need to refactor if:

* Queries require 5+ relationship hops
* Common queries are slow
* The model is hard to understand
* New use cases are not supported
* Data duplication causes inconsistencies


For Northwind, the model passes all tests.


[.summary]
== Summary


In this lesson, you learned how to test your data model:


* **Creating sample data** - Build a small instance model with representative data covering key scenarios
* **Testing use cases** - Validate each use case with Cypher queries to ensure the model supports them efficiently
* **Evaluating performance** - Consider query complexity (relationship hops), fanout (relationships per node), and index usage
* **Identifying refactoring needs** - Recognize when queries require too many hops, performance is slow, or new requirements emerge


In the next lesson, you will learn about refactoring techniques for improving your data model.
