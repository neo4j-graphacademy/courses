= Modeling Relationships
:type: lesson
:order: 4

[.slide.discrete]
== Understanding Relationships

In the previous lesson, you learned about nodes and labels, which represent the entities in your graph. To create a useful graph database, you need to connect these nodes.


In this lesson, you will learn about relationships, how they work in Neo4j, and how to model the relationships for the Northwind dataset.


[.slide.discrete]
== Defining Relationships

**Relationships** connect nodes and represent associations between entities. They are the key feature that makes graph databases powerful.


Every relationship:

* Has a **type** (name)
* Has a **direction** (from one node to another)
* Can have **properties** (attributes)
* Connects exactly two nodes


[.slide.discrete]
== Understanding Why Relationships Matter

In relational databases, you model connections with foreign keys and pivot tables. This creates problems:


**The Relational Approach:**

* Orders connect to Products through an `order_details` pivot table
* To find products in an order, you JOIN orders → order_details → products
* Each JOIN scans tables and matches keys—slow for deep queries
* The connection isn't explicit; it's just matching numbers


**The Graph Approach:**

* Orders connect directly to Products via `ORDERS` relationships
* To find products, you traverse the relationship—no table scans
* The relationship is explicit and named: `ORDERS`
* You can traverse in either direction without additional JOINs


Relationships are **faster** because there's no JOIN overhead, **clearer** because the connection is explicitly named, and **more flexible** because you can traverse them in any direction.


[.slide.discrete]
== Understanding Relationship Direction

Every relationship has a direction, but you can traverse relationships in either direction in your queries.


The direction should represent the natural flow of the relationship.


[.slide.discrete]
== Modeling Northwind Relationships

The Northwind domain includes the following relationships:


```mermaid
graph TB
    A[Customer] -->|PLACED| B[Order]
    B -->|ORDERS| C[Product]
    C -->|PART_OF| D[Category]
    C -->|SUPPLIED_BY| E[Supplier]
    F[Employee] -->|SOLD| B
    F -->|REPORTS_TO| F
```


[options="header"]
|===
| Relationship | From | To | Meaning

| `PLACED` | Customer | Order | Customer placed an order
| `ORDERS` | Order | Product | Order contains a product
| `PART_OF` | Product | Category | Product belongs to category
| `SUPPLIED_BY` | Product | Supplier | Product supplied by supplier
| `SOLD` | Employee | Order | Employee processed order
| `REPORTS_TO` | Employee | Employee | Employee reports to manager
|===


[.slide.discrete]
== Applying Naming Conventions

When naming relationships:


* **Use verbs** - Relationships are actions or associations
* **Use UPPER_SNAKE_CASE** - All caps with underscores
* **Be specific** - `PLACED` is better than `RELATED_TO`
* **Read naturally** - `(Customer)-[:PLACED]->(Order)` reads like a sentence


[.slide.discrete]
== Handling Many-to-Many Relationships

In relational databases, many-to-many relationships require pivot tables. In Northwind, orders contain many products, and products appear in many orders.


**Relational approach with pivot tables:**

[source,sql]
----
-- Three tables needed
SELECT p.productName
FROM orders o
JOIN order_details od ON o.orderID = od.orderID  -- Pivot table
JOIN products p ON od.productID = p.productID
WHERE o.orderID = 10248;
----

**Problems with pivot tables:**

* **Performance cost** - Two JOINs scan and match thousands of rows
* **Not semantic** - `order_details` is just a join table, not meaningful
* **Query complexity** - Every query needs the same JOIN pattern


**Graph approach with relationships:**

[source,cypher]
----
// Direct traversal, no joins
MATCH (o:Order {orderId: 10248})-[:ORDERS]->(p:Product)
RETURN p.productName;
----

**Why this is better:**

* **No JOIN overhead** - Direct traversal from order to products
* **Semantic meaning** - `ORDERS` describes the relationship
* **Properties on relationships** - Store quantity, price, discount right on the relationship
* **Flexible queries** - Easy to traverse in any direction


```mermaid
graph TB
    A[Customer: ACME] -->|PLACED| B[Order: #10248]
    A -->|PLACED| C[Order: #10249]
    A -->|PLACED| D[Order: #10250]

    B -->|ORDERS<br/>qty, price| E[Product: Chai]
    B -->|ORDERS<br/>qty, price| F[Product: Coffee]
```


This is natural in graphs because relationships are first-class data structures, not artificial join tables.


[.slide.discrete]
== Modeling Self-Referencing Relationships

A node can have a relationship to itself (same label). In Northwind, employees report to other employees:


```mermaid
graph LR
    A[Employee: Nancy] -->|REPORTS_TO| B[Employee: Andrew]
    C[Employee: Janet] -->|REPORTS_TO| B
    D[Employee: Margaret] -->|REPORTS_TO| A
```


This creates a hierarchy or tree structure within the graph.


[.slide.discrete]
== Adding Relationship Properties

Some data belongs on the relationship itself, not on either node.


**Why store properties on relationships?**


In Northwind, an order contains products. But quantity, price, and discount aren't properties of the order OR the product—they're properties of **the connection between them**.


```mermaid
graph LR
    A[Order] -->|"ORDERS<br/>quantity: 10<br/>unitPrice: 18.00<br/>discount: 0.05"| B[Product]
```


**Why not store this on the Product node?**

* Product price changes over time
* Historical orders need the price at the time they were placed
* Different orders might have different discounts


**Why not store this on the Order node?**

* An order contains many products
* Each product has its own quantity and price
* You'd need a complex nested structure


**Why relationships are the right place:**

* `quantity` describes "how many of this product in this order"
* `unitPrice` captures "what was the price when this order was placed"
* `discount` represents "the discount applied to this product in this order"


This data exists **because of the relationship**, so it belongs on the relationship.


In a relational database, this becomes the `order_details` pivot table—but in a graph, you model it naturally as relationship properties.


[.slide.discrete]
== Understanding Fanout

**Fanout** is when one node connects to many others. This is common and performant in Neo4j:


```mermaid
graph TB
    A[Product: Chai] -->|SUPPLIED_BY| B[Supplier: Exotic Liquids]
    A -->|PART_OF| C[Category: Beverages]

    D[Order: #10248] -->|ORDERS| A
    E[Order: #10249] -->|ORDERS| A
    F[Order: #10250] -->|ORDERS| A
    G[Order: #10251] -->|ORDERS| A
```


A popular product might appear in thousands of orders - Neo4j handles this efficiently.


[.slide.discrete]
== Reviewing the Complete Northwind Data Model

The complete data model with all nodes and relationships:


```mermaid
graph TB
    Customer[Customer] -->|PLACED| Order[Order]
    Order -->|ORDERS| Product[Product]
    Product -->|PART_OF| Category[Category]
    Product -->|SUPPLIED_BY| Supplier[Supplier]
    Employee[Employee] -->|SOLD| Order
    Employee -->|REPORTS_TO| Employee
```


[.summary]
== Summary

In this lesson, you learned about relationships in Neo4j:


* **Relationships** connect nodes and represent associations between entities
* **Every relationship** has a type, direction, and can have properties
* **Naming conventions** use verbs in UPPER_SNAKE_CASE (e.g., `PLACED`, `REPORTS_TO`)
* **Multiple relationships** of the same or different types are common and performant
* **Self-referencing relationships** create hierarchies (e.g., employee reporting structures)
* **Relationship properties** store contextual data (e.g., quantity, price, discount)
* **The Northwind model** includes relationships like `PLACED`, `ORDERS`, `PART_OF`, `SUPPLIED_BY`, `SOLD`, and `REPORTS_TO`


In the next lesson, you will learn how to define properties for nodes and relationships.

read::Mark as completed[]
