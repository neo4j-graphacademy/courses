= Optional Practice with Multi-Hop Queries
:type: lesson
:order: 4
:duration: 15
:optional: true

// Original content - practice queries for multi-hop patterns

[.slide.discrete]
== Optional Practice

You have the complete Customer→Order→Product path. This optional lesson lets you practice complex multi-hop queries and aggregations.

**Advanced learners:** Feel free to skip to the next module.

**Beginners:** These exercises will prepare you for the recommendation query in Module 6.


[.slide]
== Practice Query 1: ANTON's Most Ordered Product

Find customer ANTON's favorite product by quantity:

[source,cypher]
.ANTON's top product
----
MATCH (c:Customer {customerId: 'ANTON'})-[:PLACED]->(:Order)-[r:CONTAINS]->(p:Product)  // (1)
RETURN p.productName,                                                                  // (2)
       sum(r.quantity) AS totalQuantity                                                // (3)
ORDER BY totalQuantity DESC                                                            // (4)
LIMIT 1;                                                                               // (5)
----

<1> **Two-hop pattern** - Traverse to products with relationship variable
<2> **Product name** - Group by product
<3> **Sum quantities** - Aggregate across all orders
<4> **Sort descending** - Highest first
<5> **Top 1** - The favorite product

Click **Run** to see ANTON's most ordered product.

**Try experimenting:**

* Change 'ANTON' to other customers ('ALFKI', 'BOLID', 'BONAP')
* Change `LIMIT 1` to `LIMIT 5` to see top 5 products
* Add `count(DISTINCT r) AS timesOrdered` to see how many orders


[.slide]
== Practice Query 2: Products Never Ordered

Find products that haven't been ordered yet:

[source,cypher]
.Products with no orders
----
MATCH (p:Product)                      // (1)
WHERE NOT (p)<-[:CONTAINS]-(:Order)      // (2)
RETURN p.productName, p.unitPrice      // (3)
ORDER BY p.unitPrice DESC;             // (4)
----

<1> **All products** - Start with every product
<2> **Negative pattern** - Filter to products WITHOUT incoming CONTAINS relationships
<3> **Product details** - Show name and price
<4> **Sort** - Most expensive first

Click **Run** to find products that need marketing!

**This pattern is critical** - you'll use `WHERE NOT` in the recommendation query to exclude products you've already bought.


[.slide]
== Practice Query 3: High-Value Orders

Find orders with total value over $500:

[source,cypher]
.Orders worth more than $500
----
MATCH (o:Order)-[r:CONTAINS]->(p:Product)                      // (1)
WITH o, sum(r.quantity * r.unitPrice) AS orderTotal          // (2)
WHERE orderTotal > 500                                        // (3)
RETURN o.orderId, orderTotal                                 // (4)
ORDER BY orderTotal DESC;                                     // (5)
----

<1> **Match pattern** - Orders and their products
<2> **Aggregate with WITH** - Calculate total per order, keep order reference
<3> **Filter aggregation** - Only high-value orders
<4> **Return results** - Order ID and total value
<5> **Sort** - Highest value first

Click **Run** to find your biggest orders.

**Try experimenting:**

* Change threshold to $1000
* Add customer: `MATCH (c:Customer)-[:PLACED]->(o:Order)...` and return `c.companyName`


[.slide]
== Practice Query 4: Customers Who Bought Same Products

Find customers who bought the same products as ALFKI (similar taste!):

[source,cypher]
.Customers with similar purchases to ALFKI
----
MATCH (me:Customer {customerId: 'ALFKI'})-[:PLACED]->(:Order)-[:CONTAINS]->(p:Product)  // (1)
MATCH (p)<-[:CONTAINS]-(:Order)<-[:PLACED]-(other:Customer)                             // (2)
WHERE other <> me                                                                      // (3)
RETURN other.companyName,                                                              // (4)
       count(DISTINCT p) AS sharedProducts                                             // (5)
ORDER BY sharedProducts DESC                                                           // (6)
LIMIT 10;                                                                              // (7)
----

<1> **Find my products** - What ALFKI bought
<2> **Find other customers** - Traverse backward from products to other buyers
<3> **Exclude myself** - Don't include ALFKI in results
<4> **Customer name** - Group by other customers
<5> **Count shared products** - How many products in common
<6> **Sort** - Most similar customers first
<7> **Top 10** - Most relevant customers

Click **Run** to find customers with similar taste to ALFKI.

**This is the foundation of collaborative filtering!** You're finding "people like me" based on shared purchases.


[.slide]
== Practice Query 5: Product Co-Purchases

Find products frequently bought together:

[source,cypher]
.What products are bought with Chai?
----
MATCH (p1:Product {productName: 'Chai'})<-[:CONTAINS]-(o:Order)-[:CONTAINS]->(p2:Product)  // (1)
WHERE p2 <> p1                                                                          // (2)
RETURN p2.productName,                                                                  // (3)
       count(DISTINCT o) AS timesBoughtTogether                                         // (4)
ORDER BY timesBoughtTogether DESC                                                       // (5)
LIMIT 10;                                                                               // (6)
----

<1> **Pattern** - Find orders containing Chai, see what else is in those orders
<2> **Exclude Chai** - Don't include Chai itself
<3> **Other products** - Group by product
<4> **Count orders** - How many orders had both products
<5> **Sort** - Most frequent combinations first
<6> **Top 10** - Best combinations

Click **Run** to see products often bought with Chai.

**Use case:** "Customers who bought this also bought..."


[.slide]
== Practice Query 6: Customer Product Affinity

Find which categories customer ALFKI prefers:

[source,cypher]
.ALFKI's favorite product categories
----
MATCH (c:Customer {customerId: 'ALFKI'})-[:PLACED]->(:Order)-[r:CONTAINS]->(p:Product)-[:IN_CATEGORY]->(cat:Category)  // (1)
RETURN cat.categoryName,                                                                                              // (2)
       sum(r.quantity) AS totalQuantity,                                                                              // (3)
       count(DISTINCT p) AS uniqueProducts                                                                            // (4)
ORDER BY totalQuantity DESC;                                                                                          // (5)
----

<1> **Three-hop pattern** - Customer→Order→Product→Category
<2> **Category name** - Group by category
<3> **Total quantity** - Sum across all products in category
<4> **Product variety** - How many different products tried
<5> **Sort** - Highest quantity first

**Note:** This query requires Categories to be imported (you'll do this in Module 7). For now, it won't return results.


[.slide]
== Challenge: Complex Business Question

Try answering this question:

**"Which customers have spent more than $5,000 total, ordered more than 20 items, and bought products from at least 5 different categories?"**

**Hints:**

* Use multiple `WITH` clauses to build up the answer
* Calculate `sum(r.quantity * r.unitPrice)` for spending
* Count `DISTINCT p` for items
* Count `DISTINCT cat` for categories (if categories imported)
* Filter with WHERE after aggregations


[.summary]
== Summary

In this optional lesson, you practiced multi-hop queries:

* **Customer favorites** - Aggregating quantities across orders
* **Negative patterns** - Finding products WITHOUT orders using `WHERE NOT`
* **High-value orders** - Filtering on aggregated totals
* **Similar customers** - Finding buyers of same products (collaborative filtering foundation)
* **Co-purchases** - Products bought together in same orders
* **Category affinity** - Three-hop patterns with aggregation

These patterns are the building blocks of the recommendation query you'll build in Module 6.

In the next module, you will learn bidirectional traversals to find customers with similar purchase patterns.

read::Mark as completed[]
