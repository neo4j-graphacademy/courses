= Understanding Relationships
:type: lesson
:order: 1
:duration: 10

// Source: workshop-importing/modules-backup-original/2-data-modeling/lessons/4-relationships
// Adapted: Focused on PLACED relationship, connected to recommendation goal

[.slide.discrete]
== Introduction

In the previous module, you imported Product nodes. Nodes alone cannot answer complex questions - you need to connect them with relationships.

In this lesson, you will learn about relationships in Neo4j and why they are key to building your recommendation system.


[.slide]
== What Are Relationships?

**Relationships** connect nodes and represent associations between entities.

Every relationship has:

* **Type** - A name that describes the connection (PLACED, ORDERS, SUPPLIES)
* **Direction** - Points from one node to another (Customer→Order)
* **Properties** - Optional attributes that describe the relationship (orderDate, quantity)

Relationships are **first-class citizens** in Neo4j - they're not just foreign keys in a table.


[.slide]
== Why Relationships Matter

**The Relational Problem:**

In SQL, connections are foreign keys:

```sql
customers table: customerId (PK)
orders table: customerId (FK), orderId (PK)
```

To find a customer's orders, you JOIN:

```sql
SELECT * FROM customers c
JOIN orders o ON c.customerId = o.customerId
WHERE c.customerId = 'ALFKI';
```

The JOIN scans both tables, matches keys, and combines rows. This gets slow with millions of records.


**The Graph Solution:**

In Neo4j, connections are direct relationships:

```
(Customer {customerId: 'ALFKI'})-[:PLACED]->(Order {orderId: 10248})
```

To find orders, you traverse:

```cypher
MATCH (c:Customer {customerId: 'ALFKI'})-[:PLACED]->(o:Order)
RETURN o;
```

No JOIN - you follow the pointer directly. Performance stays constant regardless of database size.


[.slide]
== Modeling Decision: Direct Relationship vs Intermediate Node

**The question:** How should we model the connection between Customer and Product?

We have two options:

**Option 1: Direct relationship**
```
(Customer)-[:PURCHASED {quantity: 10, discount: 0.05}]->(Product)
```

**Option 2: Intermediate node**
```
(Customer)-[:PLACED]->(Order)-[:CONTAINS {quantity: 10}]->(Product)
```

**How do you choose?**


[.slide]
== Option 1: Direct Relationship

**When it's good enough:**

[source,mermaid]
....
graph LR
    Customer((Customer)) -->|PURCHASED| Product((Product))

    style Customer fill:#4C8EDA
    style Product fill:#FCC644
....

**Use a direct relationship when:**

* You only need to know **that** a connection exists
* The relationship properties are simple (quantity, discount, price)
* You're answering questions like: "What products did this customer buy?" or "How many times was this product purchased?"

**Properties on the relationship:**
```
-[:PURCHASED {quantity: 10, unitPrice: 18.00, discount: 0.05, date: '2024-01-15'}]->
```

**Advantages:**
* Simpler model
* Faster queries (one hop instead of two)
* Less storage
* Perfect for straightforward many-to-many relationships


[.slide]
== Option 2: Intermediate Node (Order)

**When you need more context:**

[source,mermaid]
....
graph LR
    Customer((Customer)) -->|PLACED| Order((Order))
    Order -->|CONTAINS| Product((Product))
    Employee((Employee)) -->|PROCESSED| Order
    Shipper((Shipper)) -->|SHIPPED| Order

    style Customer fill:#4C8EDA
    style Order fill:#7CCFA9
    style Product fill:#FCC644
    style Employee fill:#B8A5D6
    style Shipper fill:#F4A261
....

**Use an intermediate node when:**

* You need to link the connection to **other entities** (Employee, Shipper, Warehouse)
* The connection has its own **identity and lifecycle** (order status, tracking number)
* You're answering questions like: "When was this ordered?" "Who processed this?" "How was it shipped?"

**The Order node enables:**
```cypher
// Find orders processed by a specific employee
MATCH (emp:Employee)-[:PROCESSED]->(o:Order)

// Find orders shipped by a specific company
MATCH (shipper:Shipper)-[:SHIPPED]->(o:Order)

// Find orders with specific status or date range
MATCH (o:Order)
WHERE o.orderDate > '2024-01-01' AND o.status = 'Shipped'
```

**Advantages:**
* More flexible - can connect to many other entities
* Captures the **context** of the transaction
* Models the real-world concept (orders are things)


[.slide]
== The Northwind Decision: Why We Use Order Nodes

**For the Northwind dataset, we chose the intermediate node approach:**

```
(Customer)-[:PLACED]->(Order)-[:CONTAINS]->(Product)
```

**Why?**

1. **Multiple products per order** - An order can contain many products. Without the Order node, you'd have multiple PURCHASED relationships from the same customer to multiple products, with no way to group them.

2. **Order metadata** - Orders have their own properties: `orderDate`, `shippedDate`, `freight`, `shipAddress`, `orderStatus`

3. **Additional relationships** - Orders connect to:
   - `(Employee)-[:PROCESSED]->(Order)` - Who handled the order
   - `(Shipper)-[:SHIPPED]->(Order)` - How it was delivered

4. **Business questions** - We want to answer:
   - "Show me all products from order #10248"
   - "Which employee processes the most orders?"
   - "What orders are shipped by FedEx?"


[.slide]
== When to Promote a Relationship to a Node

**Promote a relationship to a node when:**

* ✅ The relationship needs to connect to other entities (Order connects to Employee, Shipper)
* ✅ The relationship has its own properties that describe it as an entity (orderDate, shipAddress)
* ✅ Multiple relationships need to be grouped (multiple products in one order)
* ✅ You need to query the relationship itself (find orders by date, status)

**Keep it as a relationship when:**

* ✅ It's a simple connection with minimal properties
* ✅ You only need to know "A is connected to B"
* ✅ Performance is critical and you don't need the extra context


[.slide]
== Refactoring Is Always Possible

**Important principle:** You can refactor your graph model in either direction.

**Simplify (Node → Relationship):**
```cypher
// If you decide Order nodes aren't needed
MATCH (c:Customer)-[:PLACED]->(o:Order)-[:CONTAINS]->(p:Product)
MERGE (c)-[:PURCHASED {date: o.orderDate}]->(p)
```

**Promote (Relationship → Node):**
```cypher
// If you decide purchases need more context
MATCH (c:Customer)-[r:PURCHASED]->(p:Product)
CREATE (c)-[:PLACED]->(o:Order {date: r.date})-[:CONTAINS]->(p)
```

**Best practice:** Err on the side of the **more complex model** (intermediate node) until you have performance requirements.

* More complex models are more flexible
* You can always simplify later
* Premature optimization limits your options


[.slide]
== The PLACED Relationship

For recommendations, you need to know **who bought what**.

The path is: Customer → Order → Product

The first step is connecting Customers to Orders with the PLACED relationship:

[source,mermaid]
....
graph LR
    Customer((Customer)) -->|PLACED| Order((Order))

    style Customer fill:#4C8EDA
    style Order fill:#7CCFA9
....

**Meaning:** Customer PLACED an Order

**Direction:** Customer→Order (the natural flow of the action)

**Properties:** You could add `placedDate` or `paymentMethod` to the relationship


[.slide]
== Relationship Direction

Every relationship has a direction, but you can query in **either direction**:

**Outgoing (follow the arrow):**

[source,cypher]
.What orders did this customer place?
----
MATCH (c:Customer {customerId: 'ALFKI'})-[:PLACED]->(o:Order)
RETURN o;
----

**Incoming (reverse the arrow):**

[source,cypher]
.Which customer placed this order?
----
MATCH (c:Customer)<-[:PLACED]-(o:Order {orderId: 10248})
RETURN c;
----

**Bidirectional (ignore direction):**

[source,cypher]
.Find all customer-order connections
----
MATCH (c:Customer)-[:PLACED]-(o:Order)
RETURN c, o LIMIT 5;
----

The direction in the data model represents the semantic meaning, but queries are flexible.


[.slide]
== Relationship Properties

Relationships can have properties that describe the connection:

[source,cypher]
.Query relationship properties
----
MATCH (c:Customer)-[r:PLACED]->(o:Order)  // (1)
WHERE r.orderDate = '1996-07-04'          // (2)
RETURN c.companyName, o.orderId, r.shipCountry
LIMIT 5;
----

<1> **Relationship variable** - `r` captures the relationship so we can access its properties
<2> **Filter by property** - Use relationship properties in WHERE clauses

**Why use relationship properties?**

* Data belongs to the **connection**, not either node
* Example: `orderDate` belongs to the act of placing, not to Customer or Order alone
* Example: `quantity` belongs to the Order-Product connection (we'll see this in Module 4)


[.slide]
== Connection to the Goal

To recommend products, you need to know:

1. **Who placed orders?** (Customer→Order via PLACED)
2. **What products were ordered?** (Order→Product via ORDERS - next module)
3. **Who bought similar products?** (traverse backward from products to find other customers)

The PLACED relationship is the first piece of this path.


[.slide]
== Naming Conventions

When naming relationships:

* **Use verbs** - PLACED, ORDERS, SUPPLIES (actions or associations)
* **Use UPPER_SNAKE_CASE** - All caps with underscores for multi-word types
* **Be specific** - PLACED is clearer than RELATED_TO or HAS

Good names make queries self-documenting:

```cypher
(Customer)-[:PLACED]->(Order)  // Reads like English
```


[.summary]
== Summary

In this lesson, you learned about relationships in Neo4j:

* **Relationships connect nodes** - They have a type, direction, and optional properties
* **First-class citizens** - Not foreign keys; direct connections with no JOIN overhead
* **Modeling decision** - Direct relationship vs intermediate node depends on your questions
  * Direct: (Customer)-[:PURCHASED]->(Product) - Simple, fast, good for "what was bought"
  * Intermediate: (Customer)-[:PLACED]->(Order)-[:CONTAINS]->(Product) - Flexible, contextual, good for "when/how/who"
* **Promote to node when** - Need to connect to other entities, has own identity, grouping required
* **Refactoring is possible** - Can always change between relationship and node
* **Best practice** - Err on side of more complex model, optimize later
* **PLACED relationship** - Connects Customer to Order (Customer→Order)
* **Direction flexibility** - Query in any direction regardless of how it's stored
* **Relationship properties** - Data that belongs to the connection itself
* **Connection to goal** - Customer→Order→Product path enables recommendations

In the next lesson, you will import Customer and Order nodes and create PLACED relationships between them.

read::Mark as completed[]
