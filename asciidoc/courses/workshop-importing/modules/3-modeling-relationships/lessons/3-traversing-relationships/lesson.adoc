= Traversing Relationships: Graph vs SQL
:type: lesson
:order: 3

// Original content - graph vs SQL comparison for traversals

[.slide.discrete]
== Introduction

You created PLACED relationships between Customers and Orders. Now you'll see how graph traversals compare to SQL JOINs.

In this lesson, you will understand why traversing relationships is more efficient and readable than JOIN operations.


[.slide]
== The Relational Approach: JOINs

In a relational database, finding a customer's orders requires a JOIN:

**SQL:**
```sql
SELECT c.companyName, o.orderId, o.orderDate
FROM customers c
JOIN orders o ON c.customerID = o.customerID
WHERE c.customerID = 'ALFKI'
ORDER BY o.orderDate;
```

**What happens:**

1. Database scans the customers table to find ALFKI
2. Database scans the orders table
3. For each order row, checks if `o.customerID = c.customerID`
4. Combines matching rows into a result set
5. Sorts by date

**Problems:**

* Table scans become slower as data grows
* JOINs are expensive operations
* Performance degrades with millions of records


[.slide]
== The Graph Approach: Traversals

In Neo4j, you traverse the relationship directly:

[source,cypher]
.Find customer orders (graph traversal)
----
MATCH (c:Customer {customerId: 'ALFKI'})-[:PLACED]->(o:Order)  // (1)
RETURN c.companyName, o.orderId, o.orderDate                    // (2)
ORDER BY o.orderDate;                                            // (3)
----

<1> **Direct traversal** - Find customer, follow PLACED relationships to connected orders
<2> **Return properties** - Get data from the matched nodes
<3> **Sort results** - Order by date

Click **Run** to see ALFKI's orders.

**What happens:**

1. Find the Customer node with customerId = 'ALFKI' (indexed lookup - instant)
2. Follow pointers along PLACED relationships (direct memory access)
3. Return the connected Order nodes

**No table scans. No matching keys. No JOIN overhead.**


[.slide]
== Performance Comparison

**Relational (SQL JOIN):**

* Time complexity: O(n × m) where n = customers, m = orders
* Scans both tables
* Gets slower as data grows
* Query with 1M customers × 10M orders = billions of comparisons

**Graph (Traversal):**

* Time complexity: O(k) where k = number of connected orders
* Only touches connected data
* Performance stays constant
* Query touches only ALFKI's orders (~6 orders), regardless of total data size

**The graph wins because it only touches what you need.**


[.slide]
== Traversing Backward

You can traverse relationships in any direction:

[source,cypher]
.Which customer placed this order?
----
MATCH (c:Customer)<-[:PLACED]-(o:Order {orderId: '10248'})  // (1)
RETURN c.companyName, c.city, c.country;                     // (2)
----

<1> **Reverse traversal** - Start at Order, traverse backward to Customer
<2> **Return customer data** - Get information about who placed the order

The arrow direction in the query (`<-`) indicates you're traversing against the relationship's stored direction.

Click **Run** to find who placed order 10248.


[.slide]
== Counting Relationships

Aggregation with traversals:

[source,cypher]
.How many orders has each customer placed?
----
MATCH (c:Customer)-[:PLACED]->(o:Order)  // (1)
RETURN c.companyName,                    // (2)
       count(o) AS orderCount            // (3)
ORDER BY orderCount DESC                 // (4)
LIMIT 10;                                // (5)
----

<1> **Traverse all PLACED relationships** - Connect all customers to their orders
<2> **Group by customer** - Implicitly groups by c.companyName
<3> **Count orders** - Aggregate the number of orders per customer
<4> **Sort** - Show highest order counts first
<5> **Limit** - Top 10 customers

Click **Run** to see your top customers by order count.

**In SQL, this would require:**
```sql
SELECT c.companyName, COUNT(o.orderID) as orderCount
FROM customers c
LEFT JOIN orders o ON c.customerID = o.customerID
GROUP BY c.companyName
ORDER BY orderCount DESC
LIMIT 10;
```

The Cypher is more readable and performs better at scale.


[.slide]
== Connection to the Goal

You now have Customer→Order traversals working. This is critical for recommendations:

**To find products similar customers bought:**

1. Find my orders: Customer→Order ✅ (you have this now)
2. Find products in my orders: Order→Product (Module 4)
3. Find customers who bought those products: Product←Order←Customer (reverse traversal)
4. Find what else they bought: Customer→Order→Product

Half the path is complete!


[.summary]
== Summary

In this lesson, you learned about graph traversals vs SQL JOINs:

* **SQL JOINs** - Scan tables, match keys, expensive operations that get slower with data growth
* **Graph traversals** - Follow pointers directly, constant performance regardless of database size
* **Performance** - Graphs only touch connected data (O(k)) vs JOINs scanning entire tables (O(n × m))
* **Directionality** - Can traverse relationships in any direction (`->` or `<-`)
* **Aggregation** - Count, sum, collect over relationships without complex GROUP BY
* **Connection to goal** - Customer→Order path is the foundation for finding similar customers

In the next lesson (optional), you can practice writing traversal queries.

read::Mark as completed[]
