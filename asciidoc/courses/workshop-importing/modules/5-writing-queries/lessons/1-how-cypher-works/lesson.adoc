= How Cypher Queries Work
:type: lesson
:order: 1
:duration: 15

[.slide.discrete]
== Introduction

You've built a complete graph with Products, Customers, Orders, and the PLACED and CONTAINS relationships. Now you'll learn how to write Cypher queries to extract insights.

In this lesson, you will understand the fundamental pattern of Cypher queries: finding anchor nodes and following relationships.


[.slide]
== Understanding the Cypher query pattern

Every Cypher query follows this pattern:

1. **Find anchor nodes** - Start with nodes you know (by ID, property, or label)
2. **Follow relationships** - Traverse connections to find related nodes
3. **Return results** - Select what to display

**Example:**
```cypher
MATCH (c:Customer {customerId: 'ALFKI'})-[:PLACED]->(o:Order)
RETURN c.companyName, o.orderId
```

Let's break down each part.


[.slide]
== Finding anchor nodes

**Anchor nodes are your starting point.** You need something to grab onto before you can traverse.

**Find by property:**
[source,cypher]
----
MATCH (c:Customer {customerId: 'ALFKI'})  // (1)
RETURN c.companyName                      // (2)
----

<1> **Anchor** - Find Customer node with specific ID
<2> **Return** - Display the company name

**Find by label (all nodes of a type):**
[source,cypher]
----
MATCH (p:Product)         // (1)
RETURN count(p)           // (2)
----

<1> **Anchor** - Find all Product nodes
<2> **Return** - Count how many

**The anchor is where your query begins.**


[.slide]
== Following relationships

**Once you have an anchor, follow relationships to find connected nodes.**

**One hop:**
[source,cypher]
----
MATCH (c:Customer {customerId: 'ALFKI'})-[:PLACED]->(o:Order)  // (1)
RETURN o.orderId, o.orderDate                                  // (2)
ORDER BY o.orderDate                                           // (3)
----

<1> **Follow PLACED** - From Customer to Order
<2> **Return orders** - Show order details
<3> **Sort** - By order date

**Two hops:**
[source,cypher]
----
MATCH (c:Customer {customerId: 'ALFKI'})-[:PLACED]->(:Order)-[:CONTAINS]->(p:Product)   // (1)
RETURN DISTINCT p.productName                                                           // (2)
ORDER BY p.productName                                                                  // (3)
----

<1> **Follow two relationships** - Customer → Order → Product
<2> **Return products** - What this customer bought
<3> **Sort** - Alphabetically

**Anonymous nodes:** Notice `(:Order)` - we don't need to name it if we're not using it in the RETURN.


[.slide]
== Example 1: products a customer bought

**Business question:** "What products did ALFKI buy?"

[source,cypher]
.ALFKI's products
----
MATCH (c:Customer {customerId: 'ALFKI'})-[:PLACED]->(:Order)-[:CONTAINS]->(p:Product)   // (1) (2) (3)
RETURN p.productName, p.unitPrice                                                       // (4)
ORDER BY p.productName                                                                  // (5)
----

<1> **Anchor** - Start with Customer ALFKI
<2> **Follow PLACED** - Get their orders
<3> **Follow CONTAINS** - Get products in those orders
<4> **Return** - Product details
<5> **Sort** - Alphabetically

**Pattern:** Anchor → Follow → Follow → Return


[.slide]
== Example 2: customers who bought a product

**Business question:** "Who bought Chai?"

[source,cypher]
.Chai buyers
----
MATCH (c:Customer)-[:PLACED]->(:Order)-[:CONTAINS]->(p:Product {productName: 'Chai'})  // (1) (2) (3)
RETURN c.customerId, c.companyName                                                      // (4)
ORDER BY c.companyName                                                                  // (5)
----

<1> **Anchor** - Start with Product "Chai"
<2> **Follow backwards** - Get orders containing Chai
<3> **Follow backwards** - Get customers who placed those orders
<4> **Return** - Customer details
<5> **Sort** - By company name

**Direction doesn't matter:** You can traverse relationships in either direction.


[.slide]
== Example 3: aggregating results

**Business question:** "How many products has each customer bought?"

[source,cypher]
.Customer purchase counts
----
MATCH (c:Customer)-[:PLACED]->(:Order)-[:CONTAINS]->(p:Product)  // (1)
RETURN c.companyName,                                             // (2)
       count(DISTINCT p) AS productCount                          // (3)
ORDER BY productCount DESC                                        // (4)
LIMIT 10                                                          // (5)
----

<1> **Pattern** - Customer → Order → Product
<2> **Group by** - Customer name (implicit grouping)
<3> **Aggregate** - Count distinct products
<4> **Sort** - Highest counts first
<5> **Limit** - Top 10 customers

**Aggregations:** `count()`, `sum()`, `avg()`, `max()`, `min()`, `collect()`


[.slide]
== Example 4: filtering with WHERE

**Business question:** "Which customers from Germany have placed orders?"

[source,cypher]
.German customers with orders
----
MATCH (c:Customer)-[:PLACED]->(o:Order)  // (1)
WHERE c.country = 'Germany'              // (2)
RETURN c.companyName,                    // (3)
       count(o) AS orderCount            // (4)
ORDER BY orderCount DESC                 // (5)
----

<1> **Pattern** - Customer with orders
<2> **Filter** - Only German customers
<3> **Return** - Company name
<4> **Aggregate** - Count their orders
<5> **Sort** - Most orders first

**WHERE clause:** Filters nodes or relationships by properties.


[.slide]
== Example 5: relationship properties

**Business question:** "What products did ALFKI buy and how many of each?"

[source,cypher]
.ALFKI's purchases with quantities
----
MATCH (c:Customer {customerId: 'ALFKI'})-[:PLACED]->(:Order)-[r:CONTAINS]->(p:Product)  // (1)
RETURN p.productName,                                                                     // (2)
       sum(r.quantity) AS totalQuantity                                                   // (3)
ORDER BY totalQuantity DESC                                                               // (4)
----

<1> **Capture relationship** - `r:CONTAINS` stores the relationship in variable `r`
<2> **Return product** - Product name
<3> **Sum quantities** - Add up quantity property from all CONTAINS relationships
<4> **Sort** - Most purchased first

**Relationship properties:** Store data that belongs to the connection (quantity, price, date).


[.slide]
== Understanding indexes and constraints

**Indexes and constraints make your queries fast and data quality high.**

**Without them:** Neo4j scans all nodes to find matches (slow)

**With them:** Neo4j uses direct lookups (fast)


[.slide]
== Creating uniqueness constraints

**Ensure a property value is unique and create an automatic index:**

[source,cypher]
.Create constraint on productName
----
CREATE CONSTRAINT product_name_unique
FOR (p:Product)
REQUIRE p.productName IS UNIQUE;
----

**What this does:**
* Prevents duplicate product names
* Automatically creates an index on `productName`
* Makes lookups instant: `O(1)` instead of `O(n)`

**Use constraints for:** Entity IDs and unique identifiers


[.slide]
== Improving CONTAINS queries with constraints

**Query without constraint:**

[source,cypher]
----
MATCH (:Order)-[:CONTAINS]->(p:Product {productName: 'Chai'})
RETURN count(*);
----

Without constraint: **Scans all Product nodes** to find 'Chai'

**Query with constraint:**

Same query, but with `product_name_unique` constraint:
* **Direct index lookup** to find 'Chai'
* 100x+ faster on large datasets

**The constraint makes finding products by name instant.**


[.slide]
== Setting up common constraints

[source,cypher]
.Essential constraints for the workshop
----
// Product name uniqueness
CREATE CONSTRAINT product_name_unique
FOR (p:Product)
REQUIRE p.productName IS UNIQUE;

// Customer ID uniqueness
CREATE CONSTRAINT customer_id_unique
FOR (c:Customer)
REQUIRE c.customerId IS UNIQUE;

// Order ID uniqueness
CREATE CONSTRAINT order_id_unique
FOR (o:Order)
REQUIRE o.orderId IS UNIQUE;
----

**Best practice:** Create constraints on properties you frequently use to find nodes.


[.slide]
== Creating indexes for range queries

**For properties used in comparisons or sorting:**

[source,cypher]
.Create index on unitPrice
----
CREATE INDEX product_price_index
FOR (p:Product)
ON (p.unitPrice);
----

**Use case:**
```cypher
MATCH (p:Product)
WHERE p.unitPrice < 20    // Index speeds up range queries
RETURN p.productName, p.unitPrice
ORDER BY p.unitPrice;     // Index speeds up sorting
```

**When to index:** Properties in WHERE clauses or ORDER BY


[.slide]
== Optimizing the recommendation query

**The recommendation query benefits from constraints:**

[source,cypher]
----
MATCH (me:Customer {customerId: 'ALFKI'})-[:PLACED]->(:Order)-[:CONTAINS]->(myProduct:Product)
RETURN myProduct
----

* `customerId` constraint → Instant Customer lookup
* `productName` constraint → Fast Product identification

**Without constraints:** Scans all Customers to find 'ALFKI'

**With constraints:** Direct index lookup - 100x+ faster

**Performance improvement is dramatic on large graphs!**


[.slide]
== Following the query building process

**When writing a query:**

1. **Identify what you know** → That's your anchor
   - "Customer ALFKI" → `(c:Customer {customerId: 'ALFKI'})`
   - "All products" → `(p:Product)`

2. **Draw the path** → Follow relationships to get what you need
   - Want orders? → `-[:PLACED]->(o:Order)`
   - Want products? → `-[:CONTAINS]->(p:Product)`

3. **Add filters** → Use WHERE for conditions
   - `WHERE p.unitPrice < 20`
   - `WHERE c.country = 'Germany'`

4. **Choose what to return** → Select, aggregate, sort
   - `RETURN p.productName, p.unitPrice`
   - `count()`, `sum()`, `ORDER BY`, `LIMIT`

5. **Consider constraints and indexes** → For frequently queried properties
   - Create constraints on unique identifiers
   - Create indexes on properties used in WHERE/ORDER BY


[.summary]
== Summary

In this lesson, you learned how Cypher queries work:

* **Anchor nodes** - Start with nodes you know (by ID, property, or label)
* **Follow relationships** - Traverse one or more hops to find connected nodes
* **Anonymous nodes** - Use `(:Label)` when you don't need to reference a node
* **Direction flexibility** - Traverse relationships forward or backward
* **Aggregations** - Use `count()`, `sum()`, `avg()` to calculate results
* **WHERE filtering** - Add conditions to filter nodes or relationships
* **Relationship properties** - Access data on connections with `[r:TYPE]`
* **Uniqueness constraints** - Ensure unique values and create automatic indexes
* **Indexes** - Speed up lookups, range queries, and sorting
* **Performance impact** - Constraints make CONTAINS queries 100x+ faster
* **Query pattern** - Anchor → Follow → Filter → Return → Consider indexes

In the next lesson, you'll practice writing queries to answer business questions.

read::Mark as completed[]
