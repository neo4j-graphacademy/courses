= Building the Recommendation Query
:type: lesson
:order: 1
:duration: 10

[.slide.discrete]
== Introduction

You've imported the nodes.  You've created the relationships.  You've practiced writing queries.

Now you'll build the complete recommendation query that answers: **"What products do people like me buy, that I haven't bought yet?"**

In this lesson, you will construct the recommendation algorithm step by step.


[.slide]
== Understanding the recommendation algorithm

**Collaborative filtering** finds recommendations based on similar customers:

1. **Find my products** - What I've purchased
2. **Find similar customers** - Who else bought those products
3. **Find their products** - What they purchased
4. **Exclude my products** - Only show things I haven't bought
5. **Rank by popularity** - Most recommended first


[.slide]
== Step 1: finding my products

Start with what customer ALFKI has purchased:

[source,cypher]
.My purchase history
----
MATCH (me:Customer {id: 'ALFKI'})-[:PLACED]->(:Order)-[:CONTAINS]->(myProduct:Product)
RETURN DISTINCT myProduct.name
ORDER BY myProduct.name;
----

This finds all products ALFKI has ever bought.


[.slide]
== Step 2: finding similar customers

Who else bought the same products?

[source,cypher]
.Customers with similar purchases
----
MATCH (me:Customer {id: 'ALFKI'})-[:PLACED]->(:Order)-[:CONTAINS]->(myProduct:Product)
MATCH (myProduct)<-[:CONTAINS]-(:Order)<-[:PLACED]-(other:Customer)                             // (1)
WHERE other <> me                                                                                // (2)
RETURN other.name, count(DISTINCT myProduct) AS sharedProducts                           // (3)
ORDER BY sharedProducts DESC                                                                     // (4)
LIMIT 10;                                                                                        // (5)
----

<1> **Similar customers** - Backward traversal from products to find customers who bought same products
<2> **Exclude me** - Don't include ALFKI in the results
<3> **Count shared** - How many products in common
<4> **Sort** - Most similar first
<5> **Top 10** - Most relevant

This finds customers with the most similar taste.


[.slide]
== Step 3: finding their products

What did similar customers buy?

[source,cypher]
.Products similar customers bought
----
MATCH (me:Customer {id: 'ALFKI'})-[:PLACED]->(:Order)-[:CONTAINS]->(myProduct:Product)
MATCH (myProduct)<-[:CONTAINS]-(:Order)<-[:PLACED]-(other:Customer)
WHERE other <> me
MATCH (other)-[:PLACED]->(:Order)-[:CONTAINS]->(rec:Product)                                    // (1)
RETURN DISTINCT rec.name, count(DISTINCT other) AS recommendedBy                         // (2)
ORDER BY recommendedBy DESC
LIMIT 10;
----

<1> **Their products** - Forward traversal from similar customers to find what they bought
<2> **Count recommendations** - How many similar customers recommend each product

**Problem:** This includes products ALFKI already bought!


[.slide]
== Step 4: excluding my products

Add a filter to exclude products I already own:

[source,cypher]
.Recommendations excluding my purchases
----
MATCH (me:Customer {id: 'ALFKI'})-[:PLACED]->(:Order)-[:CONTAINS]->(myProduct:Product)
MATCH (myProduct)<-[:CONTAINS]-(:Order)<-[:PLACED]-(other:Customer)
WHERE other <> me
MATCH (other)-[:PLACED]->(:Order)-[:CONTAINS]->(rec:Product)
WHERE NOT (me)-[:PLACED]->(:Order)-[:CONTAINS]->(rec)                                           // (1)
RETURN rec.name, count(DISTINCT other) AS recommendedBy
ORDER BY recommendedBy DESC
LIMIT 10;
----

<1> **Exclude my purchases** - WHERE NOT checks if a path exists from me to the recommended product



[.slide]
== Step 5: adding product details

Enrich with price and availability:

[source,cypher]
.Complete recommendations with details
----
MATCH (me:Customer {id: 'ALFKI'})-[:PLACED]->(:Order)-[:CONTAINS]->(myProduct:Product)
MATCH (myProduct)<-[:CONTAINS]-(:Order)<-[:PLACED]-(other:Customer)
WHERE other <> me
MATCH (other)-[:PLACED]->(:Order)-[:CONTAINS]->(rec:Product)
WHERE NOT (me)-[:PLACED]->(:Order)-[:CONTAINS]->(rec)
  AND rec.unitsInStock > 0                                                                       // (1)
RETURN rec.name,
       rec.unitPrice,                                                                            // (2)
       rec.unitsInStock,                                                                         // (3)
       count(DISTINCT other) AS recommendedBy
ORDER BY recommendedBy DESC, rec.unitPrice                                                       // (4)
LIMIT 10;
----

<1> **Filter available** - Only show in-stock products
<2> **Price** - Include unit price for each recommendation
<3> **Stock level** - Show how many units are available
<4> **Secondary sort** - Sort by popularity first, then by price


[.slide]
== Comparing to SQL

Here's the same query in SQL (simplified):

[source,sql]
----
-- Find my products
WITH my_products AS (
  SELECT DISTINCT od.productID
  FROM customers c
  JOIN orders o ON c.customerID = o.customerID
  JOIN order_details od ON o.orderID = od.orderID
  WHERE c.customerID = 'ALFKI'
),
-- Find similar customers
similar_customers AS (
  SELECT DISTINCT c2.customerID
  FROM customers c2
  JOIN orders o2 ON c2.customerID = o2.customerID
  JOIN order_details od2 ON o2.orderID = od2.orderID
  WHERE od2.productID IN (SELECT productID FROM my_products)
    AND c2.customerID <> 'ALFKI'
),
-- Find recommendations
recommendations AS (
  SELECT od3.productID, COUNT(DISTINCT sc.customerID) as recommendedBy
  FROM similar_customers sc
  JOIN orders o3 ON sc.customerID = o3.customerID
  JOIN order_details od3 ON o3.orderID = od3.orderID
  WHERE od3.productID NOT IN (SELECT productID FROM my_products)
  GROUP BY od3.productID
)
SELECT p.name, p.unitPrice, p.unitsInStock, r.recommendedBy
FROM recommendations r
JOIN products p ON r.productID = p.productID
WHERE p.unitsInStock > 0
ORDER BY r.recommendedBy DESC, p.unitPrice
LIMIT 10;
----

**38 lines vs 11 lines!**


[.slide]
== Analyzing Cypher vs SQL

| Metric | Cypher | SQL |
|--------|--------|-----|
| **Lines of code** | 11 | 38 |
| **JOINs** | 0 | 7 |
| **CTEs/Subqueries** | 0 | 3 CTEs + 2 subqueries |
| **Readability** | Reads like the question | Complex nested logic |
| **Performance** | O(k) - scales with connections | O(n × m) - table scans |
| **Maintainability** | Easy to modify | Hard to debug |

**Graph databases excel at connected data queries.**


[.slide]
== Experimenting with the query

**Modify the query:**

1. Change customer ID to `'ANTON'` or `'BOLID'`
2. Change LIMIT to see more recommendations
3. Add price filter: `AND rec.unitPrice < 50`
4. Remove stock filter to see all products
5. Show top 20 instead of 10

**Challenge:** Create a weighted score that considers both popularity and price.

read::Mark as completed[]

[.summary]
== Summary

In this lesson, you built the recommendation query:

* **Step 1:** Find my products (forward traversal)
* **Step 2:** Find similar customers (backward traversal)
* **Step 3:** Find their products (forward again)
* **Step 4:** Exclude my products (WHERE NOT pattern)
* **Step 5:** Add filters and details (stock, price)
* **Result:** Production-ready collaborative filtering in 11 lines
* **Comparison:** 11 lines Cypher vs 38 lines SQL
* **Performance:** O(k) graph traversal vs O(n × m) joins

**You've built a real recommendation engine!**

