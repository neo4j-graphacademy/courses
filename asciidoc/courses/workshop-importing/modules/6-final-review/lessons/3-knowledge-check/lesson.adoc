= Knowledge Check
:type: quiz
:order: 3
:duration: 5

// Original content - final knowledge check quiz

[.slide.discrete]
== Test Your Knowledge

You've completed the workshop! Test your understanding with these knowledge check questions.


[.slide]
== Question 1: Node Identification

**Which of the following should be a NODE in a graph model?**

[%interactive]
- [ ] A. Product price (unitPrice)
- [ ] B. Order date (orderDate)
- [x] C. Customer
- [ ] D. Quantity ordered

**Explanation:**
* **C is correct:** Customer is a distinct entity with its own identity, properties, and relationships.
* A, B, D are properties that describe other entities, not entities themselves.

**Recall Module 2:** Nodes represent entities - distinct things with identity, properties, and connections.


[.slide]
== Question 2: Relationships vs Properties

**When should you use a RELATIONSHIP instead of a PROPERTY?**

[%interactive]
- [ ] A. To store a customer's email address
- [ ] B. To store a product's unit price
- [x] C. To connect a customer to their orders
- [ ] D. To store an order's shipping address

**Explanation:**
* **C is correct:** Relationships connect entities. A customer placing orders is a connection between two entities.
* A, B, D are attributes that describe single entities, not connections.

**Recall Module 3:** Relationships have type, direction, and represent associations between entities.


[.slide]
== Question 3: Many-to-Many Transformation

**In a graph, how do you typically handle a many-to-many pivot table?**

[%interactive]
- [ ] A. Keep it as a separate node type
- [ ] B. Store it as properties on both nodes
- [x] C. Transform it into direct relationships
- [ ] D. Ignore it, graphs don't support many-to-many

**Explanation:**
* **C is correct:** Pivot tables become direct relationships. The 2,155 order_details rows became CONTAINS relationships.
* Properties from the pivot table (quantity, unitPrice) move to the relationship.

**Recall Module 4:** Entire pivot table â†’ relationships with properties. This eliminates an extra JOIN.


[.slide]
== Question 4: Cypher Pattern Matching

**What does this Cypher pattern match?**

```cypher
MATCH (c:Customer)-[:PLACED]->(o:Order)-[:CONTAINS]->(p:Product)
```

[%interactive]
- [ ] A. All customers
- [ ] B. All products
- [x] C. Customers, their orders, and the products in those orders (complete path)
- [ ] D. Only customers named 'PLACED'

**Explanation:**
* **C is correct:** This is a two-hop pattern that traverses from Customer through Order to Product.
* It matches the complete path needed for recommendations.

**Recall Module 4:** Multi-hop traversals follow relationships to connect distant entities.


[.slide]
== Question 5: Bidirectional Traversal

**What does this negative pattern do?**

```cypher
WHERE NOT (me)-[:PLACED]->(:Order)-[:CONTAINS]->(rec)
```

[%interactive]
- [ ] A. Finds products I have ordered
- [x] B. Filters out products I have already ordered
- [ ] C. Finds customers who haven't ordered
- [ ] D. Deletes my orders

**Explanation:**
* **B is correct:** This negative pattern excludes products where a path exists from me to that product.
* In recommendations, this ensures you don't recommend products the customer already owns.

**Recall Module 5:** Negative patterns filter out unwanted results using WHERE NOT.


[.slide]
== Question 6: Collaborative Filtering

**What is the core idea behind collaborative filtering?**

[%interactive]
- [ ] A. Filter products by price
- [ ] B. Sort products by popularity
- [x] C. Recommend products that similar customers bought
- [ ] D. Remove out-of-stock products

**Explanation:**
* **C is correct:** Collaborative filtering finds "people like you" and recommends what they bought.
* Pattern: My products â†’ Similar customers â†’ Their products (minus mine)

**Recall Module 5:** Bidirectional traversals find similar customers based on shared purchases.


[.slide]
== Question 7: Graph vs SQL Performance

**Why are graph databases faster for deep relationship queries?**

[%interactive]
- [ ] A. They use more RAM
- [x] B. They follow indexed pointers instead of scanning tables
- [ ] C. They skip data validation
- [ ] D. They don't support transactions

**Explanation:**
* **B is correct:** Graphs use O(k) pointer traversals vs SQL's O(n Ã— m) table scans and JOINs.
* Performance scales with number of connections, not total data size.

**Recall Module 6:** Graph traversals are 80x faster because they follow direct pointers.


[.slide]
== Question 8: The collect() Function

**What does collect() do in Cypher?**

[%interactive]
- [ ] A. Deletes nodes
- [ ] B. Counts nodes
- [x] C. Gathers values into a list during aggregation
- [ ] D. Creates new relationships

**Explanation:**
* **C is correct:** collect() aggregates values into a list, useful for filtering with WHERE NOT IN.
* Example: `collect(p.productName)` creates a list of product names.

**Recall Module 6:** collect() is used to gather my products for filtering recommendations.


[.slide]
== Question 9: Constraints

**What does a uniqueness constraint do?**

[%interactive]
- [ ] A. Speeds up all queries
- [x] B. Prevents duplicate values and automatically creates an index
- [ ] C. Deletes duplicate nodes
- [ ] D. Requires a property to exist

**Explanation:**
* **B is correct:** Uniqueness constraints prevent duplicates (e.g., no two customers with same ID) and auto-create indexes.
* Dramatically improves lookup performance.

**Recall Module 8:** Constraints maintain data quality and improve query performance.


[.slide]
== Question 10: Complete Recommendation Query

**How many lines of Cypher does the complete recommendation query require?**

[%interactive]
- [x] A. 11 lines
- [ ] B. 38 lines
- [ ] C. 100 lines
- [ ] D. 5 lines

**Explanation:**
* **A is correct:** The complete, production-ready recommendation query is 11 lines in Cypher.
* The SQL equivalent is 38 lines with 7 JOINs and 3 CTEs.

**Recall Module 6:** 11 lines Cypher vs 38 lines SQL - that's the graph advantage!


[.slide]
== Score Interpretation

**10/10:** ðŸŒŸ **Graph Master!** You've mastered graph modeling and Cypher.

**8-9/10:** ðŸŽ¯ **Graph Pro!** You understand the core concepts well.

**6-7/10:** ðŸ“ˆ **On the Right Path!** Review modules where you struggled.

**4-5/10:** ðŸ“š **Keep Learning!** Re-visit key lessons, especially Modules 4-6.

**0-3/10:** ðŸ”„ **Start Over!** Take the workshop again, focus on hands-on practice.


[.slide]
== What's Next?

**Continue learning:**
* **GraphAcademy:** https://graphacademy.neo4j.com
* **Neo4j Community:** https://community.neo4j.com
* **Documentation:** https://neo4j.com/docs/
* **Certification:** Neo4j Certified Professional

**Build something:**
* Apply these patterns to your own data
* Build a recommendation system for your project
* Explore graph algorithms and data science
* Join hackathons and contribute to open source


[.summary]
== Summary

In this knowledge check, you tested your understanding of:

* **Node identification** - When to use nodes vs properties
* **Relationships** - Connecting entities, handling many-to-many
* **Cypher patterns** - Multi-hop, bidirectional, negative patterns
* **Collaborative filtering** - Finding similar customers and recommending products
* **Performance** - Why graphs are faster (O(k) vs O(n Ã— m))
* **Cypher functions** - collect(), count(), sum()
* **Constraints** - Maintaining data quality and improving performance

**Congratulations on completing the workshop!** ðŸŽ‰

read::Mark as completed[]
