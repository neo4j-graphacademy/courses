= Graph Data Quality with Constraints and Indexes
:type: lesson
:order: 1
:duration: 10

// Original content - constraints and indexes for data quality

[.slide.discrete]
== Introduction

You've built a complete graph with products, customers, orders, and categories. Now you'll learn how to maintain data quality with constraints and improve query performance with indexes.

In this lesson, you will learn about uniqueness constraints, existence constraints, and indexes in Neo4j.


[.slide]
== Why Data Quality Matters

**Without constraints:**
* Duplicate customer IDs possible
* Products without names
* Orders without IDs
* No guarantee of data integrity

**With constraints:**
* Enforce uniqueness (no duplicate IDs)
* Require properties (no missing critical data)
* Maintain referential integrity
* Automatic indexes for constrained properties


[.slide]
== Uniqueness Constraints

Ensure a property value is unique across all nodes with a label:

[source,cypher]
.Create uniqueness constraint on Customer ID
----
CREATE CONSTRAINT customer_id_unique
FOR (c:Customer)
REQUIRE c.customerId IS UNIQUE;
----

**What this does:**
* Prevents duplicate `customerId` values on Customer nodes
* Automatically creates an index on `customerId` for fast lookups
* Fails if you try to create a Customer with an existing `customerId`

Click **Run** to create the constraint.


[.slide]
== More Uniqueness Constraints

Create constraints for all entity IDs:

[source,cypher]
.Product ID uniqueness
----
CREATE CONSTRAINT product_id_unique
FOR (p:Product)
REQUIRE p.productId IS UNIQUE;
----

[source,cypher]
.Order ID uniqueness
----
CREATE CONSTRAINT order_id_unique
FOR (o:Order)
REQUIRE o.orderId IS UNIQUE;
----

[source,cypher]
.Category ID uniqueness (if categories imported)
----
CREATE CONSTRAINT category_id_unique
FOR (c:Category)
REQUIRE c.categoryId IS UNIQUE;
----

Click **Run** on each to create all ID constraints.


[.slide]
== Node Property Existence Constraints

Require that certain properties must exist (Enterprise Edition only):

[source,cypher]
.Require product names
----
CREATE CONSTRAINT product_name_exists
FOR (p:Product)
REQUIRE p.productName IS NOT NULL;
----

**Note:** This constraint type requires Neo4j Enterprise Edition. In Aura (Community), existence is not enforced, but you can still validate data manually.

**Best practice:** Validate required properties during import using the Data Importer's mapping options.


[.slide]
== Relationship Property Existence

Require properties on relationships (Enterprise only):

[source,cypher]
.Require quantity on CONTAINS relationships
----
CREATE CONSTRAINT orders_quantity_exists
FOR ()-[r:CONTAINS]-()
REQUIRE r.quantity IS NOT NULL;
----

Again, this requires Enterprise Edition. In Community/Aura, validate during import.


[.slide]
== Indexes for Query Performance

Create indexes on properties you frequently query or filter by:

[source,cypher]
.Index on product name for text search
----
CREATE INDEX product_name_index
FOR (p:Product)
ON (p.productName);
----

[source,cypher]
.Index on product price for range queries
----
CREATE INDEX product_price_index
FOR (p:Product)
ON (p.unitPrice);
----

[source,cypher]
.Index on order date for time-based queries
----
CREATE INDEX order_date_index
FOR (o:Order)
ON (o.orderDate);
----

Click **Run** on each to create indexes.

**When to index:** Properties used in WHERE clauses, especially for filtering or range queries.


[.slide]
== Composite Indexes

Index multiple properties together for queries that filter on both:

[source,cypher]
.Composite index on price and stock
----
CREATE INDEX product_price_stock_index
FOR (p:Product)
ON (p.unitPrice, p.unitsInStock);
----

**Use case:** Queries like:
```cypher
MATCH (p:Product)
WHERE p.unitPrice < 20 AND p.unitsInStock > 0
RETURN p;
```

The composite index speeds up queries that filter on both properties.


[.slide]
== Full-Text Search Indexes

Create full-text indexes for text search across properties:

[source,cypher]
.Full-text index on product names
----
CREATE FULLTEXT INDEX product_search
FOR (p:Product)
ON EACH [p.productName, p.quantityPerUnit];
----

**Query with full-text search:**
[source,cypher]
.Search for products containing "chocolate"
----
CALL db.index.fulltext.queryNodes('product_search', 'chocolate')
YIELD node, score
RETURN node.productName, score
ORDER BY score DESC;
----

Click **Run** to create the index, then use the search query.

**Use case:** Product search, autocomplete, fuzzy matching.


[.slide]
== Viewing Constraints and Indexes

**List all constraints:**
[source,cypher]
----
SHOW CONSTRAINTS;
----

**List all indexes:**
[source,cypher]
----
SHOW INDEXES;
----

**Check constraint/index status:**
* `ONLINE` - Ready to use
* `POPULATING` - Being built (large datasets)
* `FAILED` - Check data for duplicates or missing values

Click **Run** to see your constraints and indexes.


[.slide]
== Dropping Constraints and Indexes

**Drop a constraint:**
[source,cypher]
----
DROP CONSTRAINT customer_id_unique;
----

**Drop an index:**
[source,cypher]
----
DROP INDEX product_name_index;
----

**Warning:** Dropping a uniqueness constraint also drops its automatic index. Only drop if you're sure you don't need it.


[.slide]
== Best Practices

**Always create:**
* ✅ Uniqueness constraints on all entity IDs
* ✅ Indexes on properties used in WHERE clauses
* ✅ Indexes on properties used for JOINs/matches

**Consider creating:**
* Composite indexes for multi-property filters
* Full-text indexes for text search
* Existence constraints (if Enterprise Edition)

**Don't over-index:**
* Indexes slow down writes (inserts/updates)
* Only index properties you actually query
* Monitor index usage with query profiling


[.slide]
== Impact on Recommendation Query

**Without indexes:**
```cypher
MATCH (me:Customer {customerId: 'ALFKI'})...
```
Scans all Customer nodes to find 'ALFKI'

**With uniqueness constraint:**
```cypher
MATCH (me:Customer {customerId: 'ALFKI'})...
```
Direct index lookup - O(1) instead of O(n)

**Performance improvement:** 100x+ faster on large graphs


[.summary]
== Summary

In this lesson, you learned about data quality:

* **Uniqueness constraints** - Prevent duplicate IDs, auto-create indexes
* **Existence constraints** - Require properties (Enterprise only)
* **Indexes** - Speed up queries on frequently used properties
* **Composite indexes** - Index multiple properties together
* **Full-text indexes** - Enable text search and fuzzy matching
* **Best practices** - Index entity IDs and query properties, don't over-index
* **Performance impact** - Constraints and indexes dramatically improve query speed

In the next lesson, you will review everything you learned in this workshop.

read::Mark as completed[]
