= Advanced Pattern Matching
:type: lesson
:order: 3

[.slide.discrete]
== Advanced Pattern Matching

You learned how to read data using basic MATCH patterns. To query complex relationships and analyze graph structures, you need to learn advanced pattern matching techniques.

In this lesson, you will learn how to use variable-length paths, optional matches, and pattern predicates to find complex patterns in the Northwind graph.

[.slide]
== Traversing variable-length paths

Sometimes you want to traverse multiple hops without knowing the exact depth.


[.slide.discrete]
=== Finding indirect reports

Find all employees who report to a manager (directly or indirectly):

[source,cypher]
----
MATCH path = (manager:Employee {lastName: 'Fuller'})<-[:REPORTS_TO*]-(employee:Employee)
RETURN employee.firstName + ' ' + employee.lastName AS employee,
       min(length(path)) AS levels
ORDER BY levels, employee;
----

[mermaid]
....
graph TB
    A[Andrew Fuller] <-- B[Direct Reports]
    B <-- C[Their Reports]
    B <-- D[And Their Reports]
....

The `*` means "one or more hops". You can specify ranges: `*1..3` means 1 to 3 hops.


Click **Run** to see the reporting hierarchy. You'll see results similar to:

[options="header",cols="2,1"]
|===
| Employee | Levels

| Steven Buchanan | 1
| Laura Callahan | 1
| Nancy Davolio | 1
| Robert King | 2
| Anne Dodsworth | 2
|===

[.slide]
== Using optional matches

Sometimes you want to return results even if part of the pattern doesn't match.


[.slide.discrete]
=== Matching products with or without orders

[source,cypher]
----
MATCH (p:Product)
OPTIONAL MATCH (p)<-[:ORDERS]-(o:Order)
RETURN p.productName, count(o) AS orderCount
ORDER BY orderCount DESC
LIMIT 10;
----

// ```mermaid
// flowchart TD
//     A((Match ALL Products)) --> B{Optional Match Orders}
//     B -->|Has Orders| C((Return with count))
//     B -->|No Orders| D((Return with count = 0))
// ```

`OPTIONAL MATCH` is like SQL's LEFT JOIN - it returns nulls if no match is found.


Click **Run** to see products with their order counts:

[options="header",cols="2,1"]
|===
| Product Name | Order Count

| Camembert Pierrot | 51
| Raclette Courdavault | 54
| Gorgonzola Telino | 51
|===

[.slide]
== Combining multiple patterns

You can match multiple patterns in one query.


[.slide.discrete]
=== Matching customers, orders, and employees

Find customers, their orders, and the employees who sold them:

[source,cypher]
----
MATCH (c:Customer)-[:PLACED]->(o:Order),
      (e:Employee)-[:SOLD]->(o)
WHERE c.country = 'USA'
RETURN c.companyName, o.orderId, e.firstName + ' ' + e.lastName AS employee
LIMIT 10;
----

[mermaid]
....
graph LR
    A[Customer] -->|PLACED| B[Order]
    C[Employee] -->|SOLD| B
....

Multiple patterns separated by commas are combined (like AND).

[.slide]
== Using pattern predicates in WHERE

You can use patterns in WHERE clauses to filter results.


[.slide.discrete]
=== Finding customers who ordered a specific product

Find customers who have ordered "Chai":

[source,cypher]
----
MATCH (c:Customer)
WHERE (c)-[:PLACED]->(:Order)-[:ORDERS]->(:Product {productName: 'Chai'})
RETURN c.companyName, c.country
ORDER BY c.country;
----

[mermaid]
....
graph LR
    A[Customer] -->|PLACED| B[Order]
    B -->|ORDERS| C[Product: Chai]
....

The pattern in WHERE acts as a filter condition.


[.slide.discrete]
=== Finding products never ordered

Find products that have never been ordered:

[source,cypher]
----
MATCH (p:Product)
WHERE NOT (p)<-[:ORDERS]-()
RETURN p.productName, p.unitPrice;
----

// ```mermaid
// flowchart TD
//     A((All Products)) --> B{Filter}
//     B --> C((Where NO order relationship exists))
//     C --> D((Return orphaned products))
// ```

`NOT` negates the pattern - returns products without any ORDERS relationships.

[.slide]
== Finding the shortest path

Find the shortest path between two nodes.


[.slide.discrete]
=== Finding a path from employee to category

[source,cypher]
----
MATCH path = shortestPath(
  (e:Employee {lastName: 'Davolio'})-[*]-(cat:Category {categoryName: 'Beverages'})
)
RETURN path;
----

[mermaid]
....
graph LR
    A[Employee] -->|SOLD| B[Order]
    B -->|ORDERS| C[Product]
    C -->|PART_OF| D[Category]
....

This finds the shortest path regardless of relationship directions or types.


*Possible path:*

----
(Employee)-[:SOLD]->(Order)-[:ORDERS]->(Product)-[:PART_OF]->(Category)
----

[.slide]
== Collecting results into lists

The `collect()` function gathers multiple values into a list.


[.slide.discrete]
=== Building a customer's product list

[source,cypher]
----
MATCH (c:Customer {customerId: 'ALFKI'})-[:PLACED]->(:Order)-[:ORDERS]->(p:Product)
RETURN c.companyName, collect(DISTINCT p.productName) AS products;
----

// ```mermaid
// flowchart LR
//     A((Customer)) --> B((Multiple Products))
//     B --> C((Collect into List))
//     C --> D((Return as Array))
// ```

Click **Run** to see customers with their product lists:

[options="header",cols="1,3"]
|===
| Company Name | Products

| Alfreds Futterkiste | ["Aniseed Syrup", "Chartreuse verte", "Flotemysost", ...]
|===


[.slide.discrete]
=== Grouping products by category

[source,cypher]
----
MATCH (cat:Category)<-[:PART_OF]-(p:Product)
RETURN cat.categoryName, collect(p.productName) AS products;
----

Returns each category with an array of its products.

[.slide]
== Using pattern comprehensions

Create lists based on patterns inline.


[.slide.discrete]
=== Building order line items

[source,cypher]
----
MATCH (o:Order {orderId: 10248})
RETURN o.orderId,
       [(o)-[r:ORDERS]->(p:Product) |
        p.productName + ': ' + r.quantity] AS lineItems;
----

// ```mermaid
// flowchart LR
//     A((Order)) --> B((For each ORDERS relationship))
//     B --> C((Build string))
//     C --> D((Collect into list))
// ```

Pattern comprehensions are like list comprehensions in Python.


Click **Run** to see orders with formatted line items:

[options="header",cols="1,3"]
|===
| Order ID | Line Items

| 10248 | ["Queso Cabrales: 12", "Singaporean...: 10", "Mozzarella...: 5"]
|===

[.slide]
== Combining results with UNION

Combine results from multiple queries.


[.slide.discrete]
=== Querying all companies (customers and suppliers)

[source,cypher]
----
MATCH (c:Customer)
RETURN c.companyName AS company, 'Customer' AS type
UNION
MATCH (s:Supplier)
RETURN s.companyName AS company, 'Supplier' AS type
ORDER BY company;
----

// ```mermaid
// flowchart TD
//     A((Query 1: Customers)) --> C((UNION))
//     B((Query 2: Suppliers)) --> C
//     C --> D((Combined Results))
// ```

`UNION` removes duplicates. Use `UNION ALL` to keep duplicates.

[.slide]
== Checking pattern existence with EXISTS

Check if a pattern exists (Neo4j 5.0+).


[.slide.discrete]
=== Finding customers with large orders

[source,cypher]
----
MATCH (c:Customer)
WHERE EXISTS {
  MATCH (c)-[:PLACED]->(o:Order)-[r:ORDERS]->(:Product)
  WHERE r.quantity > 50
}
RETURN c.companyName, c.country
LIMIT 10;
----

// ```mermaid
// flowchart TD
//     A((For each Customer)) --> B{Check}
//     B --> C((Do they have an order with qty > 50?))
//     C -->|Yes| D((Include))
//     C -->|No| E((Exclude))
// ```

`EXISTS` checks if the subquery pattern matches.

[.summary]
== Summary

In this lesson, you learned advanced pattern matching techniques in Cypher:

* **Variable-length paths** - Use `*` for one or more hops, or `*1..3` for specific ranges
* **Optional matches** - Use `OPTIONAL MATCH` to return results even when patterns don't match (like SQL's LEFT JOIN)
* **Multiple patterns** - Combine patterns in one query with commas (acts like AND)
* **Pattern predicates** - Filter results using patterns in WHERE clauses
* **Shortest paths** - Find the shortest path between nodes regardless of relationship types
* **Collecting results** - Use `collect()` to gather multiple values into lists
* **Pattern comprehensions** - Build lists inline based on patterns
* **UNION queries** - Combine results from multiple queries (use `UNION ALL` to keep duplicates)
* **EXISTS subqueries** - Check if patterns exist to filter results (Neo4j 5.0+)

In the next lesson, you will learn how to filter data with WHERE clauses.

read::Mark as completed[]
