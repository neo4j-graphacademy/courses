= Introduction to Cypher
:type: lesson
:order: 1

[.slide.discrete]
== Introduction to Cypher

You have imported data into your Northwind graph. To query and explore that data, you need to learn Cypher, Neo4j's graph query language.

In this lesson, you will learn the basics of Cypher syntax and how to write simple queries.


[.slide]
== Understanding Cypher

*Cypher* is Neo4j's graph query language.

It's designed to be intuitive and readable, using ASCII-art patterns to represent graph structures.

// ```mermaid
// graph LR
//     A((SQL)) --> B((Relational Databases))
//     C((Cypher)) --> D((Graph Databases))
// ```

Just as SQL is used to query relational databases, Cypher is used to query graph databases.


[.slide]
== Why use Cypher?

Cypher makes graph queries natural and expressive:

// ```mermaid
// flowchart TD
//     A((Cypher Benefits)) --> B((Visual Pattern Matching))
//     A --> C((Declarative Syntax))
//     A --> D((Optimized for Graphs))
//     A --> E((Human Readable))
// ```

*Example:* Find customers who placed orders

*SQL (Complex joins):*

[source,sql]
----
SELECT c.companyName, o.orderId
FROM customers c
JOIN orders o ON c.customerID = o.customerID;
----

*Cypher (Pattern matching):*

[source,cypher]
----
MATCH (c:Customer)-[:PLACED]->(o:Order)
RETURN c.companyName, o.orderId;
----

The Cypher version reads like a sentence and matches the visual structure of the graph!


[.slide]
== Learning Cypher basics

[.slide]
=== Representing nodes

Nodes are represented with parentheses `()`:

[source,cypher]
.Find any node
----
MATCH (n) RETURN n LIMIT 1;
----

[source,cypher]
.Any node with a Customer label
----
MATCH (c:Customer) RETURN c LIMIT 1;
----

[source,cypher]
.Find a node with a property
----
MATCH (c:Customer {customerId: 'ALFKI'}) RETURN c;
----

// ```mermaid
// graph LR
//     A(("()")) --> B((Any node))
//     C(("(c:Customer)")) --> D((Customer node<br/>assigned to variable c))
//     E(("(c:Customer {customerId: 'ALFKI'})")) --> F((Specific customer))
// ```


[.slide]
=== Representing relationships

Relationships are represented with arrows `\-->` or `<--`:

[source,cypher]
.Any relationship (right direction)
----
MATCH (c:Customer)-[:PLACED]->(o:Order) RETURN c, o LIMIT 1;
----

[source,cypher]
.Named relationship type
----
MATCH (c:Customer)-[:PLACED]->(o:Order) RETURN c.companyName, o.orderId LIMIT 1;
----

[source,cypher]
.Relationship with variable
----
MATCH (c:Customer)-[r:PLACED]->(o:Order) RETURN r LIMIT 1;
----

[source,cypher]
.Bidirectional (any direction)
----
MATCH (c:Customer)-[:PLACED]-(o:Order) RETURN c, o LIMIT 1;
----

// ```mermaid
// graph LR
//     A(("-->")) --> B((Any relationship))
//     C(("-[:PLACED))->"] --> D((PLACED relationship))
//     E(("-[r:PLACED))->"] --> F((PLACED relationship<br/>assigned to variable r))
// ```


[.slide]
=== Forming patterns

Combine nodes and relationships to form patterns:

[source,cypher]
.Customer placed order
----
MATCH (c:Customer)-[:PLACED]->(o:Order) RETURN c.companyName, o.orderId LIMIT 1;
----

[source,cypher]
.Order contains product
----
MATCH (o:Order)-[:ORDERS]->(p:Product) RETURN p.productName LIMIT 1;
----

[source,cypher]
.Product in category
----
MATCH (p:Product)-[:PART_OF]->(cat:Category) RETURN cat.categoryName LIMIT 1;
----

[mermaid]
....
graph LR
    A[Customer] -->|PLACED| B[Order]
    B -->|ORDERS| C[Product]
    C -->|PART_OF| D[Category]
....

Each pattern matches a piece of the graph structure.


[.slide]
== Using core Cypher clauses

// ```mermaid
// graph TB
//     A((Cypher Clauses)) --> B((MATCH))
//     A --> C((WHERE))
//     A --> D((RETURN))
//     A --> E((CREATE))
//     A --> F((DELETE))
//
//     B --> G((Find patterns))
//     C --> H((Filter results))
//     D --> I((Return data))
//     E --> J((Create data))
//     F --> K((Delete data))
// ```

*Key clauses you will use:*

* *MATCH* - Find patterns in the graph
* *WHERE* - Filter results
* *RETURN* - Specify what to return
* *CREATE* - Create new nodes/relationships
* *DELETE* - Delete nodes/relationships
* *SET* - Update properties
* *REMOVE* - Remove properties/labels


[.slide]
== Breaking down a simple query

Breaking down a complete query:

[source,cypher]
----
MATCH (c:Customer)-[:PLACED]->(o:Order)
WHERE c.country = 'Germany'
RETURN c.companyName, count(o) AS orderCount
ORDER BY orderCount DESC
LIMIT 5;
----

// ```mermaid
// flowchart TD
//     A((MATCH)) --> B((Find pattern:<br/>Customers and Orders))
//     B --> C((WHERE))
//     C --> D((Filter:<br/>Only Germany))
//     D --> E((RETURN))
//     E --> F((Return:<br/>Name and count))
//     F --> G((ORDER BY))
//     G --> H((Sort:<br/>Descending))
//     H --> I((LIMIT))
//     I --> J((Top 5 results))
// ```

This query does the following:

1. *MATCH* - Finds customers and their orders
2. *WHERE* - Filters to German customers only
3. *RETURN* - Returns company names and order counts
4. *ORDER BY* - Sorts by order count (highest first)
5. *LIMIT* - Shows only top 5

The result looks like this:

----
companyName              orderCount
"Königlich Essen"        10
"QUICK-Stop"             8
"Toms Spezialitäten"     7
...
----


[.slide]
== Using variables

Variables let you reference nodes and relationships:

[source,cypher]
----
MATCH (c:Customer)-[r:PLACED]->(o:Order)
RETURN c, r, o;
----

// ```mermaid
// graph LR
//     A((c)) --> B((Variable for Customer))
//     C((r)) --> D((Variable for PLACED relationship))
//     E((o)) --> F((Variable for Order))
// ```

* `c` refers to the Customer node
* `r` refers to the PLACED relationship
* `o` refers to the Order node

You can use these variables in WHERE, RETURN, and other clauses.


[.slide]
== Accessing properties

Use dot notation to access properties:

[source,cypher]
----
MATCH (c:Customer)
RETURN c.companyName, c.city, c.country;
----

// ```mermaid
// flowchart LR
//     A((c)) --> B((Customer node))
//     B --> C((c.companyName))
//     B --> D((c.city))
//     B --> E((c.country))
// ```


[.slide]
== Following Cypher style conventions

// ```mermaid
// graph TB
//     A((Naming Conventions)) --> B((Node Labels))
//     A --> C((Relationship Types))
//     A --> D((Properties))
//     A --> E((Variables))
//
//     B --> F((PascalCase<br/>Customer, Order))
//     C --> G((UPPER_SNAKE_CASE<br/>PLACED, ORDERS))
//     D --> H((camelCase<br/>companyName, orderId))
//     E --> I((camelCase<br/>c, order, prod))
// ```

*Best practices:*

* *Labels*: PascalCase (Customer, Product)
* *Relationship types*: UPPER_SNAKE_CASE (PLACED, PART_OF)
* *Properties*: camelCase (companyName, unitPrice)
* *Variables*: camelCase (c, customer, o, order)
* *Keywords*: UPPERCASE (MATCH, WHERE, RETURN)


[.slide]
== Running Cypher queries

In Neo4j Aura, open the *Query* tool to run Cypher:

// ```mermaid
// flowchart LR
//     A((Write Query)) --> B((Click Run))
//     B --> C{View Results}
//     C -->|Graph| D((Visual Diagram))
//     C -->|Table| E((Tabular Data))
// ```

1. Type your Cypher query in the editor
2. Click *Run* or press `Ctrl+Enter` (`Cmd+Enter` on Mac)
3. View results as graph or table


[.summary]
== Lesson Summary

In this lesson, you learned the basics of Cypher, Neo4j's graph query language:

* *Cypher* is designed to be intuitive and readable, using ASCII-art patterns to represent graph structures
* *Node syntax*: `(n:Label {property: value})`
* *Relationship syntax*: `-[:TYPE]\->`
* *Pattern syntax*: `(a)-[:REL]\->(b)`
* *Core clauses*: MATCH, WHERE, RETURN, CREATE, DELETE, SET, REMOVE
* *Variables* let you reference nodes and relationships in queries
* *Dot notation* (`c.companyName`) accesses properties
* *Style conventions*: PascalCase for labels, UPPER_SNAKE_CASE for relationships, camelCase for properties and variables

In the next lesson, you will read data from the Northwind graph using Cypher queries.


read::It's time to learn Cypher![]
