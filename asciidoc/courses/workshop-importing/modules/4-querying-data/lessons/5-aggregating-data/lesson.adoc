= Aggregating and Analyzing Data
:type: lesson
:order: 5

[.slide.discrete]
== Introduction

Aggregation lets you summarize and analyze data across multiple nodes and relationships.

In this lesson, you will learn how to use aggregation functions to answer business questions about the Northwind data.


[.slide]
== Counting nodes

You can use the `count()` function to count the number of nodes or relationships in your graph.

[source,cypher]
----
MATCH (c:Customer)
RETURN count(c) AS customerCount;
----

////
```mermaid
flowchart LR
    A[All Customers] --> B[count]
    B --> C[Total: 91]
```
////

The query returns the total number of Customer nodes in the graph.

**Result:**

----
customerCount
91
----


[.slide]
== Counting relationships

You can count relationships in the same way you count nodes.

[source,cypher]
----
MATCH (:Customer)-[:PLACED]->(o:Order)
RETURN count(o) AS totalOrders;
----

This query counts all customer orders by counting the Order nodes connected to Customer nodes.


[.slide]
== Counting distinct values

The `count(DISTINCT)` function counts unique values in your data.

[source,cypher]
----
MATCH (o:Order)
RETURN count(DISTINCT o.shipCountry) AS countriesShippedTo;
----

////
```mermaid
flowchart LR
    A[Orders] --> B[Unique Countries]
    B --> C[count DISTINCT]
```
////

This query counts the unique countries that orders were shipped to.


[.slide]
== Grouping data implicitly

Cypher doesn't have an explicit GROUP BY clause - grouping is implicit when you mix aggregation functions with non-aggregated fields.


[.slide.discrete]
=== Orders per customer

[source,cypher]
----
MATCH (c:Customer)-[:PLACED]->(o:Order)
RETURN c.companyName, count(o) AS orderCount
ORDER BY orderCount DESC
LIMIT 10;
----

////
```mermaid
flowchart TD
    A[Customer-Order pairs] --> B[Group by Customer]
    B --> C[Count Orders per group]
    C --> D[Return grouped results]
```
////

The query groups by `c.companyName` (the non-aggregated field) and counts orders per customer.

**Result:**

----
companyName               orderCount
"Save-a-lot Markets"      31
"Ernst Handel"            30
"QUICK-Stop"              28
...
----


[.slide.discrete]
=== Products per category

[source,cypher]
----
MATCH (cat:Category)<-[:PART_OF]-(p:Product)
RETURN cat.categoryName, count(p) AS productCount
ORDER BY productCount DESC;
----

This query groups by category and counts the number of products in each category.


[.slide]
== Using sum and average

You can use the `sum()` and `avg()` functions to calculate totals and averages across your data.


[.slide.discrete]
=== Total freight cost

[source,cypher]
----
MATCH (o:Order)
RETURN sum(o.freight) AS totalFreight,
       avg(o.freight) AS averageFreight,
       min(o.freight) AS minFreight,
       max(o.freight) AS maxFreight;
----

////
```mermaid
graph TB
    A[Aggregate Functions] --> B[sum]
    A --> C[avg]
    A --> D[min]
    A --> E[max]
    A --> F[count]
```
////

This query calculates multiple aggregate values for freight costs across all orders.

**Result:**

----
totalFreight  averageFreight  minFreight  maxFreight
64942.69      78.24           0.02        1007.64
----


[.slide.discrete]
=== Order line item totals

[source,cypher]
----
MATCH (o:Order {orderId: 10248})-[r:ORDERS]->(p:Product)
RETURN o.orderId,
       sum(r.quantity * r.unitPrice) AS orderTotal,
       sum(r.quantity) AS totalItems,
       count(p) AS productTypes;
----

////
```mermaid
flowchart LR
    A[Order Line Items] --> B[sum quantity × price]
    B --> C[Order Total]
```
////

This query calculates order totals from line items by summing the quantity multiplied by unit price for each product.

**Result:**

----
orderId  orderTotal  totalItems  productTypes
10248    440.00      27          3
----


[.slide.discrete]
=== Revenue by customer

[source,cypher]
----
MATCH (c:Customer)-[:PLACED]->(o:Order)-[r:ORDERS]->(p:Product)
RETURN c.companyName,
       sum(r.quantity * r.unitPrice * (1 - r.discount)) AS totalRevenue
ORDER BY totalRevenue DESC
LIMIT 10;
----

////
```mermaid
flowchart TD
    A[Customer Orders] --> B[For each line item]
    B --> C[qty × price × 1-discount]
    C --> D[sum per customer]
    D --> E[Top 10 customers]
```
////

This query calculates total revenue per customer including discounts by traversing from customers through orders to products.

**Result:**

----
companyName               totalRevenue
"QUICK-Stop"              110277.31
"Ernst Handel"            104874.98
"Save-a-lot Markets"      104361.95
...
----


[.slide]
== Collecting values into lists

The `collect()` function aggregates values into a list.


[.slide.discrete]
=== List products by category

[source,cypher]
----
MATCH (cat:Category)<-[:PART_OF]-(p:Product)
RETURN cat.categoryName,
       collect(p.productName) AS products,
       count(p) AS productCount
ORDER BY cat.categoryName;
----

////
```mermaid
flowchart LR
    A[Products per Category] --> B[collect into list]
    B --> C[Array of product names]
```
////

This query collects all product names into a list for each category.

**Result:**

----
categoryName   products                                    productCount
"Beverages"    ["Chai", "Chang", "Guaraná Fantástica"...] 12
"Condiments"   ["Aniseed Syrup", "Chef Anton's..."...]    12
...
----


[.slide.discrete]
=== Customers per country

[source,cypher]
----
MATCH (c:Customer)
RETURN c.country,
       collect(c.companyName) AS companies,
       count(c) AS customerCount
ORDER BY customerCount DESC
LIMIT 10;
----

This query groups customers by country and collects the company names into a list.


[.slide]
== Chaining queries with WITH

The WITH clause lets you chain query parts together and perform multi-step aggregations.

[.slide.discrete]
=== Top product per category

[source,cypher]
----
MATCH (cat:Category)<-[:PART_OF]-(p:Product)<-[r:ORDERS]-(:Order)
WITH cat, p, sum(r.quantity) AS totalOrdered
ORDER BY cat.categoryName, totalOrdered DESC
WITH cat, collect({product: p.productName, quantity: totalOrdered})[0] AS topProduct
RETURN cat.categoryName, topProduct.product AS topProduct, topProduct.quantity AS totalOrdered
ORDER BY cat.categoryName;
----

////
```mermaid
flowchart TD
    A[Calculate totals per product] --> B[WITH: save results]
    B --> C[Order by category and quantity]
    C --> D[WITH: collect and take first]
    D --> E[Return top product per category]
```
////

This multi-step aggregation finds the most ordered product in each category by using WITH to chain operations.


[.slide.discrete]
=== Filtering aggregates

[source,cypher]
----
MATCH (c:Customer)-[:PLACED]->(o:Order)
WITH c, count(o) AS orderCount
WHERE orderCount > 10
RETURN c.companyName, orderCount
ORDER BY orderCount DESC;
----

////
```mermaid
flowchart TD
    A[Count orders per customer] --> B[WITH: save count]
    B --> C[WHERE: filter count > 10]
    C --> D[Return filtered results]
```
////

The WITH clause allows you to filter on aggregated values before returning the final results.


[.slide]
== Using statistical functions

Cypher provides statistical functions for advanced analysis of your data.


[.slide.discrete]
=== Product price statistics

[source,cypher]
----
MATCH (p:Product)
WHERE NOT p.discontinued
RETURN percentileCont(p.unitPrice, 0.5) AS median,
       percentileCont(p.unitPrice, 0.25) AS q1,
       percentileCont(p.unitPrice, 0.75) AS q3,
       stDev(p.unitPrice) AS standardDeviation;
----

////
```mermaid
graph TB
    A[Statistical Functions] --> B[percentileCont]
    A --> C[percentileDisc]
    A --> D[stDev]
    A --> E[stDevP]
```
////

This query calculates advanced statistics including median, quartiles, and standard deviation for active products.


[.slide]
== Answering complex business questions

You can combine multiple aggregation techniques to answer complex business questions.


[.slide.discrete]
=== Monthly order analysis

[source,cypher]
----
MATCH (o:Order)
WHERE o.orderDate >= date('1997-01-01')
  AND o.orderDate < date('1998-01-01')
RETURN o.orderDate.year AS year,
       o.orderDate.month AS month,
       count(o) AS orderCount,
       sum(o.freight) AS totalFreight,
       avg(o.freight) AS avgFreight
ORDER BY year, month;
----

////
```mermaid
flowchart LR
    A[1997 Orders] --> B[Extract year, month]
    B --> C[Group by year-month]
    C --> D[Aggregate metrics]
```
////

This query performs a monthly analysis of orders and freight costs for a specific year.


[.slide.discrete]
=== Employee performance

[source,cypher]
----
MATCH (e:Employee)-[:SOLD]->(o:Order)-[r:ORDERS]->(p:Product)
RETURN e.firstName + ' ' + e.lastName AS employee,
       count(DISTINCT o) AS ordersProcessed,
       sum(r.quantity * r.unitPrice) AS totalSales,
       avg(r.quantity * r.unitPrice) AS avgLineItemValue
ORDER BY totalSales DESC;
----

////
```mermaid
flowchart TD
    A[Employee Sales] --> B[Count orders]
    A --> C[Sum revenue]
    A --> D[Average line item]
    E[Results] --> F[Ranked by total sales]
```
////

This query analyzes employee sales performance by calculating orders processed, total sales, and average line item value.


[.slide.discrete]
=== Category revenue analysis

[source,cypher]
----
MATCH (cat:Category)<-[:PART_OF]-(p:Product)<-[r:ORDERS]-(:Order)
RETURN cat.categoryName,
       count(DISTINCT p) AS products,
       sum(r.quantity * r.unitPrice) AS revenue,
       sum(r.quantity) AS unitsSold,
       avg(r.unitPrice) AS avgPricePoint
ORDER BY revenue DESC;
----

This comprehensive category analysis shows products, revenue, units sold, and average price points.


[.slide]
== Conditional aggregation

You can use CASE expressions within aggregation functions to perform conditional aggregation.


[.slide.discrete]
=== Order status summary

[source,cypher]
----
MATCH (o:Order)
RETURN count(o) AS totalOrders,
       count(CASE WHEN o.shippedDate IS NULL THEN 1 END) AS notShipped,
       count(CASE WHEN o.shippedDate IS NOT NULL THEN 1 END) AS shipped,
       count(CASE WHEN o.shippedDate > o.requiredDate THEN 1 END) AS lateShipments;
----

////
```mermaid
flowchart TD
    A[Orders] --> B[CASE statements]
    B --> C[Count by condition]
    C --> D[Multiple metrics in one query]
```
////

This query uses CASE expressions within count functions to calculate multiple conditional metrics in a single query.


[.summary]
== Summary

In this lesson, you learned how to use aggregation functions to summarize and analyze the Northwind data.

* **Counting** - Use `count()` and `count(DISTINCT)` to count nodes, relationships, and unique values
* **Implicit grouping** - Cypher groups results automatically when you mix aggregated and non-aggregated fields
* **Aggregation functions** - Use `sum()`, `avg()`, `min()`, and `max()` to calculate totals and statistics
* **Collecting values** - Use `collect()` to aggregate values into lists
* **Chaining queries** - Use the WITH clause for multi-step aggregations and filtering on aggregated values
* **Statistical functions** - Use `percentileCont()` and `stDev()` for advanced statistical analysis
* **Conditional aggregation** - Use CASE expressions within aggregation functions for conditional calculations

Congratulations! You have completed the Northwind Import Workshop and can now query and analyze graph data using Cypher.
