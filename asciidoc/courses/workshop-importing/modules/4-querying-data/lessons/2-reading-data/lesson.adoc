= Reading Data from Northwind
:type: lesson
:order: 2

// Source: neo4j-fundamentals/modules/3-reading-data/
// Adapted for workshop - using Northwind dataset, encouraging hands-on practice

[.slide.discrete]
== Introduction

You learned the basic structure of Cypher queries in the previous lesson. Now you'll apply those fundamentals to explore the Northwind graph you'll import.

In this lesson, you will learn how to query nodes and relationships using various MATCH and RETURN patterns.


[.slide]
== Finding Nodes by Label

The simplest Cypher query finds nodes by their label. Let's start by exploring the Customer nodes in Northwind.


[source,cypher]
.Find all customers
----
MATCH (c:Customer)
RETURN c.companyName, c.city, c.country
ORDER BY c.companyName
LIMIT 10;
----

This query matches all nodes with the Customer label, returns three properties (company name, city, and country), and limits results to the first 10.

Click **Run** to see the first 10 customers in alphabetical order.

[NOTE]
.Always use LIMIT when exploring
====
Use `LIMIT` when exploring data to avoid returning too many results. The Northwind dataset has 91 customers, so limiting to 10 makes results easier to read.
====


[.slide]
== Finding the Most Expensive Products

You want to know which products are the most expensive. Let's query Product nodes and sort by price.


[source,cypher]
.Find products sorted by price
----
MATCH (p:Product)
RETURN p.productName, p.unitPrice
ORDER BY p.unitPrice DESC
LIMIT 10;
----

This query finds all Product nodes, returns the name and price, and sorts by price in descending order (`DESC`). The highest-priced products appear first.

Click **Run** to see the 10 most expensive products in Northwind.

**Try experimenting:**

* Change `DESC` to `ASC` to see the cheapest products instead
* Change `LIMIT 10` to `LIMIT 5` to see fewer results
* Remove `ORDER BY p.unitPrice DESC` to see products in any order


[.slide]
== Finding Specific Nodes

Instead of finding all nodes of a label, you can find specific nodes by matching their properties.


[source,cypher]
.Find a specific customer by ID
----
MATCH (c:Customer {customerId: 'ALFKI'})
RETURN c.companyName, c.city, c.country;
----

The curly braces `{customerId: 'ALFKI'}` filter for a Customer node where the `customerId` property equals 'ALFKI'. This pattern returns exactly one customer: Alfreds Futterkiste in Berlin, Germany.

Click **Run** to find this specific customer.

**Try experimenting:**

* Change `'ALFKI'` to `'ANTON'` to find a different customer
* Add more properties to the RETURN clause, like `c.contactName`
* Remove the property filter to see all customers (don't forget to add `LIMIT`)


[.slide]
== Traversing Relationships

One of the most powerful features of graphs is traversing relationships between nodes. Let's find products by category.


[source,cypher]
.Find all beverage products
----
MATCH (cat:Category {categoryName: 'Beverages'})<-[:PART_OF]-(p:Product)
RETURN p.productName, p.unitPrice
ORDER BY p.unitPrice DESC;
----

This query:

* Starts with a Category node named 'Beverages'
* Traverses the PART_OF relationship backwards (notice the `<-` arrow)
* Finds all Product nodes connected to that category
* Returns product names and prices, sorted by price

The `<-[:PART_OF]-` pattern means "products that have a PART_OF relationship pointing TO the category."

Click **Run** to see all products in the Beverages category.

**Try experimenting:**

* Change `'Beverages'` to `'Condiments'` to see a different category
* Change the arrow direction to `->` and observe what happens (you'll get no results - why?)
* Add `LIMIT 5` to see only the top 5 most expensive beverages


[.slide]
== Finding Orders for a Customer

Let's find all orders placed by a specific customer. This requires traversing from Customer to Order.


[source,cypher]
.Find orders for a customer
----
MATCH (c:Customer {customerId: 'ALFKI'})-[:PLACED]->(o:Order)
RETURN c.companyName, o.orderId, o.orderDate
ORDER BY o.orderDate;
----

This pattern starts at customer ALFKI, follows PLACED relationships to connected Order nodes, and returns order details sorted by date.

Click **Run** to see all orders for Alfreds Futterkiste.

**Try experimenting:**

* Change the customer ID to explore different customers' orders
* Add `LIMIT 3` to see only the first 3 orders
* Add `o.shipCountry` to the RETURN clause to see where orders were shipped


[.slide]
== Finding Products in an Order

Now let's traverse two relationships: from an Order to its Products, including the relationship properties.


[source,cypher]
.Find products in a specific order
----
MATCH (o:Order {orderId: 10248})-[rel:ORDERS]->(p:Product)
RETURN p.productName, rel.quantity, rel.unitPrice
ORDER BY rel.quantity DESC;
----

This query:

* Finds a specific order (10248)
* Traverses the ORDERS relationship to connected products
* Returns product names AND relationship properties (quantity, price)
* Sorts by quantity to see which products had the largest quantities

Notice `[rel:ORDERS]` - we give the relationship a variable name `rel` so we can access its properties with `rel.quantity` and `rel.unitPrice`.

Click **Run** to see what was ordered.

**Try experimenting:**

* Change the order ID to explore different orders
* Sort by `rel.unitPrice` instead of `rel.quantity`
* Calculate the line total: add `rel.quantity * rel.unitPrice AS lineTotal` to the RETURN clause


[.slide]
== Chaining Multiple Relationships

You can traverse multiple relationships in one query. Let's find all products a customer has ever purchased.


[source,cypher]
.Find all products purchased by a customer
----
MATCH (c:Customer {customerId: 'ALFKI'})-[:PLACED]->(:Order)-[:ORDERS]->(p:Product)
RETURN DISTINCT p.productName
ORDER BY p.productName;
----

This query chains two relationships:

1. From Customer to Order via PLACED
2. From Order to Product via ORDERS

Notice the `(:Order)` syntax - we don't need a variable for Order since we're not returning order data. The `DISTINCT` keyword removes duplicate product names (customers often order the same product multiple times).

Click **Run** to see all unique products this customer has ordered.

**Try experimenting:**

* Remove `DISTINCT` and observe the difference
* Add `COUNT(DISTINCT p)` before `RETURN` to count how many unique products
* Change the customer ID to compare different customers' purchases


[.slide]
== Counting Results

You often want to know how many nodes or relationships match your pattern. Use `count()` to aggregate results.


[source,cypher]
.Count orders per customer
----
MATCH (c:Customer)-[:PLACED]->(o:Order)
RETURN c.companyName, count(o) AS orderCount
ORDER BY orderCount DESC
LIMIT 10;
----

The `count(o)` function counts how many orders each customer has placed. The `AS orderCount` creates an alias for the count.

Click **Run** to see the top 10 customers by order volume.

**Try experimenting:**

* Change `LIMIT 10` to `LIMIT 5` to see the top 5
* Remove `ORDER BY orderCount DESC` to see results unordered
* Add a WHERE clause: `WHERE count(o) > 10` to filter (this won't work - you need HAVING for aggregates!)


[.summary]
== Summary

In this lesson, you learned how to query the Northwind graph using Cypher:

* **Find nodes by label** - Use `MATCH (c:Customer)` to find all nodes with a specific label
* **Find specific nodes** - Use property matching `{customerId: 'ALFKI'}` to find exact nodes
* **Traverse relationships** - Use `-[:PLACED]->` to follow connections between nodes
* **Chain relationships** - String multiple relationships together to traverse deeper paths
* **Count results** - Use `count()` to aggregate and summarize data

For more advanced Cypher patterns and query optimization techniques, explore the link:/courses/cypher-fundamentals/[Cypher Fundamentals^] course.

In the next lesson, you will learn advanced pattern matching including variable-length paths and filtering patterns.

read::Mark as completed[]
