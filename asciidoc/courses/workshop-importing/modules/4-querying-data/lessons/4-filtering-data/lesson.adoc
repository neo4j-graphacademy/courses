= Filtering Data with WHERE
:type: lesson
:order: 4

[.slide.discrete]
== Introduction

You learned how to match patterns in the graph to retrieve data. To find specific data that meets certain criteria, you need to filter your query results.

In this lesson, you will learn how to use the WHERE clause to filter data based on various conditions.

[.slide]
== Filtering with comparison operators

[.slide.discrete]
=== Using equality

```cypher
MATCH (c:Customer)
WHERE c.country = 'Germany'
RETURN c.companyName, c.city;
```

////
```mermaid
flowchart LR
    A[All Customers] --> B{country = Germany?}
    B -->|Yes| C[Return]
    B -->|No| D[Exclude]
```
////

[.slide.discrete]
=== Using inequality

```cypher
MATCH (p:Product)
WHERE p.unitPrice > 50
RETURN p.productName, p.unitPrice
ORDER BY p.unitPrice DESC;
```

**Comparison operators:**

* `=` equal
* `<>` or `!=` not equal
* `<` less than
* `>` greater than
* `<=` less than or equal
* `>=` greater than or equal

[.slide]
== Combining conditions

[.slide.discrete]
=== Using AND

```cypher
MATCH (p:Product)
WHERE p.unitPrice > 20 AND p.unitsInStock < 10
RETURN p.productName, p.unitPrice, p.unitsInStock;
```

////
```mermaid
flowchart TD
    A[Products] --> B{Price > 20?}
    B -->|Yes| C{Stock < 10?}
    B -->|No| D[Exclude]
    C -->|Yes| E[Return]
    C -->|No| D
```
////

Both conditions must be true.

[.slide.discrete]
=== Using OR

```cypher
MATCH (c:Customer)
WHERE c.country = 'Germany' OR c.country = 'France'
RETURN c.companyName, c.country
ORDER BY c.country;
```

Either condition can be true.

[.slide.discrete]
=== Combining AND and OR

```cypher
MATCH (p:Product)
WHERE (p.categoryId = 1 OR p.categoryId = 2) 
  AND p.unitPrice < 20
RETURN p.productName, p.unitPrice;
```

Use parentheses to control precedence.

[.slide]
== Filtering by ranges

[.slide.discrete]
=== Filtering between values

```cypher
MATCH (o:Order)
WHERE o.orderDate >= date('1997-01-01')
  AND o.orderDate <= date('1997-12-31')
RETURN o.orderId, o.orderDate
ORDER BY o.orderDate
LIMIT 10;
```

////
```mermaid
flowchart LR
    A[Orders] --> B{1997-01-01 <= date <= 1997-12-31?}
    B -->|Yes| C[Return]
    B -->|No| D[Exclude]
```
////

Filters orders from 1997.

[.slide.discrete]
=== Using the IN operator

```cypher
MATCH (c:Customer)
WHERE c.country IN ['Germany', 'France', 'Spain']
RETURN c.companyName, c.country
ORDER BY c.country;
```

////
```mermaid
flowchart LR
    A[Customers] --> B{Country in list?}
    B -->|Yes| C[Return]
    B -->|No| D[Exclude]
```
////

Checks if value is in a list.

[.slide]
== Filtering strings

[.slide.discrete]
=== Using STARTS WITH

```cypher
MATCH (c:Customer)
WHERE c.companyName STARTS WITH 'A'
RETURN c.companyName
ORDER BY c.companyName;
```

////
```mermaid
flowchart LR
    A[Customers] --> B{Name starts with A?}
    B -->|Yes| C[Return]
```
////

[.slide.discrete]
=== Using ENDS WITH

```cypher
MATCH (p:Product)
WHERE p.productName ENDS WITH 'sauce'
RETURN p.productName;
```

[.slide.discrete]
=== Using CONTAINS

```cypher
MATCH (p:Product)
WHERE p.productName CONTAINS 'chocolate'
RETURN p.productName;
```

////
```mermaid
graph TB
    A[String Filters] --> B[STARTS WITH]
    A --> C[ENDS WITH]
    A --> D[CONTAINS]
```
////

[.slide.discrete]
=== Making string filters case-insensitive

```cypher
MATCH (p:Product)
WHERE toLower(p.productName) CONTAINS 'chocolate'
RETURN p.productName;
```

[.slide.discrete]
=== Using regular expressions

```cypher
MATCH (c:Customer)
WHERE c.phone =~ '\\(\\d{3}\\).*'
RETURN c.companyName, c.phone;
```

`=~` operator matches regular expressions.

[.slide]
== Checking for NULL values

[.slide.discrete]
=== Using IS NULL

```cypher
MATCH (o:Order)
WHERE o.shippedDate IS NULL
RETURN o.orderId, o.orderDate, o.requiredDate
LIMIT 10;
```

////
```mermaid
flowchart LR
    A[Orders] --> B{shippedDate IS NULL?}
    B -->|Yes| C[Not shipped yet]
    B -->|No| D[Already shipped]
```
////

Finds orders not yet shipped.

[.slide.discrete]
=== Using IS NOT NULL

```cypher
MATCH (e:Employee)
WHERE e.region IS NOT NULL
RETURN e.firstName, e.lastName, e.region;
```

Finds employees with a region specified.

[.slide]
== Checking for property existence

[.slide.discrete]
=== Checking if a property exists

```cypher
MATCH (p:Product)
WHERE p.reorderLevel IS NOT NULL
RETURN p.productName, p.reorderLevel;
```

Checks if property exists and is not null.

[.slide]
== Filtering on relationships

[.slide.discrete]
=== Checking for relationship existence

```cypher
MATCH (c:Customer)
WHERE EXISTS { (c)-[:PLACED]->(:Order) }
RETURN c.companyName;
```

////
```mermaid
flowchart TD
    A[Customers] --> B{Has PLACED relationship?}
    B -->|Yes| C[Include]
    B -->|No| D[Exclude]
```
////

Returns only customers who have placed orders.

[.slide.discrete]
=== Checking for no relationships

```cypher
MATCH (c:Customer)
WHERE NOT EXISTS { (c)-[:PLACED]->(:Order) }
RETURN c.companyName;
```

Returns customers who have never placed an order.

[.slide]
== Filtering on aggregates

You cannot use WHERE on aggregates. Instead, you use WITH to save aggregated values, then filter on them.

[.slide.discrete]
=== Finding customers with many orders

```cypher
MATCH (c:Customer)-[:PLACED]->(o:Order)
WITH c, count(o) AS orderCount
WHERE orderCount > 10
RETURN c.companyName, orderCount
ORDER BY orderCount DESC;
```

////
```mermaid
flowchart TD
    A[Match Pattern] --> B[Count Orders per Customer]
    B --> C[WITH clause saves count]
    C --> D{WHERE orderCount > 10?}
    D -->|Yes| E[Return]
```
////

`WITH` lets you filter on aggregated values.

[.slide]
== Building complex filters

[.slide.discrete]
=== Combining multiple conditions

```cypher
MATCH (p:Product)
WHERE p.unitPrice > 20
  AND p.unitsInStock > 0
  AND NOT p.discontinued
  AND EXISTS { (p)<-[:ORDERS]-(:Order) }
RETURN p.productName, p.unitPrice, p.unitsInStock;
```

////
```mermaid
flowchart TD
    A[Products] --> B{Price > 20?}
    B -->|Yes| C{In Stock?}
    C -->|Yes| D{Not Discontinued?}
    D -->|Yes| E{Has Orders?}
    E -->|Yes| F[Return]
```
////

Multiple conditions filter progressively.

[.slide.discrete]
=== Using dynamic filtering with parameters

```cypher
MATCH (c:Customer)
WHERE c.country = $country AND c.city = $city
RETURN c.companyName;
```

Parameters (prefixed with `$`) allow dynamic queries.

[.slide]
== Filtering dates

[.slide.discrete]
=== Filtering orders in a date range

```cypher
MATCH (o:Order)
WHERE o.orderDate >= date('1997-06-01')
  AND o.orderDate < date('1997-07-01')
RETURN o.orderId, o.orderDate
ORDER BY o.orderDate;
```

////
```mermaid
flowchart LR
    A[Orders] --> B{June 1997?}
    B -->|Yes| C[Return]
```
////

[.slide.discrete]
=== Finding recent orders

```cypher
MATCH (o:Order)
WHERE o.orderDate > date() - duration('P30D')
RETURN o.orderId, o.orderDate;
```

Orders from last 30 days (if current data).

[.slide]
== Improving filter performance

////
```mermaid
graph TB
    A[Filtering Performance] --> B[Use Indexes]
    A --> C[Filter Early]
    A --> D[Specific Labels]
    A --> E[Avoid NOT]

    B --> F[Index frequently filtered properties]
    C --> G[WHERE before complex patterns]
    D --> H[Always specify node labels]
    E --> I[Positive filters faster than negatives]
```
////

**Best practices:**

* **Use indexes** - Filter on indexed properties when possible
* **Filter early** - WHERE clauses early in the query
* **Specify labels** - Always use labels in MATCH
* **Avoid NOT when possible** - Positive filters are faster

[.summary]
== Summary

In this lesson, you learned how to filter data using the WHERE clause:

* **Comparison operators** - Use `=`, `<>`, `<`, `>`, `<=`, `>=` to compare values
* **Combining conditions** - Use AND, OR to combine multiple conditions
* **Range filtering** - Use IN to check if a value is in a list
* **String matching** - Use STARTS WITH, ENDS WITH, CONTAINS for pattern matching
* **Regular expressions** - Use `=~` for complex pattern matching
* **NULL checks** - Use IS NULL and IS NOT NULL to check for missing values
* **Relationship existence** - Use EXISTS to filter based on relationship patterns
* **Filtering aggregates** - Use WITH to save aggregated values before filtering
* **Date filtering** - Use date functions to filter by date ranges
* **Performance tips** - Use indexes, filter early, specify labels, and avoid NOT when possible

In the next lesson, you will learn how to aggregate and analyze Northwind data.
