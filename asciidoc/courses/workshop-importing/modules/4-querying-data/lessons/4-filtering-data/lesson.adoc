= Filtering Data with WHERE
:type: lesson
:order: 4

The WHERE clause filters results based on conditions. In this lesson, you'll learn various filtering techniques for the Northwind data.

== Basic Filtering

== Equality

```cypher
MATCH (c:Customer)
WHERE c.country = 'Germany'
RETURN c.companyName, c.city;
```

////
```mermaid
flowchart LR
    A[All Customers] --> B{country = Germany?}
    B -->|Yes| C[Return]
    B -->|No| D[Exclude]
```
////

== Inequality

```cypher
MATCH (p:Product)
WHERE p.unitPrice > 50
RETURN p.productName, p.unitPrice
ORDER BY p.unitPrice DESC;
```

**Comparison operators:**
* `=` equal
* `<>` or `!=` not equal
* `<` less than
* `>` greater than
* `<=` less than or equal
* `>=` greater than or equal

== Combining Conditions

== AND

```cypher
MATCH (p:Product)
WHERE p.unitPrice > 20 AND p.unitsInStock < 10
RETURN p.productName, p.unitPrice, p.unitsInStock;
```

////
```mermaid
flowchart TD
    A[Products] --> B{Price > 20?}
    B -->|Yes| C{Stock < 10?}
    B -->|No| D[Exclude]
    C -->|Yes| E[Return]
    C -->|No| D
```
////

Both conditions must be true.

== OR

```cypher
MATCH (c:Customer)
WHERE c.country = 'Germany' OR c.country = 'France'
RETURN c.companyName, c.country
ORDER BY c.country;
```

Either condition can be true.

== Combining AND/OR

```cypher
MATCH (p:Product)
WHERE (p.categoryId = 1 OR p.categoryId = 2) 
  AND p.unitPrice < 20
RETURN p.productName, p.unitPrice;
```

Use parentheses to control precedence.

== Range Filtering

== Between Values

```cypher
MATCH (o:Order)
WHERE o.orderDate >= date('1997-01-01')
  AND o.orderDate <= date('1997-12-31')
RETURN o.orderId, o.orderDate
ORDER BY o.orderDate
LIMIT 10;
```

////
```mermaid
flowchart LR
    A[Orders] --> B{1997-01-01 <= date <= 1997-12-31?}
    B -->|Yes| C[Return]
    B -->|No| D[Exclude]
```
////

Filters orders from 1997.

== IN Operator

```cypher
MATCH (c:Customer)
WHERE c.country IN ['Germany', 'France', 'Spain']
RETURN c.companyName, c.country
ORDER BY c.country;
```

////
```mermaid
flowchart LR
    A[Customers] --> B{Country in list?}
    B -->|Yes| C[Return]
    B -->|No| D[Exclude]
```
////

Checks if value is in a list.

== String Filtering

== Starts With

```cypher
MATCH (c:Customer)
WHERE c.companyName STARTS WITH 'A'
RETURN c.companyName
ORDER BY c.companyName;
```

////
```mermaid
flowchart LR
    A[Customers] --> B{Name starts with A?}
    B -->|Yes| C[Return]
```
////

== Ends With

```cypher
MATCH (p:Product)
WHERE p.productName ENDS WITH 'sauce'
RETURN p.productName;
```

== Contains

```cypher
MATCH (p:Product)
WHERE p.productName CONTAINS 'chocolate'
RETURN p.productName;
```

////
```mermaid
graph TB
    A[String Filters] --> B[STARTS WITH]
    A --> C[ENDS WITH]
    A --> D[CONTAINS]
```
////

**Case-insensitive matching:**

```cypher
MATCH (p:Product)
WHERE toLower(p.productName) CONTAINS 'chocolate'
RETURN p.productName;
```

== Regular Expressions

```cypher
MATCH (c:Customer)
WHERE c.phone =~ '\\(\\d{3}\\).*'
RETURN c.companyName, c.phone;
```

`=~` operator matches regular expressions.

== NULL Checks

== IS NULL

```cypher
MATCH (o:Order)
WHERE o.shippedDate IS NULL
RETURN o.orderId, o.orderDate, o.requiredDate
LIMIT 10;
```

////
```mermaid
flowchart LR
    A[Orders] --> B{shippedDate IS NULL?}
    B -->|Yes| C[Not shipped yet]
    B -->|No| D[Already shipped]
```
////

Finds orders not yet shipped.

== IS NOT NULL

```cypher
MATCH (e:Employee)
WHERE e.region IS NOT NULL
RETURN e.firstName, e.lastName, e.region;
```

Finds employees with a region specified.

== Property Existence

== Has Property

```cypher
MATCH (p:Product)
WHERE p.reorderLevel IS NOT NULL
RETURN p.productName, p.reorderLevel;
```

Checks if property exists and is not null.

== Filtering on Relationships

== Relationship Existence

```cypher
MATCH (c:Customer)
WHERE EXISTS { (c)-[:PLACED]->(:Order) }
RETURN c.companyName;
```

////
```mermaid
flowchart TD
    A[Customers] --> B{Has PLACED relationship?}
    B -->|Yes| C[Include]
    B -->|No| D[Exclude]
```
////

Returns only customers who have placed orders.

== No Relationships

```cypher
MATCH (c:Customer)
WHERE NOT EXISTS { (c)-[:PLACED]->(:Order) }
RETURN c.companyName;
```

Returns customers who have never placed an order.

== Filtering on Aggregates

You can't use WHERE on aggregates - use HAVING instead (after GROUP BY logic).

== Customers with Many Orders

```cypher
MATCH (c:Customer)-[:PLACED]->(o:Order)
WITH c, count(o) AS orderCount
WHERE orderCount > 10
RETURN c.companyName, orderCount
ORDER BY orderCount DESC;
```

////
```mermaid
flowchart TD
    A[Match Pattern] --> B[Count Orders per Customer]
    B --> C[WITH clause saves count]
    C --> D{WHERE orderCount > 10?}
    D -->|Yes| E[Return]
```
////

`WITH` lets you filter on aggregated values.

== Complex Filters

== Multiple Conditions

```cypher
MATCH (p:Product)
WHERE p.unitPrice > 20
  AND p.unitsInStock > 0
  AND NOT p.discontinued
  AND EXISTS { (p)<-[:ORDERS]-(:Order) }
RETURN p.productName, p.unitPrice, p.unitsInStock;
```

////
```mermaid
flowchart TD
    A[Products] --> B{Price > 20?}
    B -->|Yes| C{In Stock?}
    C -->|Yes| D{Not Discontinued?}
    D -->|Yes| E{Has Orders?}
    E -->|Yes| F[Return]
```
////

Multiple conditions filter progressively.

== Dynamic Filtering with Parameters

```cypher
MATCH (c:Customer)
WHERE c.country = $country AND c.city = $city
RETURN c.companyName;
```

Parameters (prefixed with `$`) allow dynamic queries.

== Date Filtering

== Orders in Date Range

```cypher
MATCH (o:Order)
WHERE o.orderDate >= date('1997-06-01')
  AND o.orderDate < date('1997-07-01')
RETURN o.orderId, o.orderDate
ORDER BY o.orderDate;
```

////
```mermaid
flowchart LR
    A[Orders] --> B{June 1997?}
    B -->|Yes| C[Return]
```
////

== Recent Orders

```cypher
MATCH (o:Order)
WHERE o.orderDate > date() - duration('P30D')
RETURN o.orderId, o.orderDate;
```

Orders from last 30 days (if current data).

== Performance Tips

////
```mermaid
graph TB
    A[Filtering Performance] --> B[Use Indexes]
    A --> C[Filter Early]
    A --> D[Specific Labels]
    A --> E[Avoid NOT]

    B --> F[Index frequently filtered properties]
    C --> G[WHERE before complex patterns]
    D --> H[Always specify node labels]
    E --> I[Positive filters faster than negatives]
```
////

**Best practices:**
* **Use indexes** - Filter on indexed properties when possible
* **Filter early** - WHERE clauses early in the query
* **Specify labels** - Always use labels in MATCH
* **Avoid NOT when possible** - Positive filters are faster

== Summary

In this lesson, you learned:

* Basic comparison operators: `=`, `<>`, `<`, `>`, `<=`, `>=`
* Combining conditions: AND, OR
* Range filtering with IN and BETWEEN
* String matching: STARTS WITH, ENDS WITH, CONTAINS
* Regular expressions with `=~`
* NULL checks: IS NULL, IS NOT NULL
* Filtering on relationship existence with EXISTS
* Filtering aggregates with WITH and WHERE
* Date filtering
* Performance tips for efficient filtering

In the next lesson, you will learn how to aggregate and analyze Northwind data.
