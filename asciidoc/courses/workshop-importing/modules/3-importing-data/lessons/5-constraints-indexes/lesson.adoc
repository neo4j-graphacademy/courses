= Constraints and Indexes
:type: lesson
:order: 5


[.slide.discrete]
== Introduction

You learned how to create relationships between nodes in the Data Importer.

In this lesson, you will learn about constraints and indexes to ensure data integrity and query performance.


[.slide]
== Understanding constraints

Constraints enforce rules on your data to maintain data integrity.

**Uniqueness constraints** ensure no two nodes have the same value for a property (e.g., customerId).

**Existence constraints** require certain properties to exist (Enterprise only).

**Type constraints** ensure properties have the correct data type.


[.slide]
== Understanding indexes

Indexes speed up queries by creating efficient lookup structures.

When you query by a property (e.g., find customer by name), an index makes it much faster.

Without an index, Neo4j must scan all nodes. With an index, Neo4j can perform a direct lookup.

[.slide]
== Automatic constraints in Data Importer

The Data Importer automatically creates uniqueness constraints when you mark ID properties.

For Northwind, these constraints will be created:

* `Customer.customerId`
* `Product.productId`
* `Category.categoryId`
* `Supplier.supplierId`
* `Order.orderId`
* `Employee.employeeId`

These ensure no duplicate IDs exist for any of these node types.


[.slide.discrete]
=== Viewing constraints

In Data Importer, look for the constraint indicators next to ID properties (usually a key icon).

You can also view constraints in the details panel for each node.

[.slide]
== Adding additional indexes

Beyond the automatic ID indexes, you can add indexes on commonly queried properties.

Index properties that you will frequently use in `WHERE` clauses or `MATCH` patterns.

**Good candidates for Northwind:**

* `Customer.companyName` - Finding customers by name
* `Product.productName` - Finding products by name
* `Order.orderDate` - Filtering orders by date
* `Employee.lastName` - Finding employees by name


[.slide.discrete]
=== Adding indexes in Data Importer

Some versions of Data Importer allow you to add indexes directly. Look for an "Add Index" button in the details panel.

If not available, you can add indexes after import using Cypher.

[.slide]
== Index types in Neo4j

Neo4j supports several index types:

* **B-tree Index** - General purpose (the default)
* **Text Index** - Full-text search
* **Point Index** - Spatial queries
* **Range Index** - Range queries

For Northwind, standard B-tree indexes (the default) are sufficient.

[.slide]
== Constraint and index best practices

**Do:**

* Always add uniqueness constraints on ID properties
* Index properties used in filtering/matching
* Test query performance with realistic data

**Don't:**

* Index every property (wastes space)
* Index properties rarely queried
* Forget to add ID constraints

Indexes use space and slow down writes, so only create indexes you will use.

[.slide]
== Creating indexes after import

If you need to add indexes after import, use Cypher:

[source,cypher]
----
// Create index on customer company name
CREATE INDEX customer_company_name FOR (c:Customer) ON (c.companyName);

// Create index on product name
CREATE INDEX product_name FOR (p:Product) ON (p.productName);

// Create index on order date
CREATE INDEX order_date FOR (o:Order) ON (o.orderDate);

// Create index on employee last name
CREATE INDEX employee_last_name FOR (e:Employee) ON (e.lastName);
----


[.slide]
== Viewing constraints and indexes

After import, you can view all constraints and indexes with Cypher:

[source,cypher]
----
// Show all constraints
SHOW CONSTRAINTS;

// Show all indexes
SHOW INDEXES;
----

[.slide]
== Impact on import performance

Constraints and indexes affect import performance.

**During import:**

* Constraints add validation overhead (worth it for data quality)
* Indexes are built during import (slight slowdown)

**After import:**

* Queries are much faster
* Data integrity is guaranteed

For Northwind's size, the import will still be very fast.

[.slide]
== Pre-import checklist

Before running the import, verify:

* All 6 node types created
* All 6 relationships created
* ID properties marked on all nodes
* Properties mapped from CSV files
* Uniqueness constraints configured
* ORDERS relationship has properties


[.summary]
== Lesson Summary

Constraints and indexes ensure data integrity and query performance:

* **Constraints** - Enforce rules on your data (uniqueness, existence, type)
* **Indexes** - Speed up queries by creating efficient lookup structures
* **Data Importer** - Automatically creates uniqueness constraints for ID properties
* **Best practices** - Always constrain IDs, index frequently queried properties, avoid over-indexing

You can add additional indexes after import using Cypher `CREATE INDEX` statements.

In the next lesson, you will run the import to load the Northwind dataset into your Neo4j Aura instance.

read::Mark as completed[]
