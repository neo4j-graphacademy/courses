= Northwind Import Workshop - Speaker Notes

*Total Duration:* 2 hours (core) / 4 hours (with stretch goals)

*Workshop Goal:* Guide participants through importing the Northwind dataset into Neo4j Aura and querying it with Cypher.

'''

== Module 1: Getting Started with Neo4j Aura (15 minutes)

=== Lesson 1: What is Neo4j Aura? (3 min)

*What to Show:*

* Neo4j Aura console homepage (https://console.neo4j.io)
* Point out the "Create Free Instance" button

*Talking Points:*

. *Introduce Neo4j Aura as fully managed DBaaS*
   * "Neo4j Aura handles infrastructure, backups, updates, security, and high availability automatically"
   * "This means you can focus on your data and applications, not managing servers"

. *Explain the benefits*
   * No infrastructure setup: "No servers to configure or maintain"
   * Automated backups: "Your data is backed up automatically"
   * Automatic updates: "Software patches applied without downtime"
   * Built-in security: "Encryption at rest and in transit, network isolation"
   * 99.95% uptime SLA: "Production-ready reliability"

. *Highlight the Free tier*
   * "Free tier available with no credit card required"
   * "Sufficient storage for learning, development, and small projects"
   * "Get started in minutes"
   * "Cloud-based, accessible from anywhere"

*Key Message:* "Aura removes all the operational complexity so you can focus on learning graphs and building applications."

'''

=== Lesson 2: Create Your Aura Instance (7 min)

*What to Show:*

* Live demo: Create a free Aura instance
* Show the signup flow
* Download credentials dialog
* Running instance view

*Talking Points:*

. *Navigate to Aura console*
   * "Go to console.neo4j.io"
   * "Sign up with email or SSO if you don't have an account"

. *Create free instance (DEMO)*
   * Click "Create Free Instance"
   * Show tier selection modal (image: `4-free-instance-sign-up.png`)
   * "The free tier gives you one database instance - perfect for this workshop"
   * Fill in instance details:
     ** Name: "Northwind" (or let them choose)
     ** Region: Choose closest
   * Click "Create"

. *Download and save credentials (CRITICAL)*
   * Show download credentials dialog (image: `4-download-creds.png`)
   * "This is CRITICAL - you will ONLY see these credentials ONCE"
   * "Download the .txt file and save it somewhere safe"
   * Contains:
     ** Connection URI (bolt://...)
     ** Username (usually "neo4j")
     ** Password (random generated)
   * "You'll need these to connect later"

. *Wait for instance to start*
   * "Takes about 30-60 seconds to provision"
   * Show running instance (image: `4-free-ready.png`)
   * Point out the "Open" button

*Instructor Tip:* Have participants pair up if someone loses credentials - they can share an instance for the workshop.

*Key Message:* "Keep your credentials safe - you'll need them throughout the workshop."

'''

=== Lesson 3: Aura Tools Overview (5 min)

*What to Show:*

* Aura console with instance selected
* Show each tool briefly
* Data Importer interface (image: `01_data_importer_main.jpg`)

*Talking Points:*

. *Open your instance*
   * Click on your instance name
   * Click "Open" button
   * "This opens the Neo4j workspace with all the tools"

. *Tour the four key tools:*

   *a) Data Importer*

   * "Visual tool for importing CSV files"
   * "Drag-and-drop interface, no coding required"
   * "We'll use this extensively in Module 3"
   * Show interface briefly (image: `01_data_importer_main.jpg`)

   *b) Query Tool*

   * "Where you write and execute Cypher queries"
   * "Also called Neo4j Browser or Query Console"
   * "Visualizes results as graphs or tables"
   * "We'll use this in Module 4"

   *c) Explore*

   * "Interactive graph visualization"
   * "Point-and-click navigation through your data"
   * "Great for exploring without writing queries"

   *d) Instance Management*

   * "View connection information"
   * "Create snapshots (backups)"
   * "Monitor database metrics"
   * "Manage users and security settings"

. *Accessing tools*
   * "Click on your instance → Click Open → Choose the tool"
   * "We'll start with the modeling module first, then come back to use these tools"

*Key Message:* "These four tools give you everything you need to work with your graph database - no additional software required."

'''

== Module 2: Graph Data Modeling Fundamentals (40 minutes)

=== Lesson 1: What is Graph Data Modeling? (5 min)

*What to Show:*

* Whiteboard or slide with graph model example
* Show a bad model vs good model (if available)

*Talking Points:*

. *Why model your data?*
   * "How you structure your data determines what questions you can answer and how efficiently"

. *Show consequences of no model (CONTRAST)*
   * *Without a model:*
     ** "Storing everything as properties on one node type"
     ** "Queries become slow - scanning all data"
     ** "No relationships to traverse"
     ** "Structure doesn't match how people think"

   * *With thoughtful model:*
     ** "Answers use cases efficiently - direct relationships for common patterns"
     ** "Query performance - following relationships is instant"
     ** "Intuitive structure - matches business thinking"
     ** "Scalability - touch only connected data, not all data"

. *Give concrete example*
   * "If you store product categories as a property: `product.category = 'Beverages'`"
   * "You must scan ALL products to find beverages"
   * "If you model Category as a node with PART_OF relationship:"
   * "You traverse directly from category node to its products - instant"
   * "Regardless of how many total products exist"

. *Introduce Neo4j components* (briefly - details in next lessons)
   * *Nodes* - "For entities that exist independently (Customer, Product)"
   * *Labels* - "To categorize nodes by type"
   * *Relationships* - "For connections between entities"
   * *Properties* - "For attributes describing nodes or relationships"

. *Emphasize iterative process*
   * "Modeling is iterative"
   * "Start simple, test with queries, refine as needed"
   * "Graph flexibility makes refactoring easy"

*Key Message:* "A good graph model makes complex questions simple and keeps them fast as your data grows."

'''

=== Lesson 2: Understanding the Northwind Domain (6 min)

*What to Show:*

* Northwind dataset overview (CSV files if available)
* Sample data from customers.csv, orders.csv
* Show the graph diagram with all relationships

*Talking Points:*

. *Introduce Northwind*
   * "Sample dataset from Microsoft - food products company"
   * "Imports and exports specialty foods worldwide"
   * "Perfect for learning because it has rich connections"

. *Explain WHY each entity is a node* (critical - focus on reasoning)

   Walk through each:

   * *Customers* - "Independent companies with their own contact info, can place multiple orders"
   * *Orders* - "Distinct transactions with dates, shipping details, unique identity"
   * *Products* - "Own names, prices, stock levels, appear in multiple orders"
   * *Categories* - "Group multiple products, have descriptions"
   * *Suppliers* - "Independent organizations, supply multiple products"
   * *Employees* - "Own personal details, job titles, process multiple orders"

. *Contrast: Why NOT make certain things entities?*
   * "Country - just a text attribute, no own data or relationships"
   * "Order date - just a timestamp, a property not an independent thing"
   * Ask: "What makes something worthy of being a node vs a property?"

. *List key use cases*
   * Show on slide:
     ** "What orders did a customer place?"
     ** "What products were in an order?"
     ** "Which employees report to which managers?"
     ** "What products has a customer purchased?" (multi-hop)

. *Explain why graph is better* (DEMO with SQL vs Cypher)

   *Show SQL query on slide:*

[source,sql]
----
SELECT DISTINCT p.productName
FROM customers c
JOIN orders o ON c.customerID = o.customerID
JOIN order_details od ON o.orderID = od.orderID
JOIN products p ON od.productID = p.productID
WHERE c.customerID = 'ALFKI';
----

   *Point out:*

   * "Three JOINs required"
   * "Each scans tables and matches keys"
   * "Performance degrades with more data"
   * "Doesn't read like the question"

   *Show Cypher query on slide:*

[source,cypher]
----
MATCH (c:Customer {customerId: 'ALFKI'})-[:PLACED]->(:Order)-[:ORDERS]->(p:Product)
RETURN DISTINCT p.productName;
----

   *Point out:*

   * "No JOINs - direct traversal"
   * "Performance scales - 10 relationships same as 3"
   * "Reads naturally - matches how you think"

*Key Message:* "Northwind is highly connected data - perfect use case for a graph database where relationships are first-class citizens."

'''

=== Lesson 3: Modeling Nodes and Labels (5 min)

*What to Show:*

* Diagram showing the 6 node types
* Example nodes with properties
* Query example showing label performance

*Talking Points:*

. *Recap: Nodes represent entities*
   * "Nodes are for things that exist independently and have their own data"

. *Walk through Northwind nodes with reasoning:*
   * Customer - "Exists independently, has contact information"
   * Order - "Distinct record, own dates and shipping details"
   * Product - "Own prices, stock levels, descriptions"
   * Category - "Groups products, has descriptions"
   * Supplier - "Independent companies, contact information"
   * Employee - "Personal details, job titles"

. *Explain Labels - WHY they matter*

   *Performance benefit (show example):*

   * "When you query for customers: `MATCH (c:Customer)`"
   * "Neo4j ONLY scans Customer nodes, not every node"
   * "Without labels, it would scan millions of nodes"
   * "With labels, only scans the ~100 customer nodes"
   * "This makes queries significantly faster"

   *Other benefits:*

   * "Clarity - queries are self-documenting"
   * "Constraints - unique customerId on Customer only"
   * "Indexing - index Customer by country, doesn't affect Products"

. *Show the Northwind labels:*

----
Customer, Order, Product, Category, Supplier, Employee
----

. *Label naming conventions:*
   * Use nouns: "Customer, Product, Order"
   * PascalCase: "Customer" not "customer"
   * Be specific: "Customer" not "Entity"
   * Singular: "Product" not "Products"

. *Multiple labels (brief mention):*
   * "A node CAN have multiple labels"
   * "Example: Employee who is also a Manager"
   * "Not common in Northwind, but good to know"

*Key Message:* "Labels aren't just for organization - they're critical for query performance and data integrity."

'''

=== Lesson 4: Modeling Relationships (8 min)

*What to Show:*

* Diagram of relationship types
* Side-by-side: SQL with pivot table vs Cypher with relationship
* Diagram showing relationship properties

*Talking Points:*

. *Define relationships*
   * "Connections between nodes"
   * "Every relationship has: type (name), direction, can have properties"
   * "Connects exactly two nodes"

. *Explain WHY relationships are better than relational approach* (CRITICAL - spend time here)

   *The Relational Problem:*

   * "In relational DBs, you model connections with foreign keys and pivot tables"
   * Show diagram of orders table with foreign key
   * Show order_details pivot table connecting orders and products

   *Show SQL example on slide:*

[source,sql]
----
SELECT p.productName
FROM orders o
JOIN order_details od ON o.orderID = od.orderID  -- Pivot table
JOIN products p ON od.productID = p.productID
WHERE o.orderID = 10248;
----

   *Point out problems:*

   * "Two JOINs scan and match thousands of rows"
   * "order_details is just a join table, not meaningful"
   * "Every query needs the same JOIN pattern"

   *The Graph Solution:*

   * "Direct relationships, no joins"

   *Show Cypher example:*

[source,cypher]
----
MATCH (o:Order {orderId: 10248})-[:ORDERS]->(p:Product)
RETURN p.productName;
----

   *Point out benefits:*

   * "No JOIN overhead - direct traversal"
   * "ORDERS describes the relationship - semantic meaning"
   * "Can store properties right on the relationship"
   * "Easy to traverse in any direction"

. *Show the Northwind relationships:*

----
Customer -[:PLACED]-> Order
Order -[:ORDERS]-> Product
Product -[:PART_OF]-> Category
Product -[:SUPPLIED_BY]-> Supplier
Employee -[:SOLD]-> Order
Employee -[:REPORTS_TO]-> Employee
----

. *Explain many-to-many handling:*
   * Draw diagram: Customer →PLACED→ Order →ORDERS→ Product
   * "One customer, many orders"
   * "One order, many products"
   * "One product, many orders"
   * "This is natural in graphs - relationships are first-class"

. *Relationship properties* (CRITICAL - explain the WHY)

   *Show ORDERS relationship with properties:*

----
(Order)-[:ORDERS {quantity: 10, unitPrice: 18.00, discount: 0.05}]->(Product)
----

   *Explain WHY data belongs here:*

   * "Quantity describes 'how many of THIS product in THIS order'"
   * "Not a property of the product (varies per order)"
   * "Not a property of the order (varies per product)"
   * "It exists BECAUSE of the relationship"

   *Compare to pivot table:*

   * "In relational DB, this IS the order_details table"
   * "But in graph, we model it naturally as relationship properties"

. *Self-referencing relationships:*
   * "Employee -[:REPORTS_TO]-> Employee"
   * "Creates hierarchy/tree structure"
   * "Same node label, relationship to itself"

*Key Message:* "Relationships eliminate JOIN overhead and let you model connections naturally with semantic meaning and properties."

'''

=== Lesson 5: Defining Properties (6 min)

*What to Show:*

* Example nodes with full property lists
* Diagram showing historical pricing on relationships
* Comparison: country as property vs country as node

*Talking Points:*

. *What are properties?*
   * "Key-value pairs storing actual data"
   * "On nodes AND relationships"
   * "Types: strings, numbers, booleans, dates, lists"

. *Show Northwind properties* (don't read all, just highlight)
   * Customer: customerId, companyName, contactName, city, country, phone...
   * Product: productId, productName, unitPrice, unitsInStock...
   * Order: orderId, orderDate, requiredDate, shippedDate, freight...

. *Property naming conventions:*
   * camelCase: "firstName, orderDate, unitPrice"
   * Be descriptive: "orderDate" not "date"
   * Consistent: "customerId" everywhere, not mixing with "customerID"

. *Unique identifiers:*
   * "Each node type has a unique ID property"
   * Customer: customerId, Product: productId, Order: orderId...
   * "Used for constraints, matching during import, query performance"

. *Property vs Node Decision* (CRITICAL - spend time here)

   *Present the question:*

   * "When should something be a property vs a separate node?"

   *Use country as example:*

   _Option 1: Country as property_

----
Customer {customerId: 'ALFKI', country: 'Germany'}
----

   _Option 2: Country as node_

----
(Customer)-[:LOCATED_IN]->(Country {name: 'Germany'})
----

   *When to use PROPERTY:*

   * "Simple value - just text describing the customer"
   * "No shared attributes - don't need GDP, population"
   * "Filtering, not navigation - filter customers BY country"
   * "Storage efficiency - properties faster than traversing"

   *Example query:* `WHERE c.country = 'Germany'`

   *When to use NODE:*

   * "Has own attributes - country population, region, timezone"
   * "Central to queries - often ask 'What customers in this country?'"
   * "Relates to multiple entities - customers AND suppliers"
   * "Shared reference data - manage centrally"

   *Example query:* `MATCH (cat:Category {name: 'Beverages'})<-[:PART_OF]-(p:Product)`

   *The key distinction:*

   * "Category is queried FROM (start point)"
   * "Country is queried FOR (filter condition)"
   * "If you navigate FROM it, make it a node"
   * "If you filter BY it, make it a property"

. *In Northwind decisions:*
   * country → Property (simple filter)
   * Category → Node (has description, navigate from it)

*Key Message:* "Choose properties vs nodes based on how you'll query the data, not just based on the source file structure."

'''

=== Lesson 6: Testing Your Data Model (5 min)

*What to Show:*

* Sample data diagram with a few nodes and relationships
* Write a test query on whiteboard/screen
* Query result showing it works

*Talking Points:*

. *Why test before importing?*
   * "Verify model answers your use cases"
   * "Catch design issues early"
   * "Easier to fix model now than after importing millions of rows"

. *Create sample data*
   * "Create small instance with representative data"
   * Show diagram:
     ** 2 customers, 2 orders, 3 products, 2 categories
     ** Connections between them
   * "This lets you test queries without full dataset"

. *Test each use case with Cypher*

   *Example 1: Orders by Customer*

[source,cypher]
----
MATCH (c:Customer {customerId: 'ALFKI'})-[:PLACED]->(o:Order)
RETURN c.companyName, o.orderId, o.orderDate
----

   * "Direct relationship - fast"

   *Example 2: Products in Order*

[source,cypher]
----
MATCH (o:Order {orderId: 10248})-[rel:ORDERS]->(p:Product)
RETURN p.productName, rel.quantity, rel.unitPrice
----

   * "Can access relationship properties"

   *Example 3: Customer Purchase History (multi-hop)*

[source,cypher]
----
MATCH (c:Customer {customerId: 'ALFKI'})-[:PLACED]->(:Order)-[:ORDERS]->(p:Product)
RETURN DISTINCT p.productName
----

   * "2-hop traversal - still fast"

. *Evaluate results:*
   * "All use cases supported? ✓"
   * "Queries are simple? ✓"
   * "Performance acceptable? ✓"
   * "If no to any: refactor the model"

. *Query complexity guidelines:*
   * "Most queries should be 1-3 hops"
   * "5+ hops might need optimization"
   * "If common queries are deep, add direct relationships"

*Key Message:* "Testing with sample data now saves hours of frustration later."

'''

=== Lesson 7: Refactoring Your Graph Model (5 min)

*What to Show:*

* Before/after examples of refactoring patterns
* Property-to-node transformation diagram
* Intermediate node pattern

*Talking Points:*

. *What is refactoring?*
   * "Improving your model while preserving meaning"
   * "Done to improve performance, simplify, support new use cases"

. *Why Neo4j makes refactoring easy:*
   * "Schema is optional and flexible"
   * "No complex migrations like in relational DBs"
   * "Can be done incrementally"

. *Common refactoring patterns* (show 2-3 examples)

   *a) Property to Node:*

   Before:

----
Customer {country: 'Germany'}
Customer {country: 'France'}
Customer {country: 'Germany'}
----

   After:

----
(Customer)-[:LOCATED_IN]->(Country {name: 'Germany'})
----

   Why: "Deduplicate data, add country properties, query by country efficiently"

   *b) Intermediate Node:*

   Before:

----
(Order)-[:ORDERS {quantity, price}]->(Product)
----

   After:

----
(Order)-[:CONTAINS]->(OrderDetail {quantity, price})-[:FOR]->(Product)
----

   Why: "More flexible for complex scenarios, can add line-item logic"

. *When to refactor:*
   * "Queries require 5+ hops"
   * "Common queries are slow"
   * "New requirements not supported"

. *When NOT to refactor:*
   * "Model is working well"
   * "Performance acceptable"
   * "Complexity doesn't justify benefit"
   * "Remember: Premature optimization is wasteful"

. *Northwind model status:*
   * "Our Northwind model passes all tests"
   * "No refactoring needed"
   * "But good to know these patterns for your own projects"

*Key Message:* "Graph flexibility means you can evolve your model as requirements change - don't overthink it upfront."

'''

== Module 3: Importing the Northwind Dataset (30 minutes)

=== Lesson 1: Data Import Overview (5 min)

*What to Show:*

* List of Northwind CSV files
* Comparison slide: different import methods
* Final graph diagram

*Talking Points:*

. *Understanding data importing:*
   * "Transform CSV files into graph structure (nodes, relationships, properties)"

. *List the Northwind CSV files:*

----
customers.csv - 91 customers
orders.csv - 830 orders
products.csv - 77 products
categories.csv - 8 categories
suppliers.csv - 29 suppliers
employees.csv - 9 employees
order-details.csv - ~2150 order line items
----

. *Compare import options* (show table)

   *Data Importer* (what we'll use)

   * Visual, GUI-based
   * No coding required
   * Perfect for CSV files
   * Built into Aura
   * Best for: Learning and small datasets

   *Cypher LOAD CSV*

   * Code-based, flexible
   * Can handle transformations
   * Works with URLs
   * Best for: Scripted imports, custom logic

   *Neo4j Admin Import*

   * Extremely fast bulk loads
   * Command-line tool
   * Only for initial import (empty DB)
   * Best for: Billions of rows

   *Application Drivers*

   * Full programmatic control
   * Integrates with systems
   * Best for: Real-time, continuous imports

. *Why Data Importer for this workshop:*
   * "Visual and easy to learn"
   * "Perfect for CSV files"
   * "Built into Aura"
   * "No coding required"
   * "Great for Northwind dataset size"

. *Preview the import process:*
   * Upload CSV files
   * Create node labels
   * Map CSV columns to properties
   * Create relationships
   * Add constraints & indexes
   * Run import
   * Verify data

*Key Message:* "Different import methods for different scenarios - Data Importer is perfect for learning and CSV-based imports."

'''

=== Lesson 2: Introduction to Data Importer (5 min)

*What to Show:*

* Open Data Importer in Aura
* Tour the interface (image: `data-importer.png`)
* Show each panel and button

*Talking Points:*

. *Access Data Importer:*
   * "Go to your Aura instance → Click Open → Select Data Importer"

. *Tour the interface* (point to each area)

   Show image: `data-importer.png`

   *Files Panel (left):*

   * "Upload CSV files here"
   * "View uploaded files"
   * "See file previews"

   *Canvas Area (center):*

   * "Visual graph model"
   * "Drag nodes to position"
   * "Draw relationships between nodes"
   * "See the big picture of your model"

   *Details Panel (right):*

   * "Configure node properties"
   * "Map CSV columns"
   * "Set constraints and indexes"

   *Action Buttons (top):*

   * "Save model (download JSON)"
   * "Load model (upload JSON)"
   * "Clear model"
   * "Run import"

. *Explain the workflow:*

----
1. Upload CSV file
2. Create node in canvas
3. Set node label
4. Map properties from CSV
5. Set ID property
6. Repeat for all nodes
7. Create relationships
8. Map relationship properties
9. Add constraints & indexes
10. Run import
----

. *Best practices:*
   * "Import nodes BEFORE relationships (relationships need nodes to exist)"
   * "Set ID properties correctly - crucial for matching"
   * "Test with subset first - debug with small files"
   * "Add constraints before importing - prevents duplicates"
   * "Verify after each step - query DB to confirm"

*Key Message:* "Data Importer gives you a visual, point-and-click way to build your graph without writing any code."

'''

=== Lesson 3: Importing Northwind Nodes (10 min)

*What to Show:*

* LIVE DEMO: Import one node type completely (Customer)
* Show the other nodes more quickly
* Final canvas with all nodes (image: `result.svg`)

*Talking Points:*

. *Download CSV files first:*
   * "Everyone download these files now:"
   * Show links:
+
----
customers.csv
products.csv
categories.csv
suppliers.csv
orders.csv
employees.csv
----
   * "Save them to your desktop or downloads folder"

. *DEMO: Import Customer node* (do this slowly, let them follow)

   *Step 1: Upload CSV*

   * "Click 'Add Data Source'"
   * "Upload customers.csv"
   * "You'll see a preview of the data"
   * Point out columns: customerID, companyName, contactName, city, country...

   *Step 2: Create node*

   * "Click 'Add Node' in the canvas"
   * Show image: `add-node.png`
   * "A node appears on the canvas"

   *Step 3: Set label*

   * "In details panel, set label to 'Customer'"

   *Step 4: Map from file*

   * "Click 'Map from file'"
   * Show image: `map-from-file.png`
   * "Select customers.csv"
   * "Tool suggests property mappings automatically"
   * Show image: `mapped-properties.png`

   *Step 5: Configure properties*

   * "Map these columns:"
   * Show table (from lesson):
+
----
customerID → customerId (String)
companyName → companyName (String)
contactName → contactName (String)
city → city (String)
country → country (String)
...and others
----

   *Step 6: Set ID property* (CRITICAL)

   * "Click the key icon next to customerId"
   * Show image: `set-id.png`
   * "This marks it as the unique identifier"
   * "Creates a uniqueness constraint"
   * "Prevents duplicate customers"

. *Let participants do Product node:*
   * "Now you do Product following the same steps"
   * "Label: Product"
   * "File: products.csv"
   * "ID property: productId"
   * Walk around and help

. *Quickly show remaining nodes:*
   * Category (categoryId)
   * Supplier (supplierId)
   * Order (orderId)
   * Employee (employeeId)

. *Review the canvas:*
   * Show image: `result.svg`
   * "You should see 6 nodes on the canvas"
   * "Each connected to its CSV file"
   * "Properties mapped"
   * "ID properties set"

*Instructor Tip:* Save your model as JSON after this step so participants who fall behind can load your file.

*Key Message:* "Nodes first, relationships later - this two-step process ensures everything connects properly."

'''

=== Lesson 4: Creating Relationships (6 min)

*What to Show:*

* DEMO: Create one relationship completely (Customer PLACED Order)
* Show the relationship properties on ORDERS relationship
* Final model with all relationships

*Talking Points:*

. *Explain relationship requirements:*
   * Type name (PLACED, ORDERS, etc.)
   * Source node (which node it starts from)
   * Target node (which node it points to)
   * Matching IDs (how to connect them)
   * Properties (optional, on the relationship)

. *DEMO: Customer PLACED Order* (do this slowly)

   *Step 1: Draw the relationship*

   * "Hover over the Customer node edge"
   * "Click the + button that appears"
   * "Drag to the Order node"
   * "A relationship line appears"

   *Step 2: Configure in details panel*

   * Type: `PLACED`
   * From file: `orders.csv`
   * From ID: Match `customerID` from CSV to `customerId` property on Customer node
   * To ID: Match `orderID` from CSV to `orderId` property on Order node
   * "No properties needed on this relationship"

. *Let participants create these relationships:*
   * Product PART_OF Category
   * Product SUPPLIED_BY Supplier
   * Employee SOLD Order

. *DEMO: Order ORDERS Product* (has properties - important!)

   *First, download order-details.csv:*

   * "This CSV has the quantity, price, discount info"
   * "It's the pivot table from relational world"
   * "In graph world, it becomes relationship properties"

   *Draw the relationship:*

   * Order → Product
   * Type: `ORDERS`
   * From file: `order-details.csv`
   * From ID: orderID → orderId
   * To ID: productID → productId

   *Add relationship properties:*

   * Show table:
+
----
quantity → quantity (Integer)
unitPrice → unitPrice (Float)
discount → discount (Float)
----
   * "These properties exist BECAUSE of the connection"
   * "They describe how many, at what price, with what discount"

. *Create final relationship:*
   * Employee REPORTS_TO Employee (self-referencing)
   * From file: employees.csv
   * From ID: employeeID → employeeId
   * To ID: reportsTo → employeeId

. *Review complete model:*
   * "Canvas should show all nodes and relationships"
   * Point out:
+
----
Customer →PLACED→ Order
Order →ORDERS→ Product (with properties)
Product →PART_OF→ Category
Product →SUPPLIED_BY→ Supplier
Employee →SOLD→ Order
Employee →REPORTS_TO→ Employee
----

*Key Message:* "Relationships connect your data and enable graph traversal - they're what make a graph database powerful."

'''

=== Lesson 5: Constraints and Indexes (2 min)

*What to Show:*

* Constraints panel in Data Importer
* Show the constraints that were created

*Talking Points:*

. *What are constraints?*
   * "Rules that ensure data integrity"
   * "Unique constraints: ensure IDs are unique"
   * "Existence constraints: ensure required properties exist"

. *Constraints already created:*
   * "When you set ID properties, Data Importer created uniqueness constraints"
   * "Customer.customerId must be unique"
   * "Product.productId must be unique"
   * "And so on for all nodes"

. *What are indexes?*
   * "Speed up queries"
   * "Created automatically on ID properties"
   * "Make lookups by ID fast"

. *In Data Importer:*
   * "Click the constraints/indexes tab"
   * "You'll see all the constraints listed"
   * "Data Importer handles this for you automatically"

*Key Message:* "Constraints and indexes ensure data quality and query performance - Data Importer creates them automatically on ID properties."

'''

=== Lesson 6: Running the Import (2 min)

*What to Show:*

* LIVE: Click "Run Import"
* Show import progress
* Show success message with counts

*Talking Points:*

. *Ready to import:*
   * "All nodes mapped? ✓"
   * "All relationships configured? ✓"
   * "Constraints set? ✓"
   * "Time to run the import!"

. *Click 'Run Import':*
   * "Button in top right"
   * "Connects to your database"
   * "Generates Cypher statements"
   * "Executes the import"

. *Watch the progress:*
   * "Shows nodes being created"
   * "Shows relationships being created"
   * "Takes about 30-60 seconds for Northwind"

. *Review the results:*
   * "Import summary shows:"
+
----
91 Customers created
830 Orders created
77 Products created
8 Categories created
29 Suppliers created
9 Employees created
~4000 relationships created
----
   * "Success message"

. *Verify the import:*
   * "Open Query tool"
   * "Run a simple query:"
+
[source,cypher]
----
MATCH (n) RETURN labels(n) AS label, count(n) AS count
----
   * "Should see counts for each label"

*Key Message:* "Import is one click - Data Importer does all the heavy lifting behind the scenes."

'''

== Module 4: Querying the Northwind Graph (35 minutes)

=== Lesson 1: Introduction to Cypher (5 min)

*What to Show:*

* Cypher syntax examples on slides
* Open Query tool
* Run a simple query

*Talking Points:*

. *What is Cypher?*
   * "Neo4j's graph query language"
   * "SQL is for relational databases, Cypher is for graph databases"
   * "Designed to be intuitive and readable"
   * "Uses ASCII-art patterns to represent graphs"

. *Show Cypher vs SQL example:*

   *SQL (complex):*

[source,sql]
----
SELECT c.companyName, o.orderId
FROM customers c
JOIN orders o ON c.customerID = o.customerID;
----

   *Cypher (simple):*

[source,cypher]
----
MATCH (c:Customer)-[:PLACED]->(o:Order)
RETURN c.companyName, o.orderId;
----

   "The Cypher version reads like a sentence and matches the visual structure!"

. *Cypher basics - Nodes:*

[source,cypher]
----
()                          // Any node
(:Customer)                 // Node with label
(c:Customer)                // Node with variable
(c:Customer {customerId: 'ALFKI'})  // Node with properties
----

. *Cypher basics - Relationships:*

[source,cypher]
----
-->                         // Any relationship
-[:PLACED]->               // Named relationship
-[r:PLACED]->              // Relationship with variable
-[:PLACED]-                 // Bidirectional (any direction)
----

. *Cypher basics - Patterns:*

[source,cypher]
----
(c:Customer)-[:PLACED]->(o:Order)
(o:Order)-[:ORDERS]->(p:Product)
(p:Product)-[:PART_OF]->(cat:Category)
----

. *Core Cypher clauses:*
   * MATCH - Find patterns
   * WHERE - Filter results
   * RETURN - Specify what to return
   * CREATE - Create data
   * DELETE - Delete data

. *Open Query tool and run first query:*

[source,cypher]
----
MATCH (c:Customer)
RETURN c
LIMIT 10;
----

   * "Returns first 10 customers"
   * "Displays as graph visualization"

. *Style conventions:*
   * Labels: PascalCase (Customer, Product)
   * Relationships: UPPER_SNAKE_CASE (PLACED, PART_OF)
   * Properties: camelCase (companyName, unitPrice)
   * Keywords: UPPERCASE (MATCH, WHERE, RETURN)

*Key Message:* "Cypher makes graph queries natural and readable - patterns look like the graph itself."

'''

=== Lesson 2: Reading Data from Northwind (8 min)

*What to Show:*

* Open Query tool
* Run each example query
* Show graph and table views of results

*Talking Points:*

. *Simple queries - Find nodes by label:*

[source,cypher]
----
MATCH (c:Customer)
RETURN c
LIMIT 10;
----

   * "Returns first 10 Customer nodes"
   * "Graph view shows nodes visually"
   * Click "Table" to see properties

. *Return specific properties:*

[source,cypher]
----
MATCH (p:Product)
RETURN p.productName, p.unitPrice
ORDER BY p.unitPrice DESC
LIMIT 10;
----

   * "Returns 10 most expensive products"
   * "Only shows name and price columns"
   * Results: Côte de Blaye (263.50), Thüringer (123.79)...

. *Find specific nodes:*

[source,cypher]
----
MATCH (c:Customer {customerId: 'ALFKI'})
RETURN c.companyName, c.city, c.country;
----

   * "Finds one specific customer"
   * Result: Alfreds Futterkiste, Berlin, Germany

. *Traverse relationships:*

   *Customer's orders:*

[source,cypher]
----
MATCH (c:Customer {customerId: 'ALFKI'})-[:PLACED]->(o:Order)
RETURN c.companyName, o.orderId, o.orderDate
ORDER BY o.orderDate;
----

   * "Follows PLACED relationship from customer to orders"
   * "Shows customer name and order details"

. *Access relationship properties:*

   *Products in an order:*

[source,cypher]
----
MATCH (o:Order {orderId: 10248})-[rel:ORDERS]->(p:Product)
RETURN p.productName, rel.quantity, rel.unitPrice,
       rel.quantity * rel.unitPrice AS lineTotal
ORDER BY lineTotal DESC;
----

   * "Accesses quantity and unitPrice from relationship"
   * "Calculates line total"

. *Multi-hop traversals:*

   *Customer's purchased products:*

[source,cypher]
----
MATCH (c:Customer {customerId: 'ALFKI'})-[:PLACED]->(:Order)-[:ORDERS]->(p:Product)
RETURN DISTINCT p.productName
ORDER BY p.productName;
----

   * "Traverses TWO relationships: Customer→Order→Product"
   * "No JOINs needed"
   * "DISTINCT removes duplicates"

. *Counting results:*

   *Orders per customer:*

[source,cypher]
----
MATCH (c:Customer)-[:PLACED]->(o:Order)
RETURN c.companyName, count(o) AS orderCount
ORDER BY orderCount DESC
LIMIT 10;
----

   * "Counts orders for each customer"
   * "Shows top 10 customers by order count"

. *Return different types:*
   * Entire nodes: `RETURN c`
   * Properties: `RETURN c.companyName, c.city`
   * Paths: `RETURN path`
   * Computed values: `RETURN p.unitPrice * 1.2 AS priceWithTax`

*Instructor Tip:* Let participants run these queries themselves. Walk around and help troubleshoot.

*Key Message:* "Cypher queries read naturally and traverse relationships directly - no JOINs required."

'''

=== Lesson 3: Advanced Pattern Matching (8 min)

*What to Show:*

* Run advanced query examples
* Show variable-length paths
* Demonstrate optional matches
* Show pattern comprehensions

*Talking Points:*

. *Variable-length paths:*

   *Find all reports (direct and indirect):*

[source,cypher]
----
MATCH (manager:Employee {lastName: 'Fuller'})<-[:REPORTS_TO*]-(employee:Employee)
RETURN employee.firstName + ' ' + employee.lastName AS employee,
       length((manager)<-[:REPORTS_TO*]-(employee)) AS levels
ORDER BY levels, employee;
----

   * "The `*` means one or more hops"
   * "Finds employees who report to Fuller at any level"
   * "Can specify range: `*1..3` for 1 to 3 hops"

. *Optional matches:*

   *Products with or without orders:*

[source,cypher]
----
MATCH (p:Product)
OPTIONAL MATCH (p)<-[:ORDERS]-(o:Order)
RETURN p.productName, count(o) AS orderCount
ORDER BY orderCount DESC
LIMIT 10;
----

   * "OPTIONAL MATCH is like SQL's LEFT JOIN"
   * "Returns products even if they have no orders"
   * "Count is 0 for products never ordered"

. *Multiple patterns:*

   *Customers, orders, and employees:*

[source,cypher]
----
MATCH (c:Customer)-[:PLACED]->(o:Order),
      (e:Employee)-[:SOLD]->(o)
WHERE c.country = 'USA'
RETURN c.companyName, o.orderId, e.firstName + ' ' + e.lastName AS employee
LIMIT 10;
----

   * "Two patterns combined with comma"
   * "Both must match (like AND)"

. *Pattern predicates in WHERE:*

   *Customers who ordered Chai:*

[source,cypher]
----
MATCH (c:Customer)
WHERE (c)-[:PLACED]->(:Order)-[:ORDERS]->(:Product {productName: 'Chai'})
RETURN c.companyName, c.country
ORDER BY c.country;
----

   * "Pattern used as a filter condition"
   * "Only returns customers matching the pattern"

. *Shortest path:*

   *Path from employee to category:*

[source,cypher]
----
MATCH path = shortestPath(
  (e:Employee {lastName: 'Davolio'})-[*]-(cat:Category {categoryName: 'Beverages'})
)
RETURN path;
----

   * "Finds shortest path regardless of relationship types or directions"
   * "Useful for finding connections"

. *Collecting results:*

   *Customer's product list:*

[source,cypher]
----
MATCH (c:Customer {customerId: 'ALFKI'})-[:PLACED]->(:Order)-[:ORDERS]->(p:Product)
RETURN c.companyName, collect(DISTINCT p.productName) AS products;
----

   * "collect() aggregates values into a list"
   * "Returns one row with array of products"

*Key Message:* "Advanced patterns let you express complex queries concisely - things that would be painful in SQL."

'''

=== Lesson 4: Filtering Data with WHERE (6 min)

*What to Show:*

* Run filtering examples
* Show different WHERE conditions
* Combine multiple filters

*Talking Points:*

. *Comparison operators:*

   *Expensive products:*

[source,cypher]
----
MATCH (p:Product)
WHERE p.unitPrice > 50
RETURN p.productName, p.unitPrice
ORDER BY p.unitPrice DESC;
----

   * Operators: `=`, `<>`, `<`, `>`, `<=`, `>=`

. *Combining conditions:*

   *Expensive AND low stock:*

[source,cypher]
----
MATCH (p:Product)
WHERE p.unitPrice > 20 AND p.unitsInStock < 10
RETURN p.productName, p.unitPrice, p.unitsInStock;
----

   * "Both conditions must be true"

. *OR conditions:*

   *Germany OR France:*

[source,cypher]
----
MATCH (c:Customer)
WHERE c.country = 'Germany' OR c.country = 'France'
RETURN c.companyName, c.country
ORDER BY c.country;
----

. *IN operator:*

   *Multiple countries:*

[source,cypher]
----
MATCH (c:Customer)
WHERE c.country IN ['Germany', 'France', 'Spain']
RETURN c.companyName, c.country
ORDER BY c.country;
----

   * "Cleaner than multiple ORs"

. *String matching:*

   *STARTS WITH:*

[source,cypher]
----
MATCH (c:Customer)
WHERE c.companyName STARTS WITH 'A'
RETURN c.companyName
ORDER BY c.companyName;
----

   *CONTAINS:*

[source,cypher]
----
MATCH (p:Product)
WHERE p.productName CONTAINS 'chocolate'
RETURN p.productName;
----

   *Case-insensitive:*

[source,cypher]
----
WHERE toLower(p.productName) CONTAINS 'chocolate'
----

. *NULL checks:*

   *Orders not yet shipped:*

[source,cypher]
----
MATCH (o:Order)
WHERE o.shippedDate IS NULL
RETURN o.orderId, o.orderDate, o.requiredDate
LIMIT 10;
----

. *Filtering on relationships:*

   *Customers who placed orders:*

[source,cypher]
----
MATCH (c:Customer)
WHERE EXISTS { (c)-[:PLACED]->(:Order) }
RETURN c.companyName;
----

. *Filtering aggregates with WITH:*

   *Customers with many orders:*

[source,cypher]
----
MATCH (c:Customer)-[:PLACED]->(o:Order)
WITH c, count(o) AS orderCount
WHERE orderCount > 10
RETURN c.companyName, orderCount
ORDER BY orderCount DESC;
----

   * "WITH lets you filter on aggregated values"

*Key Message:* "WHERE clause gives you powerful filtering options - from simple comparisons to complex pattern checks."

'''

=== Lesson 5: Aggregating and Analyzing Data (8 min)

*What to Show:*

* Run aggregation examples
* Show count, sum, avg
* Demonstrate grouping behavior

*Talking Points:*

. *Counting:*

   *Total customers:*

[source,cypher]
----
MATCH (c:Customer)
RETURN count(c) AS customerCount;
----

   * Result: 91

   *Count distinct:*

[source,cypher]
----
MATCH (o:Order)
RETURN count(DISTINCT o.shipCountry) AS countriesShippedTo;
----

. *Implicit grouping:*

   *Orders per customer:*

[source,cypher]
----
MATCH (c:Customer)-[:PLACED]->(o:Order)
RETURN c.companyName, count(o) AS orderCount
ORDER BY orderCount DESC
LIMIT 10;
----

   * "No GROUP BY clause needed"
   * "Cypher groups by non-aggregated fields automatically"
   * "Groups by c.companyName, counts orders"

. *Sum and average:*

   *Freight statistics:*

[source,cypher]
----
MATCH (o:Order)
RETURN sum(o.freight) AS totalFreight,
       avg(o.freight) AS averageFreight,
       min(o.freight) AS minFreight,
       max(o.freight) AS maxFreight;
----

. *Calculate order totals:*

   *Order 10248 total:*

[source,cypher]
----
MATCH (o:Order {orderId: 10248})-[r:ORDERS]->(p:Product)
RETURN o.orderId,
       sum(r.quantity * r.unitPrice) AS orderTotal,
       sum(r.quantity) AS totalItems,
       count(p) AS productTypes;
----

   * "Accesses relationship properties"
   * "Multiplies quantity × price"
   * "Sums line totals"

. *Revenue by customer:*

   *Top customers by revenue:*

[source,cypher]
----
MATCH (c:Customer)-[:PLACED]->(o:Order)-[r:ORDERS]->(p:Product)
RETURN c.companyName,
       sum(r.quantity * r.unitPrice * (1 - r.discount)) AS totalRevenue
ORDER BY totalRevenue DESC
LIMIT 10;
----

   * "Includes discount calculation"
   * "Shows top 10 customers by revenue"

. *Collecting into lists:*

   *Products by category:*

[source,cypher]
----
MATCH (cat:Category)<-[:PART_OF]-(p:Product)
RETURN cat.categoryName,
       collect(p.productName) AS products,
       count(p) AS productCount
ORDER BY cat.categoryName;
----

   * "collect() creates an array"
   * "Useful for seeing all related items"

. *Chaining with WITH:*

   *Top product per category:*

[source,cypher]
----
MATCH (cat:Category)<-[:PART_OF]-(p:Product)<-[r:ORDERS]-(:Order)
WITH cat, p, sum(r.quantity) AS totalOrdered
ORDER BY cat.categoryName, totalOrdered DESC
WITH cat, collect({product: p.productName, quantity: totalOrdered})[0] AS topProduct
RETURN cat.categoryName, topProduct.product, topProduct.quantity
ORDER BY cat.categoryName;
----

   * "WITH lets you chain query parts"
   * "First WITH: calculate totals per product"
   * "Second WITH: collect and take first (top)"

. *Conditional aggregation:*

   *Order status summary:*

[source,cypher]
----
MATCH (o:Order)
RETURN count(o) AS totalOrders,
       count(CASE WHEN o.shippedDate IS NULL THEN 1 END) AS notShipped,
       count(CASE WHEN o.shippedDate IS NOT NULL THEN 1 END) AS shipped,
       count(CASE WHEN o.shippedDate > o.requiredDate THEN 1 END) AS lateShipments;
----

   * "CASE expressions within count()"
   * "Multiple metrics in one query"

*Key Message:* "Cypher's aggregation functions let you analyze your data without moving it out of the database."

'''

== Workshop Wrap-Up (5 minutes)

=== Final Summary

*What to Show:*

* Show the complete graph in Explore tool
* Display a complex query that brings it all together

*Talking Points:*

. *Recap what we've accomplished:*
   * "Created a Neo4j Aura instance"
   * "Modeled the Northwind dataset as a graph"
   * "Imported 7 CSV files with ~1,000 nodes and ~4,000 relationships"
   * "Wrote Cypher queries to explore business data"

. *Show the complete graph:*
   * Open Explore tool
   * "Here's your complete Northwind graph"
   * Click around to show connections

. *Run a final complex query:*

[source,cypher]
----
MATCH (c:Customer {customerId: 'ALFKI'})-[:PLACED]->(o:Order)-[r:ORDERS]->(p:Product)-[:PART_OF]->(cat:Category)
RETURN c.companyName AS customer,
       cat.categoryName AS category,
       count(DISTINCT o) AS orders,
       sum(r.quantity) AS totalItems,
       sum(r.quantity * r.unitPrice * (1 - r.discount)) AS totalSpent
ORDER BY totalSpent DESC;
----

   * "This query shows everything we learned:"
   * "Pattern matching across multiple relationships"
   * "Accessing relationship properties"
   * "Aggregation and calculation"
   * "All in one readable query"

. *Next steps:*
   * "Build an application: link:https://graphacademy.neo4j.com/courses/app-python[Building Neo4j Applications^]"
   * "Master Cypher: link:https://graphacademy.neo4j.com/courses/cypher-fundamentals[Cypher Fundamentals^]"
   * "Get certified: link:https://graphacademy.neo4j.com/categories/certification[Neo4j Certification^]"
   * "Explore more courses: https://graphacademy.neo4j.com"

. *Encourage questions:*
   * "What questions do you have?"
   * "What will you build with Neo4j?"

*Key Message:* "You now have the skills to model data as graphs, import CSV files, and query graph databases. The rest is practice and exploration!"

'''

== Appendix: Timing Guide

=== 2-Hour Workshop (Core Content)

* Module 1: Aura Setup - 15 min
* Module 2: Data Modeling - 40 min (skip lesson 7: Refactoring)
* BREAK - 10 min
* Module 3: Importing Data - 30 min
* Module 4: Querying Data - 25 min (lessons 1-2 only, brief overview of 3-5)

=== 4-Hour Workshop (With Stretch Goals)

* Module 1: Aura Setup - 15 min
* Module 2: Data Modeling - 50 min (include refactoring)
* BREAK - 10 min
* Module 3: Importing Data - 35 min
* BREAK - 10 min
* Module 4: Querying Data - 80 min (all lessons with practice time)
* Wrap-up and Q&A - 10 min

'''

== Appendix: Common Questions & Answers

*Q: "What if I lose my credentials?"*

A: You can reset the password in the Aura console. Go to your instance → Settings → Reset password.

*Q: "Can I use my own dataset instead of Northwind?"*

A: Yes! The same principles apply. Start with your CSV files and follow the same modeling and import process.

*Q: "How much does Aura cost after the free tier?"*

A: Professional tier starts around $65/month. Enterprise tier is custom pricing. Free tier is free forever.

*Q: "Can I export my data from Aura?"*

A: Yes, you can export to CSV or create database dumps. Use the export features in the Aura console.

*Q: "What's the difference between Neo4j Desktop and Aura?"*

A: Desktop is a local installation on your machine. Aura is cloud-hosted and fully managed. Both run Neo4j database.

*Q: "How do I delete my instance when I'm done?"*

A: Aura console → Select instance → Settings → Delete instance. Be careful - this is permanent!

*Q: "Can I connect to Aura from Python/Java/etc?"*

A: Yes! Use the official Neo4j drivers. Your connection URI and credentials work with all drivers.

*Q: "How big can my graph be in the free tier?"*

A: Free tier supports up to 200k nodes and relationships, 50MB storage. Plenty for learning and small projects.

'''

== Appendix: Troubleshooting Guide

*Issue: Data Importer shows "Connection Error"*

* Check if instance is running (should show green status)
* Try refreshing the browser
* Check browser console for errors
* Try closing and reopening Data Importer

*Issue: Import fails with "Constraint violation"*

* Check for duplicate IDs in your CSV files
* Ensure ID columns don't have blank values
* Verify ID property is set correctly on each node

*Issue: Relationship not connecting*

* Verify both source and target nodes exist
* Check ID mappings - column name must match node property
* Ensure CSV file has both ID columns
* Check for case sensitivity in IDs

*Issue: Query returns no results*

* Verify data was imported: `MATCH (n) RETURN count(n)`
* Check label names - case sensitive
* Check property names - case sensitive
* Try simpler query first to isolate issue

*Issue: Query is very slow*

* Check if you're using labels: `MATCH (n:Customer)` not just `MATCH (n)`
* Ensure you're filtering by indexed properties (ID properties)
* Limit results: add `LIMIT 100`
* Avoid returning all nodes: `MATCH (n) RETURN n` will be slow on large graphs

'''

== Appendix: Additional Demo Ideas

=== Demo 1: Show the Power of Relationships

Compare finding products a customer purchased:

* In relational: Show 3-table JOIN
* In graph: Show simple 2-hop traversal
* Run both queries (if you have access to both systems)
* Highlight the performance difference

=== Demo 2: Recommendation Query

"Customers who bought Chai also bought..."

[source,cypher]
----
MATCH (c:Customer)-[:PLACED]->(:Order)-[:ORDERS]->(p1:Product {productName: 'Chai'})
MATCH (c)-[:PLACED]->(:Order)-[:ORDERS]->(p2:Product)
WHERE p1 <> p2
RETURN p2.productName, count(*) AS frequency
ORDER BY frequency DESC
LIMIT 5;
----

=== Demo 3: Organizational Hierarchy

"Show the full employee hierarchy:"

[source,cypher]
----
MATCH path = (e:Employee)-[:REPORTS_TO*]->(manager:Employee)
WHERE NOT (manager)-[:REPORTS_TO]->()
RETURN path;
----

=== Demo 4: Complex Business Question

"Which employee sold the most diverse product categories?"

[source,cypher]
----
MATCH (e:Employee)-[:SOLD]->(:Order)-[:ORDERS]->(:Product)-[:PART_OF]->(cat:Category)
RETURN e.firstName + ' ' + e.lastName AS employee,
       count(DISTINCT cat) AS categoriesSold
ORDER BY categoriesSold DESC
LIMIT 5;
----
