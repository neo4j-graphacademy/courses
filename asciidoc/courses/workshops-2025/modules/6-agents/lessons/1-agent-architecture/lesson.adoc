= Agent Architecture for Financial Intelligence
:type: lesson
:order: 1
:duration: 20 minutes

== Learning Objectives

By the end of this lesson, you will be able to:

* Understand the architecture of intelligent agents for financial analysis
* Design agent workflows for complex financial research tasks
* Implement tool-based agents using LangChain and Neo4j
* Build conversation memory systems that track entity interactions

== Introduction to Financial Intelligence Agents

Financial intelligence agents are autonomous systems that can reason about financial data, plan multi-step analysis workflows, and interact with various data sources to answer complex questions. Unlike simple chatbots, these agents can:

* **Plan and Execute**: Break down complex financial queries into sub-tasks
* **Use Tools**: Access databases, APIs, and analysis functions dynamically
* **Maintain Context**: Remember previous interactions and build on them
* **Track Entities**: Monitor which companies, risks, and metrics are discussed
* **Learn and Adapt**: Improve responses based on interaction patterns

=== Financial Agent Use Cases

```python
# Real-world financial agent applications
financial_agent_applications = {
    'investment_research': {
        'description': 'Multi-step company analysis combining quantitative and qualitative data',
        'capabilities': [
            'Analyze SEC filings for competitive advantages',
            'Cross-reference risk factors with market data',
            'Generate investment thesis reports',
            'Track management commentary trends'
        ],
        'example_workflow': [
            '1. Extract company fundamentals from filings',
            '2. Identify key risk factors and competitive threats',
            '3. Analyze institutional ownership patterns',
            '4. Generate comprehensive investment recommendation'
        ]
    },
    'portfolio_risk_analysis': {
        'description': 'Systematic risk assessment across investment portfolios',
        'capabilities': [
            'Identify concentration risks across holdings',
            'Map risk factor correlations between companies',
            'Monitor regulatory compliance issues',
            'Track ESG risk exposures'
        ],
        'example_workflow': [
            '1. Analyze portfolio composition and weightings',
            '2. Identify shared risk factors across holdings',
            '3. Assess systemic risk through network analysis',
            '4. Generate risk mitigation recommendations'
        ]
    },
    'market_intelligence': {
        'description': 'Competitive landscape analysis and market trend identification',
        'capabilities': [
            'Monitor competitive positioning changes',
            'Track product launch announcements',
            'Analyze market share dynamics',
            'Identify emerging industry trends'
        ],
        'example_workflow': [
            '1. Gather competitive intelligence from filings',
            '2. Identify market share shifts and new entrants',
            '3. Analyze strategic initiative announcements',
            '4. Synthesize market outlook and implications'
        ]
    },
    'regulatory_compliance': {
        'description': 'Automated monitoring of regulatory changes and compliance risks',
        'capabilities': [
            'Track regulatory filing requirements',
            'Monitor compliance risk mentions',
            'Identify regulatory environment changes',
            'Generate compliance risk alerts'
        ],
        'example_workflow': [
            '1. Scan filings for regulatory risk mentions',
            '2. Cross-reference with regulatory databases',
            '3. Assess compliance impact across portfolio',
            '4. Generate regulatory risk dashboard'
        ]
    }
}

print("Financial Intelligence Agent Applications:")
print("=" * 60)

for app_type, details in financial_agent_applications.items():
    print(f"\n{app_type.replace('_', ' ').title()}:")
    print(f"  Description: {details['description']}")
    print(f"  Key Capabilities:")
    for capability in details['capabilities']:
        print(f"    â€¢ {capability}")
    print(f"  Example Workflow:")
    for step in details['example_workflow']:
        print(f"    {step}")
```

== Agent Architecture Components

=== Core Agent Architecture

Financial intelligence agents consist of several key components working together:

```python
from dataclasses import dataclass
from typing import List, Dict, Optional, Any
from enum import Enum

class AgentRole(Enum):
    ANALYST = "financial_analyst"
    RESEARCHER = "investment_researcher" 
    RISK_MANAGER = "risk_manager"
    COMPLIANCE_OFFICER = "compliance_officer"

@dataclass
class AgentCapability:
    name: str
    description: str
    tools_required: List[str]
    data_sources: List[str]
    output_format: str

@dataclass
class AgentArchitecture:
    """Core architecture for financial intelligence agents"""
    
    # Agent Identity and Role
    agent_id: str
    role: AgentRole
    capabilities: List[AgentCapability]
    
    # Planning and Reasoning
    planning_engine: str  # "react", "plan_and_execute", "hierarchical"
    reasoning_model: str  # "gpt-4", "claude-3", etc.
    
    # Memory and Context
    conversation_memory: str  # "neo4j", "redis", "local"
    entity_tracking: bool
    session_persistence: bool
    
    # Tools and Integration
    available_tools: List[str]
    data_connectors: List[str]
    api_integrations: List[str]
    
    # Knowledge Base
    domain_knowledge: Dict[str, Any]
    entity_schemas: List[str]
    relationship_types: List[str]

# Example: Investment Research Agent Architecture
investment_agent_arch = AgentArchitecture(
    agent_id="investment_research_agent_001",
    role=AgentRole.RESEARCHER,
    capabilities=[
        AgentCapability(
            name="company_analysis",
            description="Comprehensive analysis of company fundamentals and strategy",
            tools_required=["sec_filing_analyzer", "financial_metrics_extractor", "competitive_intelligence"],
            data_sources=["sec_filings", "financial_data", "market_data"],
            output_format="structured_report"
        ),
        AgentCapability(
            name="risk_assessment",
            description="Multi-dimensional risk factor analysis",
            tools_required=["risk_factor_extractor", "correlation_analyzer", "scenario_modeler"],
            data_sources=["risk_disclosures", "market_data", "economic_indicators"],
            output_format="risk_dashboard"
        )
    ],
    planning_engine="react",
    reasoning_model="gpt-4",
    conversation_memory="neo4j",
    entity_tracking=True,
    session_persistence=True,
    available_tools=["database_query", "web_search", "financial_calculator", "report_generator"],
    data_connectors=["neo4j_graph", "sec_api", "market_data_feed"],
    api_integrations=["openai", "neo4j", "sec_edgar"],
    domain_knowledge={
        "financial_metrics": ["revenue", "earnings", "debt_ratios", "growth_rates"],
        "risk_categories": ["market", "credit", "operational", "regulatory"],
        "analysis_frameworks": ["dcf", "comparable_analysis", "sum_of_parts"]
    },
    entity_schemas=["Company", "Financial_Metric", "Risk_Factor", "Asset_Manager"],
    relationship_types=["HOLDS", "FACES_RISK", "HAS_METRIC", "COMPETES_WITH"]
)

print("Investment Research Agent Architecture:")
print(f"  Agent ID: {investment_agent_arch.agent_id}")
print(f"  Role: {investment_agent_arch.role.value}")
print(f"  Planning Engine: {investment_agent_arch.planning_engine}")
print(f"  Capabilities: {len(investment_agent_arch.capabilities)}")
print(f"  Available Tools: {len(investment_agent_arch.available_tools)}")
print(f"  Entity Tracking: {investment_agent_arch.entity_tracking}")
```

=== Planning and Reasoning Engines

Different planning approaches for different types of financial analysis:

```python
class FinancialAgentPlanner:
    """Planning engine for financial intelligence agents"""
    
    def __init__(self, planning_strategy: str = "react"):
        self.strategy = planning_strategy
        self.task_templates = self._load_task_templates()
    
    def _load_task_templates(self) -> Dict[str, Dict]:
        """Load pre-defined task templates for common financial analyses"""
        
        return {
            'company_analysis': {
                'description': 'Comprehensive company analysis workflow',
                'steps': [
                    {
                        'step': 1,
                        'action': 'extract_company_fundamentals',
                        'tools': ['sec_filing_analyzer', 'financial_metrics_extractor'],
                        'inputs': ['company_name'],
                        'outputs': ['financial_metrics', 'business_overview']
                    },
                    {
                        'step': 2,
                        'action': 'analyze_competitive_position',
                        'tools': ['competitive_intelligence', 'market_analyzer'],
                        'inputs': ['company_name', 'industry_sector'],
                        'outputs': ['competitive_advantages', 'market_position']
                    },
                    {
                        'step': 3,
                        'action': 'assess_risk_factors',
                        'tools': ['risk_factor_extractor', 'risk_analyzer'],
                        'inputs': ['company_name', 'filing_documents'],
                        'outputs': ['risk_factors', 'risk_assessment']
                    },
                    {
                        'step': 4,
                        'action': 'generate_investment_thesis',
                        'tools': ['report_generator', 'synthesis_engine'],
                        'inputs': ['financial_metrics', 'competitive_advantages', 'risk_factors'],
                        'outputs': ['investment_recommendation', 'key_risks', 'price_target']
                    }
                ],
                'dependencies': {
                    2: [1],  # Step 2 depends on Step 1
                    3: [1],  # Step 3 depends on Step 1
                    4: [1, 2, 3]  # Step 4 depends on all previous steps
                }
            },
            'portfolio_risk_analysis': {
                'description': 'Portfolio-level risk assessment workflow',
                'steps': [
                    {
                        'step': 1,
                        'action': 'identify_portfolio_holdings',
                        'tools': ['portfolio_analyzer', 'holdings_extractor'],
                        'inputs': ['asset_manager_name', 'portfolio_id'],
                        'outputs': ['holdings_list', 'position_sizes', 'sector_allocation']
                    },
                    {
                        'step': 2,
                        'action': 'extract_company_risk_factors',
                        'tools': ['risk_factor_extractor', 'company_analyzer'],
                        'inputs': ['holdings_list'],
                        'outputs': ['company_risks', 'risk_categories']
                    },
                    {
                        'step': 3,
                        'action': 'analyze_risk_correlations',
                        'tools': ['correlation_analyzer', 'network_analyzer'],
                        'inputs': ['company_risks', 'holdings_list'],
                        'outputs': ['risk_correlations', 'systemic_risks']
                    },
                    {
                        'step': 4,
                        'action': 'generate_risk_report',
                        'tools': ['risk_reporter', 'visualization_engine'],
                        'inputs': ['risk_correlations', 'position_sizes', 'systemic_risks'],
                        'outputs': ['risk_dashboard', 'concentration_analysis', 'recommendations']
                    }
                ],
                'dependencies': {
                    2: [1],
                    3: [1, 2],
                    4: [1, 2, 3]
                }
            },
            'competitive_intelligence': {
                'description': 'Competitive landscape analysis workflow',
                'steps': [
                    {
                        'step': 1,
                        'action': 'identify_industry_peers',
                        'tools': ['peer_identifier', 'industry_classifier'],
                        'inputs': ['company_name', 'business_description'],
                        'outputs': ['peer_companies', 'industry_classification']
                    },
                    {
                        'step': 2,
                        'action': 'analyze_competitive_positioning',
                        'tools': ['positioning_analyzer', 'strategy_extractor'],
                        'inputs': ['company_name', 'peer_companies'],
                        'outputs': ['market_position', 'competitive_advantages', 'strategic_initiatives']
                    },
                    {
                        'step': 3,
                        'action': 'track_market_dynamics',
                        'tools': ['market_tracker', 'trend_analyzer'],
                        'inputs': ['industry_classification', 'peer_companies'],
                        'outputs': ['market_trends', 'competitive_threats', 'growth_opportunities']
                    },
                    {
                        'step': 4,
                        'action': 'synthesize_intelligence',
                        'tools': ['intelligence_synthesizer', 'insight_generator'],
                        'inputs': ['market_position', 'market_trends', 'competitive_threats'],
                        'outputs': ['competitive_intelligence_report', 'strategic_recommendations']
                    }
                ],
                'dependencies': {
                    2: [1],
                    3: [1],
                    4: [1, 2, 3]
                }
            }
        }
    
    def plan_analysis(self, analysis_type: str, inputs: Dict[str, Any]) -> Dict:
        """Generate execution plan for a specific analysis type"""
        
        if analysis_type not in self.task_templates:
            return {'error': f'Unknown analysis type: {analysis_type}'}
        
        template = self.task_templates[analysis_type]
        
        # Create execution plan
        execution_plan = {
            'analysis_type': analysis_type,
            'description': template['description'],
            'total_steps': len(template['steps']),
            'inputs': inputs,
            'execution_order': self._determine_execution_order(template),
            'estimated_duration': self._estimate_duration(template),
            'required_tools': self._extract_required_tools(template),
            'expected_outputs': self._extract_expected_outputs(template)
        }
        
        return execution_plan
    
    def _determine_execution_order(self, template: Dict) -> List[int]:
        """Determine optimal execution order based on dependencies"""
        
        steps = template['steps']
        dependencies = template.get('dependencies', {})
        
        # Simple topological sort for dependency resolution
        executed = set()
        execution_order = []
        
        while len(executed) < len(steps):
            for step in steps:
                step_num = step['step']
                if step_num in executed:
                    continue
                
                # Check if all dependencies are satisfied
                deps = dependencies.get(step_num, [])
                if all(dep in executed for dep in deps):
                    execution_order.append(step_num)
                    executed.add(step_num)
        
        return execution_order
    
    def _estimate_duration(self, template: Dict) -> Dict[str, int]:
        """Estimate execution duration for the analysis"""
        
        # Simple duration estimation based on step complexity
        step_durations = {
            'extract_company_fundamentals': 30,
            'analyze_competitive_position': 45,
            'assess_risk_factors': 25,
            'generate_investment_thesis': 20,
            'identify_portfolio_holdings': 15,
            'extract_company_risk_factors': 40,
            'analyze_risk_correlations': 35,
            'generate_risk_report': 25
        }
        
        total_seconds = 0
        for step in template['steps']:
            action = step['action']
            duration = step_durations.get(action, 30)  # Default 30 seconds
            total_seconds += duration
        
        return {
            'total_seconds': total_seconds,
            'estimated_minutes': round(total_seconds / 60, 1),
            'complexity_level': 'High' if total_seconds > 120 else 'Medium' if total_seconds > 60 else 'Low'
        }
    
    def _extract_required_tools(self, template: Dict) -> List[str]:
        """Extract all tools required for the analysis"""
        
        tools = set()
        for step in template['steps']:
            tools.update(step['tools'])
        
        return list(tools)
    
    def _extract_expected_outputs(self, template: Dict) -> List[str]:
        """Extract all expected outputs from the analysis"""
        
        outputs = set()
        for step in template['steps']:
            outputs.update(step['outputs'])
        
        return list(outputs)

# Example usage
planner = FinancialAgentPlanner()

# Plan a company analysis
company_analysis_plan = planner.plan_analysis('company_analysis', {
    'company_name': 'APPLE INC',
    'industry_sector': 'Technology'
})

print("Company Analysis Execution Plan:")
print(f"  Total Steps: {company_analysis_plan['total_steps']}")
print(f"  Execution Order: {company_analysis_plan['execution_order']}")
print(f"  Estimated Duration: {company_analysis_plan['estimated_duration']['estimated_minutes']} minutes")
print(f"  Required Tools: {', '.join(company_analysis_plan['required_tools'])}")
print(f"  Expected Outputs: {len(company_analysis_plan['expected_outputs'])} deliverables")
```

== Tool-Based Agent Architecture

=== Financial Tool Ecosystem

Agents use specialized tools to access and analyze financial data:

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional

class FinancialTool(ABC):
    """Base class for financial analysis tools"""
    
    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description
        self.usage_count = 0
        self.last_used = None
    
    @abstractmethod
    def execute(self, inputs: Dict[str, Any]) -> Dict[str, Any]:
        """Execute the tool with given inputs"""
        pass
    
    def log_usage(self):
        """Log tool usage statistics"""
        self.usage_count += 1
        from datetime import datetime
        self.last_used = datetime.now()

class SECFilingAnalyzer(FinancialTool):
    """Tool for analyzing SEC filings and extracting key information"""
    
    def __init__(self, neo4j_driver):
        super().__init__(
            name="SEC Filing Analyzer",
            description="Analyzes SEC filings to extract business overview, risk factors, and financial metrics"
        )
        self.driver = neo4j_driver
    
    def execute(self, inputs: Dict[str, Any]) -> Dict[str, Any]:
        """Extract information from SEC filings for a company"""
        
        self.log_usage()
        company_name = inputs.get('company_name')
        analysis_type = inputs.get('analysis_type', 'comprehensive')
        
        if not company_name:
            return {'error': 'Company name is required'}
        
        # Query Neo4j for company filing information
        query = """
        MATCH (c:Company {name: $company_name})-[:FILED]->(doc:Document)
        OPTIONAL MATCH (c)-[:HAS_METRIC]->(metric:FinancialMetric)
        OPTIONAL MATCH (c)-[:FACES_RISK]->(risk:RiskFactor)
        OPTIONAL MATCH (c)-[:MENTIONS]->(product:Product)
        
        RETURN c.name AS company,
               c.ticker AS ticker,
               collect(DISTINCT doc.id) AS filing_documents,
               collect(DISTINCT metric.name) AS financial_metrics,
               collect(DISTINCT risk.name) AS risk_factors,
               collect(DISTINCT product.name) AS products
        """
        
        with self.driver.session() as session:
            result = session.run(query, company_name=company_name)
            record = result.single()
            
            if record:
                return {
                    'company': record['company'],
                    'ticker': record['ticker'],
                    'filing_documents': record['filing_documents'],
                    'financial_metrics': record['financial_metrics'],
                    'risk_factors': record['risk_factors'],
                    'products': record['products'],
                    'analysis_type': analysis_type,
                    'tool_used': self.name
                }
            else:
                return {'error': f'Company {company_name} not found in database'}

class CompetitiveIntelligenceTool(FinancialTool):
    """Tool for competitive analysis and market positioning"""
    
    def __init__(self, neo4j_driver):
        super().__init__(
            name="Competitive Intelligence",
            description="Analyzes competitive landscape and market positioning"
        )
        self.driver = neo4j_driver
    
    def execute(self, inputs: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze competitive landscape for a company"""
        
        self.log_usage()
        company_name = inputs.get('company_name')
        analysis_scope = inputs.get('scope', 'direct_competitors')
        
        # Find competitors through shared products, risks, or asset managers
        competitor_query = """
        MATCH (c:Company {name: $company_name})
        
        // Find competitors through shared products
        OPTIONAL MATCH (c)-[:MENTIONS]->(product:Product)<-[:MENTIONS]-(competitor1:Company)
        WHERE competitor1 <> c
        
        // Find competitors through shared risk factors
        OPTIONAL MATCH (c)-[:FACES_RISK]->(risk:RiskFactor)<-[:FACES_RISK]-(competitor2:Company)
        WHERE competitor2 <> c
        
        // Find companies held by same asset managers
        OPTIONAL MATCH (c)<-[:HOLDS]-(am:AssetManager)-[:HOLDS]->(competitor3:Company)
        WHERE competitor3 <> c
        
        WITH c,
             collect(DISTINCT {competitor: competitor1.name, connection: 'shared_products'}) AS product_competitors,
             collect(DISTINCT {competitor: competitor2.name, connection: 'shared_risks'}) AS risk_competitors,
             collect(DISTINCT {competitor: competitor3.name, connection: 'shared_investors'}) AS investor_competitors
        
        RETURN c.name AS company,
               product_competitors,
               risk_competitors,
               investor_competitors
        """
        
        with self.driver.session() as session:
            result = session.run(competitor_query, company_name=company_name)
            record = result.single()
            
            if record:
                # Aggregate all competitors
                all_competitors = set()
                competitive_connections = {}
                
                for comp_list, connection_type in [
                    (record['product_competitors'], 'shared_products'),
                    (record['risk_competitors'], 'shared_risks'),
                    (record['investor_competitors'], 'shared_investors')
                ]:
                    for comp_info in comp_list:
                        competitor = comp_info['competitor']
                        if competitor:
                            all_competitors.add(competitor)
                            if competitor not in competitive_connections:
                                competitive_connections[competitor] = []
                            competitive_connections[competitor].append(connection_type)
                
                return {
                    'company': record['company'],
                    'total_competitors_identified': len(all_competitors),
                    'competitors': list(all_competitors),
                    'competitive_connections': competitive_connections,
                    'analysis_scope': analysis_scope,
                    'tool_used': self.name
                }
            else:
                return {'error': f'Company {company_name} not found for competitive analysis'}

class RiskAssessmentTool(FinancialTool):
    """Tool for comprehensive risk factor analysis"""
    
    def __init__(self, neo4j_driver):
        super().__init__(
            name="Risk Assessment Tool",
            description="Analyzes risk factors and their interconnections across entities"
        )
        self.driver = neo4j_driver
    
    def execute(self, inputs: Dict[str, Any]) -> Dict[str, Any]:
        """Perform risk assessment analysis"""
        
        self.log_usage()
        entity_name = inputs.get('entity_name')
        entity_type = inputs.get('entity_type', 'Company')
        risk_scope = inputs.get('scope', 'direct_and_network')
        
        # Analyze risk factors and their network effects
        risk_query = f"""
        MATCH (entity:{entity_type} {{name: $entity_name}})
        
        // Direct risks
        OPTIONAL MATCH (entity)-[:FACES_RISK]->(direct_risk:RiskFactor)
        
        // Network risks through connections
        OPTIONAL MATCH (entity)<-[:HOLDS]-(am:AssetManager)-[:HOLDS]->(connected:Company)-[:FACES_RISK]->(network_risk:RiskFactor)
        WHERE connected <> entity
        
        // Risk contagion paths
        OPTIONAL MATCH path = (entity)-[:FACES_RISK]->(shared_risk:RiskFactor)<-[:FACES_RISK]-(other:Company)
        WHERE other <> entity
        
        WITH entity,
             collect(DISTINCT direct_risk.name) AS direct_risks,
             collect(DISTINCT {{
                 risk: network_risk.name,
                 through_company: connected.name,
                 asset_manager: am.name
             }}) AS network_risks,
             collect(DISTINCT {{
                 risk: shared_risk.name,
                 shared_with: other.name
             }}) AS shared_risks
        
        RETURN entity.name AS entity_name,
               direct_risks,
               network_risks,
               shared_risks,
               size(direct_risks) AS direct_risk_count,
               size(network_risks) AS network_risk_count,
               size(shared_risks) AS shared_risk_count
        """
        
        with self.driver.session() as session:
            result = session.run(risk_query, entity_name=entity_name)
            record = result.single()
            
            if record:
                # Calculate risk scores
                direct_risk_score = min(record['direct_risk_count'] * 10, 100)
                network_risk_score = min(record['network_risk_count'] * 5, 50)
                shared_risk_score = min(record['shared_risk_count'] * 3, 30)
                
                total_risk_score = direct_risk_score + network_risk_score + shared_risk_score
                
                return {
                    'entity_name': record['entity_name'],
                    'entity_type': entity_type,
                    'direct_risks': record['direct_risks'],
                    'network_risks': record['network_risks'],
                    'shared_risks': record['shared_risks'],
                    'risk_scores': {
                        'direct_risk_score': direct_risk_score,
                        'network_risk_score': network_risk_score,
                        'shared_risk_score': shared_risk_score,
                        'total_risk_score': min(total_risk_score, 100)
                    },
                    'risk_level': self._classify_risk_level(total_risk_score),
                    'tool_used': self.name
                }
            else:
                return {'error': f'{entity_type} {entity_name} not found for risk assessment'}
    
    def _classify_risk_level(self, risk_score: float) -> str:
        """Classify overall risk level based on score"""
        if risk_score >= 80:
            return 'VERY HIGH'
        elif risk_score >= 60:
            return 'HIGH'
        elif risk_score >= 40:
            return 'MEDIUM'
        elif risk_score >= 20:
            return 'LOW'
        else:
            return 'VERY LOW'

# Tool Registry for Agent Access
class FinancialToolRegistry:
    """Registry for managing and accessing financial analysis tools"""
    
    def __init__(self, neo4j_driver):
        self.driver = neo4j_driver
        self.tools = {}
        self._register_standard_tools()
    
    def _register_standard_tools(self):
        """Register standard financial analysis tools"""
        
        self.tools['sec_filing_analyzer'] = SECFilingAnalyzer(self.driver)
        self.tools['competitive_intelligence'] = CompetitiveIntelligenceTool(self.driver)
        self.tools['risk_assessment'] = RiskAssessmentTool(self.driver)
    
    def get_tool(self, tool_name: str) -> Optional[FinancialTool]:
        """Get a tool by name"""
        return self.tools.get(tool_name)
    
    def list_available_tools(self) -> List[Dict[str, str]]:
        """List all available tools with descriptions"""
        return [
            {
                'name': tool.name,
                'description': tool.description,
                'usage_count': tool.usage_count
            }
            for tool in self.tools.values()
        ]
    
    def execute_tool(self, tool_name: str, inputs: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a tool with given inputs"""
        
        tool = self.get_tool(tool_name)
        if not tool:
            return {'error': f'Tool {tool_name} not found'}
        
        try:
            return tool.execute(inputs)
        except Exception as e:
            return {'error': f'Tool execution failed: {str(e)}'}

# Example tool registry usage
from neo4j import GraphDatabase

# tool_registry = FinancialToolRegistry(GraphDatabase.driver("bolt://localhost:7687", auth=("neo4j", "password")))
# 
# # List available tools
# print("Available Financial Analysis Tools:")
# for tool_info in tool_registry.list_available_tools():
#     print(f"  {tool_info['name']}: {tool_info['description']}")
# 
# # Execute SEC filing analysis
# sec_result = tool_registry.execute_tool('sec_filing_analyzer', {
#     'company_name': 'APPLE INC',
#     'analysis_type': 'comprehensive'
# })
# 
# print(f"\nSEC Filing Analysis Result:")
# print(f"  Company: {sec_result.get('company', 'N/A')}")
# print(f"  Risk Factors: {len(sec_result.get('risk_factors', []))}")
# print(f"  Products: {len(sec_result.get('products', []))}")
```

== Knowledge Check

What is the primary advantage of using a tool-based architecture for financial intelligence agents?

( ) Faster execution of simple queries
( ) Reduced memory requirements
(x) Modular capabilities that can be combined for complex analysis workflows
( ) Simplified agent implementation

[%collapsible]
.Explanation
====
Tool-based architecture allows agents to have modular capabilities that can be dynamically combined to handle complex, multi-step financial analysis workflows. Each tool specializes in a specific aspect (SEC filing analysis, competitive intelligence, risk assessment) and can be combined in different ways depending on the analysis requirements. This provides flexibility and reusability while maintaining specialized expertise in each domain.
====

== Summary

Financial intelligence agents require sophisticated architecture to handle complex analysis workflows:

### **Core Components:**
* **Agent Identity and Role** - Defines capabilities and specialization areas
* **Planning and Reasoning Engine** - Breaks down complex queries into executable workflows
* **Tool Ecosystem** - Modular tools for specialized financial analysis tasks
* **Memory and Context Management** - Tracks conversations and entity interactions
* **Knowledge Base Integration** - Connects to financial data sources and schemas

### **Key Design Principles:**
* **Modularity** - Tools can be combined for different analysis types
* **Specialization** - Each tool focuses on specific financial domains
* **Flexibility** - Planning engine adapts workflows based on query requirements
* **Traceability** - Track which entities and data sources are used in analysis

### **Financial Applications:**
- Investment research with multi-step company analysis
- Portfolio risk assessment with network effects
- Competitive intelligence and market positioning
- Regulatory compliance monitoring and alerting

Next, we'll explore how agents can perform graph-based reasoning to uncover complex relationships in financial networks.