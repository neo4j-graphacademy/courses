= Dijkstra's Shortest Path
:type: lesson
:order: 2

[.slide]
== What is Pathfinding?

Pathfinding algorithms find routes between nodes in a graph.

They answer questions like:

* What's the **shortest** path between two points?
* What's the **cheapest** route considering costs?
* What are the **alternative** routes if the best one is unavailable?
* How do I **traverse** the entire graph systematically?

Unlike simple pattern matching, pathfinding algorithms consider **weights**, **distances**, and **optimization criteria** to find the best routes through complex networks.

[.slide]
== Pathfinding Algorithms in GDS

GDS provides a comprehensive family of pathfinding algorithms:

[cols="2,3"]
|===
|Algorithm |Use Case

|**Dijkstra Source-Target**
|Shortest path between two nodes

|**Dijkstra Single-Source**
|Shortest paths from one node to all others

|**Yen's Shortest Path**
|K shortest paths (alternatives)

|**A\* Shortest Path**
|Shortest path with heuristic (e.g., geospatial)

|**Delta-Stepping**
|Parallelized single-source shortest paths

|**Bellman-Ford**
|Shortest paths with negative weights

|**Breadth/Depth First Search**
|Systematic graph traversal

|**Minimum Spanning Tree**
|Connect all nodes with minimum total cost

|**Steiner Tree**
|Connect subset of nodes optimally

|**Maximum Flow**
|Maximum throughput through a network
|===

[.slide]
== Dijkstra's and Yen's
In this module, we'll focus on **Dijkstra's** and **Yen's**—the simplest and most-used, respectively.

image::images/dijkstras_yens.png[Illustration: Dijkstra's and Yen's shortest paths on a graph]

[.slide]
== Why Pathfinding?

Global freight forwarding is complex:

* Thousands of possible routes between origin-destination pairs
* Variable transit times due to weather, customs, delays
* Historical routing driven by habit, not data
* Hidden inefficiencies costing millions in transit time

image::images/route_complexity.png[Left: A tangled web of possible routes; Right: The single optimal path highlighted.]

[.transcript-only]
====
These patterns are hard to see in spreadsheets—but graph algorithms find them instantly.
====

[.slide]
== The Business Model

Freight forwarding consolidates shipments:

* **Incoming legs**: Freight collected from source airports
* **Consolidation**: Shipments merged at transfer points
* **Outgoing leg**: Combined freight delivered to destination

**Objective**: Minimize total transit time while efficiently consolidating.

image::images/freight_consolidation.png[Three incoming shipments converging at a transfer point, then departing as one consolidated shipment.]

[.slide]
== The Challenge

With ~68,000 relationships, manual route optimization is impossible.

We need algorithms to:

1. **Find optimal routes** — Identify the fastest path
2. **Compare alternatives** — Rank backup options
3. **Reveal inefficiencies** — Compare to historical choices

[.slide]
== What Dijkstra's Does

Dijkstra's finds the **shortest weighted path** between a source node and one or more target nodes.

It systematically explores the network, always choosing the lowest-cost path forward until reaching the destination.

image::images/dijkstra_exploration.png[Dijkstra's algorithm expanding outward from source, with explored paths and the final optimal route highlighted.]

[.slide]
== The Core Concept: Weighted Paths

Dijkstra's optimizes for **total cost**—the sum of all relationship weights along a path.

* **Low total cost:** Efficient route through the network
* **High total cost:** Inefficient route with unnecessary delays

For movies, "cost" could mean rating difference, year gap, or collaboration strength. For logistics, it typically means time.

[.slide]
== How It Works

Dijkstra's uses a **greedy approach** with a priority queue:

1. Start at the source node with cost 0
2. Add all neighbors to a priority queue, ordered by total cost
3. Pop the lowest-cost node from the queue
4. If it's the target, we're done
5. Otherwise, add its unvisited neighbors to the queue
6. Repeat until target is reached or queue is empty

image::image/djikstras_simple_diagram.png[a simple five window demonstration of djikstra's 6 step process.]

[.slide]
== A Metaphor: Road Trip

Imagine planning a road trip with multiple possible routes.

**Dijkstra's approach:**

* Check all roads from your starting city
* Pick the shortest road to an unvisited city
* From there, check all roads to new cities
* Always expand from wherever gives the lowest total distance

**Result:** The guaranteed shortest route to your destination.

image::images/djikstras_map.png[map visualization of djikstra's process.]

[.slide]
== Why Not Just Use Cypher SHORTEST?

Native Cypher has a `SHORTEST` function.

[source,cypher]
.Cypher shortest
----
MATCH path = SHORTEST 1 (:Actor)-[:ACTED_IN]-+(:Actor)
RETURN path
----

There are a few key differences...

[.slide.col-2]
== Cypher SHORTEST vs Dijkstra's

[.col]
====
**Cypher SHORTEST**:

* Specify complex graph navigation through quantified path patterns
* Faster for simple queries
* Does not account for relationship weights
====

[.col]
====
**Dijkstra's**

* Finds paths with the lowest total cost
* Fast on large graphs
* Considers relationship weights

====

[.slide]
== Graph Structure Requirements

Dijkstra's works on:

* **Directed or undirected** graphs
* **Heterogeneous nodes** — Multiple node labels supported
* **Heterogeneous relationships** — Multiple relationship types supported
* **Weighted relationships** — Required for meaningful results

**Critical:** Weights must be **non-negative**. If your model includes negative values (discounts, refunds, credits), Dijkstra's will silently produce incorrect paths. Use Bellman-Ford for negative weights.


[.slide]
== Key Configuration Parameters

[cols="1,1,2"]
|===
|Parameter |Type |Description

|sourceNode
|Integer
|The source node (required)

|targetNodes
|Integer or List
|One or more target nodes (required)

|relationshipWeightProperty
|String
|Property to use as weights (optional)
|===

[.transcript-only]
====
If `relationshipWeightProperty` is not specified, the algorithm runs unweighted—treating all relationships as having equal cost. This effectively finds the path with fewest hops.
====

[.slide]
== Practice: Project the Movie Graph

Let's find the shortest path between actors through their collaborations. First, project the graph:

[source,cypher]
.Project actor collaborations
----
MATCH (source:Actor)-[:ACTED_IN]->(m:Movie)<-[:ACTED_IN]-(target:Actor)
WHERE source <> target
WITH source, target, count(m) AS collaborations
RETURN gds.graph.project(
  'actor-collaborations',
  source,
  target,
  {relationshipProperties: {collaborations: collaborations}},
  {undirectedRelationshipTypes: ['*']}
)
----

[.transcript-only]
====
This creates an undirected graph where actors are connected if they've appeared in the same movie. The `collaborations` property counts how many movies they've shared.
====

[.slide]
== Practice: Project the Movie Graph (AGA)

In AGA, we use `gds.graph.project()` with a Cypher projection:

[source,python]
----
# Project actor collaborations
G_collab, result = gds.graph.project(
    "actor-collaborations",
    """
    MATCH (source:Actor)-[:ACTED_IN]->(m:Movie)<-[:ACTED_IN]-(target:Actor)
    WHERE source <> target
    WITH source, target, count(m) AS collaborations
    RETURN gds.graph.project.remote(
      source,
      target,
      {relationshipProperties: {collaborations: collaborations}},
      {undirectedRelationshipTypes: ['*']}
    )
    """
)

print(f"Projected graph: {G_collab.name()}")
print(f"  Nodes: {G_collab.node_count():,}")
print(f"  Relationships: {G_collab.relationship_count():,}")
----

[.slide]
== Find the Shortest Path

Now, to find the shortest path between two actors:

[source,cypher]
.Run Dijkstra's
----
MATCH (source:Actor {name: 'Shah Rukh Khan'}),
      (target:Actor {name: 'Lee Jung-jae'})
CALL gds.shortestPath.dijkstra.stream('actor-collaborations', {
    sourceNode: source,
    targetNodes: target
})
YIELD totalCost, nodeIds
RETURN totalCost AS hops,
       [nodeId IN nodeIds | gds.util.asNode(nodeId).name] AS path
----

Without a weight property, this finds the path with fewest hops—the classic "degrees of separation."

[.slide]
== Find the Shortest Path (AGA)

In AGA, we call `gds.shortestPath.dijkstra.stream()` on the graph object:

[source,python]
----
# Get source and target node IDs
nodes = gds.run_cypher("""
    MATCH (source:Actor {name: 'Shah Rukh Khan'}),
          (target:Actor {name: 'Lee Jung-jae'})
    RETURN id(source) AS sourceId, id(target) AS targetId
""")

source_id = nodes['sourceId'].iloc[0]
target_id = nodes['targetId'].iloc[0]

# Run Dijkstra's algorithm
dijkstra_result = gds.shortestPath.dijkstra.stream(
    G_collab,
    sourceNode=source_id,
    targetNode=target_id
)

# Get actor names along the path
path_node_ids = dijkstra_result['nodeIds'].iloc[0]
path_names = gds.run_cypher("""
    UNWIND $nodeIds AS nodeId
    MATCH (n) WHERE id(n) = nodeId
    RETURN n.name AS name
""", params={"nodeIds": list(path_node_ids)})

print(f"Hops: {int(dijkstra_result['totalCost'].iloc[0])}")
print(f"Path: {' → '.join(path_names['name'].tolist())}")
----

[.slide]
== Single Target vs Multiple Targets

Dijkstra's can find paths to **multiple targets** in a single call:

[source,cypher]
.Multiple targets
----
MATCH (source:Actor {name: 'Shah Rukh Khan'}),
      (target1:Actor {name: 'Lee Jung-jae'}),
      (target2:Actor {name: 'Joe Pantoliano'}),
      (target3:Actor {name: 'Keanu Reeves'})
CALL gds.shortestPath.dijkstra.stream('actor-collaborations', {
    sourceNode: source,
    targetNodes: [target1, target2, target3]
})
YIELD targetNode, totalCost, nodeIds
RETURN gds.util.asNode(targetNode).name AS target,
       totalCost AS hops,
       [nodeId IN nodeIds | gds.util.asNode(nodeId).name] AS path
----

This is more efficient than running separate queries for each target.

[.slide]
== Single Target vs Multiple Targets (AGA)

In AGA, pass a list of target node IDs:

[source,python]
----
# Get multiple target node IDs
targets = gds.run_cypher("""
    MATCH (source:Actor {name: 'Shah Rukh Khan'}),
          (target1:Actor {name: 'Lee Jung-jae'}),
          (target2:Actor {name: 'Joe Pantoliano'}),
          (target3:Actor {name: 'Keanu Reeves'})
    RETURN id(source) AS sourceId,
           id(target1) AS t1, id(target2) AS t2, id(target3) AS t3
""")

source_id = targets['sourceId'].iloc[0]
target_ids = [targets['t1'].iloc[0], targets['t2'].iloc[0], targets['t3'].iloc[0]]

# Run Dijkstra's with multiple targets
multi_result = gds.shortestPath.dijkstra.stream(
    G_collab,
    sourceNode=source_id,
    targetNode=target_ids  # Pass list of targets
)

# Display results for each target
for idx, row in multi_result.iterrows():
    target_name = gds.run_cypher("""
        MATCH (n) WHERE id(n) = $nodeId RETURN n.name AS name
    """, params={"nodeId": row['targetNode']})['name'].iloc[0]
    print(f"Target: {target_name}, Hops: {int(row['totalCost'])}")
----

[.slide]
== Dijkstra's Finds the Minimum Cost

We projected collaboration counts to the graph too. Let's add those as a weight and see what happens:

[source,cypher]
.Multiple targets weighted collaborations
----
MATCH (source:Actor {name: 'Shah Rukh Khan'}), (target1:Actor {name: 'Lee Jung-jae'}),
      (target2:Actor {name: 'Joe Pantoliano'}),(target3:Actor {name: 'Keanu Reeves'})
CALL gds.shortestPath.dijkstra.stream('actor-collaborations', {
    sourceNode: source,
    targetNodes: [target1, target2, target3],
    relationshipWeightProperty: 'collaborations'})
YIELD targetNode, totalCost, nodeIds
RETURN gds.util.asNode(targetNode).name AS target,
       totalCost AS hops,
       [nodeId IN nodeIds | gds.util.asNode(nodeId).name] AS path
----

The algorithm is now biased to choose the shortest path between the characters who have collaborated the least.

This happens because Dijkstra's always interprets relationship weights as costs.

[.slide]
== Dijkstra's Finds the Minimum Cost (AGA)

In AGA, add the `relationshipWeightProperty` parameter:

[source,python]
----
# Run Dijkstra's with collaboration weights
weighted_result = gds.shortestPath.dijkstra.stream(
    G_collab,
    sourceNode=source_id,
    targetNode=target_ids,
    relationshipWeightProperty='collaborations'  # Add weight property
)

# Display results
for idx, row in weighted_result.iterrows():
    target_name = gds.run_cypher("""
        MATCH (n) WHERE id(n) = $nodeId RETURN n.name AS name
    """, params={"nodeId": row['targetNode']})['name'].iloc[0]

    path_names = gds.run_cypher("""
        UNWIND $nodeIds AS nodeId
        MATCH (n) WHERE id(n) = nodeId
        RETURN n.name AS name
    """, params={"nodeIds": list(row['nodeIds'])})

    print(f"Target: {target_name}")
    print(f"  Total Cost: {row['totalCost']}")
    print(f"  Path: {' → '.join(path_names['name'].tolist())}")
----

[.slide]
== Collaboration Visualisation No Weights

Check out this query -- it runs Dijkstra's but returns the paths between actors as a graph:

[source,cypher]
.Dijkstra's as graph -- no weights
----
MATCH (source:Actor {name: 'Shah Rukh Khan'}), (target1:Actor {name: 'Lee Jung-jae'}),
      (target2:Actor {name: 'Joe Pantoliano'}), (target3:Actor {name: 'Keanu Reeves'})
CALL gds.shortestPath.dijkstra.stream('actor-collaborations', {
    sourceNode: source, targetNodes: [target1, target2, target3]})
YIELD targetNode, nodeIds
WITH [nodeId IN nodeIds | gds.util.asNode(nodeId)] AS actors
UNWIND range(0, size(actors) - 2) AS i
WITH actors[i] AS a1, actors[i + 1] AS a2
MATCH path = (a1)-[:ACTED_IN]->(m:Movie)<-[:ACTED_IN]-(a2)
RETURN path
----

[.slide]
== Collaboration Visualisation No Weights (AGA)

In AGA, we visualize paths using `neo4j_viz`:

[source,python]
----
from neo4j_viz import Node, Relationship, VisualizationGraph

# Run unweighted Dijkstra's
unweighted_result = gds.shortestPath.dijkstra.stream(
    G_collab, sourceNode=source_id, targetNode=target_ids
)

# Collect all node IDs from all paths
all_node_ids = set()
for idx, row in unweighted_result.iterrows():
    all_node_ids.update(row['nodeIds'])

# Get node details and relationships via movies
node_details = gds.run_cypher("""
    UNWIND $nodeIds AS nodeId
    MATCH (n) WHERE id(n) = nodeId
    RETURN id(n) AS id, n.name AS name
""", params={"nodeIds": list(all_node_ids)})

path_rels = gds.run_cypher("""
    UNWIND $nodeIds AS id1
    UNWIND $nodeIds AS id2
    WITH id1, id2 WHERE id1 < id2
    MATCH (a:Actor)-[:ACTED_IN]->(m:Movie)<-[:ACTED_IN]-(b:Actor)
    WHERE id(a) = id1 AND id(b) = id2
    RETURN id(a) AS source, id(b) AS target, m.title AS movie
""", params={"nodeIds": list(all_node_ids)})

# Build and render visualization
# ... (create nodes and rels lists)
VG = VisualizationGraph(nodes=nodes, relationships=rels)
VG.render()
----

[.slide]
== Collaboration Visualisation Weighted with Collaborations

And now try this one, with the collaboration weights.

Remember, Dijkstra's interprets the 'weight' as 'cost'. The higher the cost, the greater the penalty.

[source,cypher]
.Shortest path with collaboration weights
----
MATCH (source:Actor {name: 'Shah Rukh Khan'}), (target1:Actor {name: 'Lee Jung-jae'}),
      (target2:Actor {name: 'Joe Pantoliano'}), (target3:Actor {name: 'Keanu Reeves'})
CALL gds.shortestPath.dijkstra.stream('actor-collaborations', {
    sourceNode: source, targetNodes: [target1, target2, target3], relationshipWeightProperty: 'collaborations'})
YIELD targetNode, nodeIds
WITH [nodeId IN nodeIds | gds.util.asNode(nodeId)] AS actors
UNWIND range(0, size(actors) - 2) AS i
WITH actors[i] AS a1, actors[i + 1] AS a2
MATCH path = (a1)-[:ACTED_IN]->(m:Movie)<-[:ACTED_IN]-(a2)
RETURN path
----

[.slide]
== Collaboration Visualisation Weighted (AGA)

In AGA, run with weights and visualize the different paths:

[source,python]
----
# Run weighted Dijkstra's
weighted_result = gds.shortestPath.dijkstra.stream(
    G_collab,
    sourceNode=source_id,
    targetNode=target_ids,
    relationshipWeightProperty='collaborations'
)

# Collect all node IDs from weighted paths
all_node_ids = set()
for idx, row in weighted_result.iterrows():
    all_node_ids.update(row['nodeIds'])

# Get relationships with collaboration counts
path_rels = gds.run_cypher("""
    UNWIND $nodeIds AS id1
    UNWIND $nodeIds AS id2
    WITH id1, id2 WHERE id1 < id2
    MATCH (a:Actor)-[:ACTED_IN]->(m:Movie)<-[:ACTED_IN]-(b:Actor)
    WHERE id(a) = id1 AND id(b) = id2
    WITH a, b, collect(m.title)[0] AS movie, count(m) AS collabs
    RETURN id(a) AS source, id(b) AS target, movie, collabs
""", params={"nodeIds": list(all_node_ids)})

# Build visualization with collaboration counts on edges
# ... (create nodes and rels with collab counts as captions)
VG = VisualizationGraph(nodes=nodes, relationships=rels)
VG.render()
----

[.slide]
== Collaboration Strength

What if we want to find the path through the **strongest** collaborations?

We need to invert our thinking: Dijkstra's minimizes cost, but we want to maximize strength.

[.slide]
== Project with Inverted Weighted Paths

Re-project with inverted weights:

[source,cypher]
.Project with inverted weights
----
MATCH (source:Actor)-[:ACTED_IN]->(m:Movie)<-[:ACTED_IN]-(target:Actor)
WHERE source <> target
WITH source, target, count(m) AS collaborations
RETURN gds.graph.project(
  'actor-weighted',
  source,
  target,
  {relationshipProperties: {invertedCollab: 1.0 / collaborations}}, // Inverts the weights
  {undirectedRelationshipTypes: ['*']}
)
----

[.slide]
== Project with Inverted Weighted Paths (AGA)

In AGA, include the inverted weight calculation in the projection:

[source,python]
----
# Project with inverted weights
G_weighted, result = gds.graph.project(
    "actor-weighted",
    """
    MATCH (source:Actor)-[:ACTED_IN]->(m:Movie)<-[:ACTED_IN]-(target:Actor)
    WHERE source <> target
    WITH source, target, count(m) AS collaborations
    RETURN gds.graph.project.remote(
      source,
      target,
      {relationshipProperties: {invertedCollab: 1.0 / collaborations}},
      {undirectedRelationshipTypes: ['*']}
    )
    """
)

print(f"Projected graph: {G_weighted.name()}")
print(f"  Nodes: {G_weighted.node_count():,}")
print(f"  Relationships: {G_weighted.relationship_count():,}")
----

[.slide]
== Weighted Paths

Now, let's run the same query, with our inverted weights and see what happens.

[source,cypher]
.Find strongest collaboration path
----
MATCH (source:Actor {name: 'Shah Rukh Khan'}), (target1:Actor {name: 'Lee Jung-jae'}),
      (target2:Actor {name: 'Joe Pantoliano'}), (target3:Actor {name: 'Keanu Reeves'})
CALL gds.shortestPath.dijkstra.stream('actor-weighted', {
    sourceNode: source,
    targetNodes: [target1, target2, target3],
    relationshipWeightProperty: 'invertedCollab'
})
YIELD totalCost, nodeIds
RETURN [nodeId IN nodeIds | gds.util.asNode(nodeId).name] AS path
----

[.slide]
== Weighted Paths (AGA)

In AGA, run Dijkstra's on the inverted-weight projection:

[source,python]
----
# Find strongest collaboration paths using inverted weights
inverted_result = gds.shortestPath.dijkstra.stream(
    G_weighted,
    sourceNode=source_id,
    targetNode=target_ids,
    relationshipWeightProperty='invertedCollab'
)

# Display results
for idx, row in inverted_result.iterrows():
    path_names = gds.run_cypher("""
        UNWIND $nodeIds AS nodeId
        MATCH (n) WHERE id(n) = nodeId
        RETURN n.name AS name
    """, params={"nodeIds": list(row['nodeIds'])})

    print(f"Path: {' → '.join(path_names['name'].tolist())}")
----

[.slide]
== Visualize Weighted Paths

The previous query returned yet another set of shortest paths. Running the query below will show you the reason.

Along the path, any two connections are the **strongest** collaborators on the shortest path.

[source,cypher]
.Find strongest collaboration path
----
MATCH (source:Actor {name: 'Shah Rukh Khan'}), (target1:Actor {name: 'Lee Jung-jae'}),
      (target2:Actor {name: 'Joe Pantoliano'}), (target3:Actor {name: 'Keanu Reeves'})
CALL gds.shortestPath.dijkstra.stream('actor-weighted', {
    sourceNode: source, targetNodes: [target1, target2, target3], relationshipWeightProperty: 'invertedCollab'})
YIELD targetNode, nodeIds
WITH [nodeId IN nodeIds | gds.util.asNode(nodeId)] AS actors
UNWIND range(0, size(actors) - 2) AS i
WITH actors[i] AS a1, actors[i + 1] AS a2
MATCH path = (a1)-[:ACTED_IN]->(m:Movie)<-[:ACTED_IN]-(a2)
RETURN path
----

[.slide]
== Visualize Weighted Paths (AGA)

In AGA, visualize the strongest collaboration paths:

[source,python]
----
# Collect all node IDs from inverted-weight paths
all_node_ids = set()
for idx, row in inverted_result.iterrows():
    all_node_ids.update(row['nodeIds'])

# Get relationships showing strongest collaborations
path_rels = gds.run_cypher("""
    UNWIND $nodeIds AS id1
    UNWIND $nodeIds AS id2
    WITH id1, id2 WHERE id1 < id2
    MATCH (a:Actor)-[:ACTED_IN]->(m:Movie)<-[:ACTED_IN]-(b:Actor)
    WHERE id(a) = id1 AND id(b) = id2
    WITH a, b, collect(m.title) AS movies, count(m) AS collabs
    RETURN id(a) AS source, id(b) AS target,
           movies[0] AS movie, collabs
""", params={"nodeIds": list(all_node_ids)})

# Build visualization - these paths go through STRONGEST collaborators
# ... (create nodes and rels)
VG = VisualizationGraph(nodes=nodes, relationships=rels)
VG.render()
----

[.slide]
== Write Mode

Write mode persists the path as a new relationship in Neo4j:

[source,cypher,role=noplay]
----
MATCH (source:Actor {name: 'Shah Rukh Khan'}),
      (target:Actor {name: 'Keanu Reeves'})
CALL gds.shortestPath.dijkstra.write('actor-collaborations', {
    sourceNode: source,
    targetNodes: target,
    writeRelationshipType: 'SHORTEST_PATH',
    writeNodeIds: true,
    writeCosts: true
})
YIELD relationshipsWritten
RETURN relationshipsWritten
----

[.slide]
== Write Mode (AGA)

In AGA, use `gds.shortestPath.dijkstra.write()`:

[source,python]
----
# Get Keanu Reeves node ID
keanu_id = gds.run_cypher("""
    MATCH (a:Actor {name: 'Keanu Reeves'})
    RETURN id(a) AS id
""")['id'].iloc[0]

# Write the shortest path as a relationship
write_result = gds.shortestPath.dijkstra.write(
    G_collab,
    sourceNode=source_id,
    targetNode=keanu_id,
    writeRelationshipType='SHORTEST_PATH',
    writeNodeIds=True,
    writeCosts=True
)

print(f"Relationships written: {write_result['relationshipsWritten']}")
----

[.slide]
== Write Mode Configuration

Additional parameters for write mode:

[cols="1,1,2"]
|===
|Parameter |Type |Description

|writeRelationshipType
|String
|Type for the new relationship (required)

|writeNodeIds
|Boolean
|Store intermediate node IDs on relationship

|writeCosts
|Boolean
|Store accumulated costs on relationship
|===

The written relationship connects source directly to target, with path details stored as properties.

[.slide]
== See the Relationship

Check out the relationship we just created:

[source,cypher]
.Shah Rukh Khan to Keanu Reeves
----
MATCH (a:Actor {name: "Shah Rukh Khan"})-[r:SHORTEST_PATH]->(a2:Actor {name: "Keanu Reeves"})
RETURN a.name AS actor1, r.totalCost AS totalCost, r.nodeIds AS nodeIds, r.costs AS costs, a2.name AS actor2
----

[.slide]
== See the Relationship (AGA)

In AGA, query the written relationship:

[source,python]
----
# Query the written relationship
shortest_path_rel = gds.run_cypher("""
    MATCH (a:Actor {name: 'Shah Rukh Khan'})-[r:SHORTEST_PATH]->(a2:Actor {name: 'Keanu Reeves'})
    RETURN a.name AS actor1,
           r.totalCost AS totalCost,
           r.nodeIds AS nodeIds,
           r.costs AS costs,
           a2.name AS actor2
""")

display(shortest_path_rel)
----

[.slide]
== Mutate Mode

Mutate mode adds the path to the **in-memory graph** without writing to Neo4j:

[source,cypher]
----
MATCH (source:Actor {name: 'Tom Hanks'}),
      (target:Actor {name: 'Keanu Reeves'})
CALL gds.shortestPath.dijkstra.mutate('actor-collaborations', {
    sourceNode: source,
    targetNodes: target,
    mutateRelationshipType: 'SHORTEST_PATH'
})
YIELD relationshipsWritten
RETURN relationshipsWritten
----

Useful when chaining multiple algorithms together.

[.transcript-only]
====
The relationship produced is always **directed**, even if the input graph is undirected. This is because a path has a natural direction from source to target.
====

[.slide]
== Mutate Mode (AGA)

In AGA, use `gds.shortestPath.dijkstra.mutate()`:

[source,python]
----
# Get Tom Hanks node ID
tom_id = gds.run_cypher("""
    MATCH (a:Actor {name: 'Tom Hanks'})
    RETURN id(a) AS id
""")['id'].iloc[0]

# Mutate - add path to in-memory graph only
mutate_result = gds.shortestPath.dijkstra.mutate(
    G_collab,
    sourceNode=tom_id,
    targetNode=keanu_id,
    mutateRelationshipType='SHORTEST_PATH'
)

print(f"Relationships added to projection: {mutate_result['relationshipsWritten']}")
----

[.slide]
== Performance Considerations

Dijkstra's is efficient:

* **Time complexity:** O((V + E) log V)
* **Space complexity:** O(V) for the priority queue
* **Single-threaded:** Changing concurrency has no effect

The projection step is typically the bottleneck, not the algorithm itself.

[.slide]
== When Dijkstra's Won't Help

Dijkstra's is **not** the right choice when:

* You need paths with **negative weights** -> Use Bellman-Ford
* You need **all** shortest paths, not just one -> Use All Pairs Shortest Path
* You need **k shortest paths** -> Use Yen's algorithm
* Weights are all equal -> Native Cypher SHORTEST is simpler

[.slide]
== Relationship Type Filtering

You can filter which relationship types to traverse:

[source,cypher]
----
CALL gds.shortestPath.dijkstra.stream('myGraph', {
    sourceNode: source,
    targetNodes: target,
    relationshipTypes: ['ACTED_IN'],
    relationshipWeightProperty: 'cost'
})
----

Only specified relationship types will be considered.

[.slide]
== Relationship Type Filtering (AGA)

In AGA, add `relationshipTypes` parameter:

[source,python]
----
# Filter by relationship types
filtered_result = gds.shortestPath.dijkstra.stream(
    G_collab,
    sourceNode=source_id,
    targetNode=target_id,
    relationshipTypes=['ACTED_IN'],  # Only traverse these types
    relationshipWeightProperty='cost'
)
----

[.slide]
== Node Label Filtering

Similarly, you can filter which nodes are allowed on the path:

[source,cypher]
----
CALL gds.shortestPath.dijkstra.stream('myGraph', {
    sourceNode: source,
    targetNodes: target,
    nodeLabels: ['Actor', 'Director'],
    relationshipWeightProperty: 'cost'
})
----

Only nodes with specified labels will be traversed.

[.slide]
== Node Label Filtering (AGA)

In AGA, add `nodeLabels` parameter:

[source,python]
----
# Filter by node labels
filtered_result = gds.shortestPath.dijkstra.stream(
    G_collab,
    sourceNode=source_id,
    targetNode=target_id,
    nodeLabels=['Actor', 'Director'],  # Only traverse these labels
    relationshipWeightProperty='cost'
)
----

[.slide]
== Clean Up

Drop the practice projections:

[source,cypher]
----
CALL gds.graph.list()
YIELD graphName
CALL gds.graph.drop(graphName)
YIELD graphName as droppedGraphs
RETURN droppedGraphs
----

[.slide]
== Clean Up (AGA)

In AGA, drop projections and delete the session:

[source,python]
----
# Drop all projections
for graph_name in gds.graph.list()["graphName"].tolist():
    gds.graph.drop(graph_name)
    print(f"Dropped: {graph_name}")

# Delete the session when finished
gds.delete()
print("Session deleted - billing stopped")
----

[.slide]
== Common Use Cases

Dijkstra's is widely used for:

* **Logistics** — Finding fastest shipping routes
* **Navigation** — GPS and mapping applications
* **Network routing** — Internet packet delivery
* **Game AI** — Character pathfinding
* **Social networks** — Degrees of separation (like our actor example!)

Any network where you need the optimal weighted path is a candidate.

[.slide]
== Dijkstra's vs Other Pathfinding

[cols="1,2,2"]
|===
|Algorithm |Finds |Use When

|**Dijkstra's**
|Single shortest path
|You need one optimal route

|**Yen's**
|K shortest paths
|You need alternatives

|**A***
|Single shortest path
|You have a heuristic (e.g., geographic distance)

|**Bellman-Ford**
|Single shortest path
|You have negative weights
|===

[.slide]
== Transfer: From Movies to Logistics

You've now learned Dijkstra's on the Movie graph:

* **Actors** -> **Locations** (airports, warehouses)
* **Collaboration strength** -> **Transit time**
* **Degrees of separation** -> **Optimal route**

In the next lesson, you'll apply this to the logistics network—finding optimal shipping routes and comparing them to historical operations.

[.summary]
== Summary

Dijkstra's finds the optimal weighted path by systematically exploring from source to destination using a priority queue.

Key points:

* **Minimizes total cost** (sum of weights), not hop count
* **Requires non-negative weights** — Negative weights cause errors
* **Single-threaded** — Concurrency setting has no effect
* **Multiple targets** — Can find paths to several destinations in one call
* **Three execution modes** — Stream, mutate, and write

In the next lesson, you'll apply Dijkstra's to the logistics network to find optimal shipping routes.
