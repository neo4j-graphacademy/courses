= Workshop Summary
:pdf-summary:

Congratulations on completing the **Graph Data Science in Practice** workshop!

In just 4 hours, you've learned how to apply graph algorithms to solve real-world business problems.

== GDS Foundations

You've mastered the fundamentals:

* The GDS Project → Run → Write workflow
* How to create monopartite and bipartite graph projections tailored to analytical questions
* How to run algorithms in stream, stats, mutate, and write modes
* How to configure projections for different analytical scenarios

== Community Detection for Fraud

You now know how to:

* Apply Louvain community detection to find densely connected groups
* Use Weakly Connected Components (WCC) for deterministic community assignment
* Apply Degree Centrality to filter high-connection nodes
* Identify fraud rings by encoding domain hypotheses as graph relationships
* Reduce search space by 98% while uncovering hidden fraud networks

== Python GDS Client

You've learned to:

* Connect to Neo4j and run GDS algorithms programmatically with Python
* Work with algorithm results as pandas DataFrames
* Apply PageRank and Betweenness Centrality to rank influential papers in citation networks
* Run Louvain to detect research communities
* Generate FastRP node embeddings for machine learning pipelines
* Build complete end-to-end analytics workflows

== Aura Graph Analytics

You can now:

* Create and manage ephemeral GDS Sessions for scalable analytics
* Run Dijkstra's shortest path algorithm for route optimization
* Use Yen's k-shortest paths to find alternative routes
* Compare historical routes against optimal paths for logistics optimization
* Scale GDS workloads without impacting production databases

== Pro Tips

=== Choosing the Right Algorithm

* Use **Louvain** when you need hierarchical communities and can tolerate non-deterministic results
* Use **WCC** when you need deterministic, explainable community assignments
* Use **PageRank** for ranking by incoming connections (citations, links, references)
* Use **Betweenness Centrality** to find nodes that bridge different parts of the network
* Use **FastRP** to create node embeddings for machine learning models

=== Performance Optimization

* Start with stream mode during exploration, then use write mode for production
* Use native projections when possible for better performance
* Filter your graph projections to include only relevant nodes and relationships
* Consider Aura Graph Analytics for large-scale workloads

=== Production Workflows

* Use the Python GDS client for automated, repeatable analytics pipelines
* Encode domain knowledge as graph relationships for more targeted analysis
* Always validate algorithm results against business context
* Document your projection and algorithm configurations for reproducibility

== Ready for your next challenge?

Ready to dive deeper into Graph Data Science?

**Online Courses:**

* link:/courses/gds-fundamentals/[Graph Data Science Fundamentals^] - Comprehensive coverage of all GDS concepts (3-4 hours)
* link:/courses/gds-applied-algorithms/[Applied Algorithms in GDS^] - Five industry use cases with deep algorithm coverage (8-10 hours)

**Related Topics:**

* link:/courses/cypher-fundamentals/[Cypher Fundamentals^] - Master the query language
* link:/courses/modeling-fundamentals/[Graph Data Modeling Fundamentals^] - Design effective graph structures

== Want to Learn More?

**Community & Resources:**

* link:https://neo4j.com/docs/graph-data-science/current/[GDS Documentation^] - Complete algorithm reference
* link:https://community.neo4j.com/[Neo4j Community Forum^] - Connect with other practitioners
* link:https://neo4j.com/developer/graph-data-science/[GDS Developer Guide^] - Practical examples and tutorials

Create a free link:https://console.neo4j.io[Neo4j AuraDB instance^] or download link:https://neo4j.com/download/[Neo4j Desktop^] to continue practicing with your own data.

include::{shared}/resources.adoc[]
