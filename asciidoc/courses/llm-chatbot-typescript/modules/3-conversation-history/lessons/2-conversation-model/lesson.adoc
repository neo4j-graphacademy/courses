= The Conversation Model
:type: lesson
:order: 2

Before going any further, it is worth pausing to think about how we will store the conversation history in the graph.

The chatbot will use two methods to retrieve information from the graph, but both need to store memory consistently.
As the particular implementation may change based on the data retrieval method, the chains themselves will be responsible for persisting the memory, keeping the logic close to the chain.


Let's walk through an example conversation with a user asking for a recommendation.

// TODO: Image>

* **Human:** Can you recommend a movie about robots?
* **AI:** Sure, _iRobot_ is a 2004 sci-fi film where a homicide detective with a distrust of robots investigates a homicide with the help of a robopsychologist.
* **Human:** That doesn’t sound very age-appropriate. Can you recommend a film suitable for children?
* **AI:** Oh, sorry. _WALL-E_  is a 2008 animated film where a waste-cleaning robot falls in love and saves the world.  It has a 4.2-star rating.
* **Human:** That sounds interesting, tell me more…
* **AI:** The film is a _Disney Pixar_ production directed by _Andrew Stanton_.  _Ben Burtt_ voices WALL-E, while __Jeff Garlin__ plays Captain B. McCrea.

== Retrieval Tool

When the human asks for a recommendation based on its plot, the chatbot will embed the rephrased question and search the vector index for similar embeddings.
The text associated with those embeddings will be appended to the prompt, allowing the LLM to use the information to generate a natural language answer.

At the same time, the chain will be responsible for creating a `:CONTEXT` relationship from the `(:Response)` node to the node that contains the embedding.

image::images/retrieval-model.png[The Retrieval Conversation History Data Model]

// [%collapsible]
// .Retrieval History Cypher Statement
// ====

// The following statement will:

// 1. Find or create the user's session
// 2. Create a new `(:Response)` node with properties
// 3. If it exists, remove any existing `:LAST_RESPONSE` relationship from the session
// 4. Use the `last` node in the chain to create a `:NEXT` relationship to the newly created node
// 5. Create a `:LAST_RESPONSE` relationship from the session to the new Response node
// 6. Create `:CONTEXT` relationships to any element IDs used in the response


// [source,cypher]
// .Save Conversation History
// ----
// include::{repository-raw}/main/cypher/save-response.cypher[]
// ----
// ====


== Cypher Tool

As the human asks more complex questions, the chatbot must fall back to the Cypher tool, which will generate and execute a Cypher statement capable of answering the rephrased question.

image::images/cypher-model.png[The Cypher Conversation History Data Model]

The Cypher generation prompt must include instructions to return the `elementId` of the node along with any relevant properties.
This will provide the chain with the information needed to create the `:CONTEXT` relationship, which, in turn, will provide additional clarity on the response.

The `(:Response)` node should also store the generated Cypher statement.

Note also the addition of the `.cypher` property on the `(: Response)`, which will clarify the Cypher statement used to query the database.

// [%collapsible]
// .Cypher Tool Cypher Statement
// ====

// The following statement will:

// 1. Find or create the user's session
// 2. Create a new `(:Response)` node with properties
// 3. If it exists, remove any existing `:LAST_RESPONSE` relationship from the session
// 4. Use the `last` node in the chain to create a `:NEXT` relationship to the newly created node
// 5. Create a `:LAST_RESPONSE` relationship from the session to the new Response node
// 6. Create `:CONTEXT` relationships to any element IDs used in the response

// // TODO: Combine these - save-response.cypher
// [source,cypher]
// ----
// include::{repository-raw}/main/cypher/save-response.cypher[]
// ----
// ====

== Saving the conversation history

The chatbot must create a `(:Response)` node that contains the original input, the rephrased question, and the output from the LLM.

As **users** receive one or more **responses** within a **session**, this forms a natural hierarchy of `(:Session)` nodes, each containing relationships to many `(:Response)` nodes.

// // TODO: diagram
// [source,cypher,rel=norun]
// ----
// (:User)-[:HAS_SESSION]->(:Session {id: uuid})-[:HAS_RESPONSE]->(:Response)
// ----

Regardless of which chain creates it, the `(:Response)` node should hold the following properties:

* `.createdAt` - The creation date of the node
* `.input` - The original input that comes from the user
* `.rephrasedQuestion` - The standalone question rephrased by the LLM using the conversation history
* `.output` - The output subsequently generated by the LLM following the RAG stage


=== Creating a Response Chain

Creating a chain of `:NEXT` relationships between responses will provide an optimal way to find the conversation history.

When adding a new response, the chatbot must create an additional `:LAST_RESPONSE` relationship from the `(:Session)` node. This relationship offers a shortcut to locate the latest response in the session, from which one can follow the `:NEXT` relationship to trace the recent response history.


Using the `:LAST_RESPONSE` relationship to obtian recent message history will be more performant than collecting all responses in memory and ordering by the `.createdAt` timestamp.
From there, you will follow the path of  `:NEXT` relationships in a variable-length traversal to obtain a list of previous messages.

This `:LAST_RESPONSE` pointer will need to be actively maintained, removing any old relationships before creating a new one to ensure the pointer always points to the latest response.

image::images/response-chain.png[Modelling a sequence of responses]


[TIP]
.Modeling Decisions
====
You can learn more about modeling nodes and relationships in the link:/courses/modeling-fundamentals/[Graph Data Modelling Fundamentals course^].
====

== Saving responses

You will use the following Cypher statement to save conversation history to the database.


[source,cypher]
----
include::{repository-raw}/main/cypher/save-response.cypher[]
----

The statement performs the following actions:

1. Find or create the user's session
2. Create a new `(:Response)` node with properties
3. If it exists, remove any existing `:LAST_RESPONSE` relationship from the session
4. Use the `last` node in the chain to create a `:NEXT` relationship to the newly created node
5. Create a `:LAST_RESPONSE` relationship from the session to the new Response node
6. Create `:CONTEXT` relationships to any element IDs used in the response


== Rephasing Questions

In the next lesson, you will build a chain that utilizes the conversation history to rephrase a question into a standalone question.


== Check Your Understanding

include::questions/1-context.adoc[leveloffset=+1]
include::questions/2-next.adoc[leveloffset=+1]
include::questions/3-last-response.adoc[leveloffset=+1]

[.summary]
== Summary

In this lesson, we explored the data model you will use to store conversation history in the graph.

In the next lesson, you will create a `Neo4jGraph` object for interacting with Neo4j.
