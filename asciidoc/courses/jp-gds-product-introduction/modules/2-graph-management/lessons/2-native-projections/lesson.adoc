= ネイティブプロジェクション
:type: quiz

// [.video]
// video::xxxx[youtube,width=560,height=315]


[.transcript]
== はじめに
前回のレッスンでは、グラフカタログについて学びました。そこではグラフプロジェクションについて簡単に紹介しましたが、あまり深く掘り下げて説明することはありませんでした。グラフプロジェクションを理解することは、GDSで成功するための基礎となります。次の2つのレッスンでより詳細に説明します。

GDSのプロジェクションには、**ネイティブプロジェクション**と**Cypherプロジェクション**という2つの主要なタイプがあります。要約すると、ネイティブ・プロジェクションは、効率とパフォーマンスを最適化し、大規模なグラフ・データ・サイエンスをサポートします。Cypherプロジェクションは、柔軟性とカスタマイズ性に最適化されており、探索的分析、実験、および小規模なグラフ・プロジェクションをサポートします。

このレッスンでは、ネイティブプロジェクションとは何か、どのように使用するのかについて、具体的に説明します。次のレッスンでは、Cypherプロジェクションについても同じように説明します。

=== ネイティブプロジェクションについて

前回のレッスンでは、実際にネイティブプロジェクションを使いました。  gds.graph.project()` を呼び出すと、ネイティブプロジェクションを使用していることになります。  ネイティブプロジェクションは、Neo4jのストアファイルから直接読み込むことで、最高のパフォーマンスを発揮します。開発段階でも運用段階でも、ネイティブプロジェクションを使うことをお勧めします。


ネイティブプロジェクションは、ノードやリレーションシップの要素をデータベースからそのままプロジェクションするだけでなく、さまざまな機能を備えています。  以下はその主なものです。:

* ノードとリレーションシップのプロパティを数値で表現
* リレーションシップの方向性の変更
* 並列リレーションシップの集約

これらのオプションは、さまざまなタイプの分析ワークフローやアルゴリズムに対応するプロジェクションの準備するのに役立ちます。

以下では、ネイティブプロジェクションの基本的な構文について説明し、一般的な設定方法を紹介します。

=== 基本構文

ネイティブプロジェクションは3つの必須引数:caption：`graphName` , `nodeProjection`, `relationshipProjection` の3つの引数を取る。さらに、オプションの `configuration` パラメータで、グラフの作成方法をさらに設定することができる。


[opts="header",cols="1,1,1, 4"]
|===
| Name                  | Type                | Optional | Description
| graphName             | String              | no       | グラフがカタログに保存されるときの名前
| nodeProjection        | String, List or Map | no       | ノードをプロジェクションするための設定
| relationshipProjection| String, List or Map | no       | リレーションシップをプロジェクションするための設定
| configuration         | Map                 | yes      | ネイティブプロジェクションを設定するための追加パラメータ
|===

`nodeProjection` と `relationshipProjection` には複数の異なるオプションがあります。  基本的なことを紹介するために、ユースケースごとに説明するのが便利です。

=== 基本的なネイティブプロジェクション
まず、ノードとリレーションシップをプロパティなしでそのまま投影するという、非常に基本的なシナリオを考えてみましょう。ノードラベルとリレーションシップの両方を含めるには、リストのようなシンタックスを使用することができます。以下の例では、`User` と `Movie` のノードを `RATED` というリレーションシップで投影しています。  このような投影は、暗黙の協調フィルタリング（メモリベースの推薦手法）のバリエーションをサポートするため、グラフデータサイエンスに基づく推薦システムには非常に一般的です。

[source,cypher,role=nocopy]
----
CALL gds.graph.project('native-proj',['User', 'Movie'], ['RATED']);
----

また、様々な省略記法があります。 例えば、ノードラベルやリレーションシップの種類を1つだけ含める場合は、1つの文字列の値だけを使用することができます。例えば、 `relationshipProjection` に `RATED` という値を入力するだけで、同等のプロジェクションを得ることができます。

[source, cypher,role=nocopy]
----
CALL gds.graph.project('native-proj',['User', 'Movie'], 'RATED');
----


[NOTE]
.A graph with name 'native-proj' already exists.
====
もし、既に存在する名前で新しいグラフ投影を作成しようとすると、エラーが発生します。
続行するには、まず `gds.graph.drop()` プロシージャを実行して、既存のグラフプロジェクションを削除する必要があります。

.グラフの削除
[source,cypher]
----
CALL gds.graph.drop('native-proj');
----
====

ワイルドカード文字 `*` を使用すると、データベース内のすべてのノードやリレーションシップを含めることができます。以下は、すべてのノードとリレーションシップを投影します。

[source, cypher,role=nocopy]
----
CALL gds.graph.project('native-proj','*', '*');
----

=== リレーションシップの志向を変える

ネイティブプロジェクションでは、リレーションシップの向きも変更することができます。リレーションシップの向きと、それを変更する理由を説明するために、有向リレーションシップと無向リレーションシップの違いを説明する必要があります。

有向リレーションシップは、非対称です。下の画像に示すように、ソース・ノードからターゲット・ノードに向かう関係である。  このタイプの関係には、重み付けや強度インジケータなど、追加の修飾プロパティが含まれる場合があります。

image::images/directed-relationship.png[title="Directed Relationship",400]

無向関係は、方向性を持たない対称的な関係で、ソースとターゲットを持つ代わりに、単に2つのノード間に存在します。

image::images/undirected-relationship.png[title="Undirected Relationship",400]

neo4j データベースのすべてのリレーション湿布は、設計上、有向です。しかし、いくつかのグラフアルゴリズムは、無向性の関係で動作するように設計されています。他のアルゴリズムは有向ですが、我々が望む分析を得るために、データベース内の関係の方向を逆にする必要があるかもしれません。

これに対応するために、`relationshipProjection`のリレーションシップタイプに適用できる3つのオリエンテーションオプションが用意されています:

* `NATURAL`: データベースと同じ方向(デフォルト)
* `REVERSE`: データベースの方向と反対方向
* `UNDIRECTED`: 無指向性

先ほどプロジェクションしたグラフを例にとってみましょう。  例えば、各映画のユーザー評価の数を数えたい場合を考えてみましょう。  前回のレッスンでやったように次数の呼び出しを使おうとすると、すべてゼロになります。

[source, cypher]
----
CALL gds.graph.drop('native-proj', false);
CALL gds.graph.project('native-proj',['User', 'Movie'], ['RATED']);
CALL gds.degree.mutate('native-proj', {mutateProperty: 'ratingCount'});
----

[source, cypher]
----
CALL gds.graph.streamNodeProperty('native-proj','ratingCount', ['Movie'])
YIELD nodeId, propertyValue
RETURN gds.util.asNode(nodeId).title AS movieTitle, propertyValue AS ratingCount
ORDER BY movieTitle DESCENDING LIMIT 10
----

[options="header"]
|==================================================
| movieTitle                          | ratingCount
| İtirazım Var                        | 0.0
| À nous la liberté (Freedom for Us)  | 0.0
| ¡Three Amigos!                      | 0.0
| xXx: State of the Union             | 0.0
| xXx                                 | 0.0
|==================================================

これはリレーションシップの方向と関係があります。このグラフを削除して、`RATED`リレーションシップの方向を逆にした新しいグラフをプロジェクションしてみましょう。

[source, cypher]
----
CALL gds.graph.drop('native-proj', false);

//replace with a project that has reversed relationship orientation
CALL gds.graph.project(
    'native-proj',
    ['User', 'Movie'],
    {RATED_BY: {type: 'RATED', orientation: 'REVERSE'}}
);

CALL gds.degree.mutate('native-proj', {mutateProperty: 'ratingCount'});
----

これで、次数アルゴリズムを使うと、必要な視聴率カウントを得ることができます。

[source, cypher]
----
CALL gds.graph.streamNodeProperty('native-proj','ratingCount', ['Movie'])
YIELD nodeId, propertyValue
RETURN gds.util.asNode(nodeId).title AS movieTitle, propertyValue AS ratingCount
ORDER BY movieTitle DESCENDING LIMIT 5
----

[options="header"]
|==================================================
| movieTitle                          | ratingCount
| İtirazım Var                        | 1.0
| À nous la liberté (Freedom for Us)  | 1.0
| ¡Three Amigos!                      | 31.0
| xXx: State of the Union             | 1.0
| xXx                                 | 23.0
|==================================================



=== ノードとリレーションシップのプロパティを含める

ノードとリレーションシップの特性は、グラフ分析において考慮することが有用です。これらはグラフアルゴリズムにおける重みとして、また機械学習における特徴として使用することができます。

以下は、複数の映画のノードプロパティと、`rating`というリレーションシップ・プロパティを含む例です。

[source,cypher]
----
CALL gds.graph.drop('native-proj', false);

CALL gds.graph.project(
    'native-proj',
    ['User', 'Movie'],
    {RATED: {orientation: 'UNDIRECTED'}},
    {
        nodeProperties:{
            revenue: {defaultValue: 0}, // <1>
            budget: {defaultValue: 0},
            runtime: {defaultValue: 0}
        },
        relationshipProperties: ['rating'] // <3>
    }
);
----

**備考:**

1. `defaultValue` パラメータを使用すると、欠損値をデフォルト値で埋めることができます。  この場合、`0`を使用する。
2. データモデルによると、欠損値があってはならないので、デフォルト値なしでよりシンプルな構文にする。


We will go over how to leverage properties like these in more detail in the Neo4j Graph Data Science Fundamentals course. There are a variety of different options for setting defaults and for alternative configurations, such as setting properties for all node labels and relationship types instead for doing so for each one separately.  Please refer to the https://neo4j.com/docs/graph-data-science/current/graph-project/#graph-project-native-syntax[documentation^] if you want more details on these.

=== Parallel Relationship Aggregations

The Neo4j database allows you to store multiple relationships of the same type and direction between two nodes.  These are colloquially known as _parallel_ relationships. For example, consider a graph of financial transaction data where users send money to one another.  If a user sends money to the same user multiple times this can form multiple parallel relationships.

image::images/parallell-relationships.png[title="Nodes with Parallel Relationships",600]

Sometimes you will want to aggregate these parallel relationships into a single relationship in preparation for running graph algorithms or machine learning. This is because graph algorithms may count each relationship between two nodes separately when all we need to consider is whether a single relationship exists between them. Other times we may want to weight the connection between two nodes higher if more parallel relationships exists, but it's not always easy to do so without aggregating the relationships first depending on which algorithm you use.

Native projections allow for this aggregation. When you conduct relationship aggregation you can generate aggregate statics too, such as parallel relationship counts or sums or averages of relationship properties which can then be used as weights. Below is an example of aggregating relationships without any properties

[source, cypher, role=noplay]
----
CALL gds.graph.project(
  'user-proj',
  ['User'],
  {
    SENT_MONEY_TO: { aggregation: 'SINGLE' }
  }
);
----
image::images/parallell-rels-agg-1.png[title="Aggregate the SENT_MONEY_TO Realtionship With no Properties",800]

We can create a property with the count of the relationships as well - like so:

[source, cypher, role=noplay]
----
CALL gds.graph.project(
  'user-proj',
  ['User'],
  {
    SENT_MONEY_TO: {
      properties: {
        numberOfTransactions: {
          // the wildcard '*' is a placeholder, signaling that
          // the value of the relationship property is derived
          // and not based on Neo4j property.
          property: '*',
          aggregation: 'COUNT'
        }
      }
    }
  }
);
----
image::images/parallell-rels-agg-2.png[title="Aggregate the SENT_MONEY_TO Realtionship With a Trancastion Count",800]
We can also take the sum, min or max of relationship properties during aggregation.  Below is an example with sum.

[source, cypher, role=noplay]
----
CALL gds.graph.project(
  'user-proj',
  ['User'],
  {
    SENT_MONEY_TO: {
      properties: {
        totalAmount: {
          property: 'amount',
          aggregation: 'SUM'
        }
      }
    }
  }
);
----


image::images/parallell-rels-agg-3.png[title="Aggregate the SENT_MONEY_TO Realtionship With a Property Sum",800]


=== Other Native Projection Configuration and Features

We covered the basics here but there are actually many extended syntax and configuration options available for native projections which are detailed in the https://neo4j.com/docs/graph-data-science/current/graph-project/#graph-project-native-syntax[documentation^].  In general, if you are trying to do something in native projection and can't quite express the thing you want with the current syntax, check the docs to see if there are additional configurations or syntax extensions to support.

== 理解度チェック

include::questions/1-graph-native-projection.adoc[leveloffset=+1]

include::questions/2-native-projection-use-cases.adoc[leveloffset=+1]


[.summary]
== まとめ
In this lesson we went over native projections, the primary graph projection mechanism in GDS.  Native Projections are optimized for efficiency and performance to support graph data science at scale.  Native projections have a rich syntax and set of configuration options that allow you to

. filter the graph by node label and relationship types
. include node and relationship properties
. alter relationship orientation
. aggregate parallel relationships

In the next lesson you will be challenged to run a Native Projection against your Neo4j Sandbox.