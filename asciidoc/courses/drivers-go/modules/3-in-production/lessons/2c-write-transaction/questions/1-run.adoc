[.question.select-in-source]
= Read transactions

Select the correct function to execute the Cypher statement in a read transaction and stream the results to the client as soon as they are available.


[source,go,role=nocopy noplay]
----
import (
    "api"
    "log"
)

session := driver.NewSession(ctx, neo4j.SessionConfig{})
defer session.Close(ctx)

res, err := session./*select:ExecuteRead*/(
    ctx,
    func(tx neo4j.ManagedTransaction) (any, error) {
        return getCheapestFlights(tx, "2024-01-01", "LAX", "SFO")
    },
)

if err != nil {
    log.Fatal(err)
}

flights := res.([]any)
for _, row := range flights {
    sendToUI(row)
}

----

- [ ] Run(
- [x] ExecuteRead(
- [ ] ExecuteWrite(
- [ ] ReadAsync(

[TIP,role=hint]
.Hint
====
When reading data from Neo4j, use `ExecuteRead()` to run a read transaction. This ensures that the transaction is properly managed and allows for streaming results back to the client.
====

[TIP,role=solution]
.Solution
====
The correct answer is `ExecuteRead()`.

`ExecuteRead()` is the recommended method for running read transactions in Neo4j. 
The function handles transaction management automatically and allows for streaming results as they become available.

[source,go]
----
session := driver.NewSession(ctx, neo4j.SessionConfig{})
defer session.Close(ctx)

res, err := session.ExecuteRead(
    ctx,
    func(tx neo4j.ManagedTransaction) (any, error) {
        return getCheapestFlights(tx, "2024-01-01", "LAX", "SFO")
    },
)

if err != nil {
    log.Fatal(err)
}

flights := res.([]any)
for _, row := range flights {
    sendToUI(row)
}
----

The other options are incorrect because:

- `Run()` is not a method on the session object
- `ExecuteWrite()` is for write transactions only
- `ReadAsync()` is not a valid method for the session object
====
