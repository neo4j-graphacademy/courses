# Executing Cypher statements

## Introduction

You can use the `neo4j.ExecuteQuery()` function to run one-off Cypher statements or statements that return a small number of records.
This function fetches a list of records and loads them into memory.

```go
cypher := `
MATCH (p:Person {name: $name})-[r:ACTED_IN]->(m:Movie) 
RETURN m.title AS title, r.role AS role
`
name := "Tom Hanks"

result, err := neo4j.ExecuteQuery(ctx, driver, // The function returns a result object and an error.
    cypher,    // The function expects a Cypher statement as a string as the first argument.
    map[string]any{"name": name}, // Parameters are passed as a map with string keys and any values.
    neo4j.EagerResultTransformer, // The result transformer determines how results are processed.
)
```

**Using Parameters**: It is good practice to use parameters in your queries to avoid malicious code being injected into your Cypher statement.

## Handling the Result

The `neo4j.ExecuteQuery()` function returns a result object containing:

1. A slice of `Record` objects
2. Summary information about the query execution
3. Keys specified in the `RETURN` clause

```go
fmt.Println(result.Keys)  // [title role]
fmt.Println(result.Summary)  // A summary of the query execution
```

## Accessing results

Each row returned by the query is a `Record` object. The `Record` object provides access to the data returned by the query.

You can access any item in the `RETURN` clause using the `Get()` method.

```go
// RETURN m.title AS title, r.role AS role

for _, record := range result.Records {
    title, _ := record.Get("title")  // Toy Story
    role, _ := record.Get("role")    // "Woody"
    fmt.Printf("%s played %s\n", title, role)
}
```

## Transforming results

The `ExecuteQuery()` method accepts a result transformer that allows you to transform the result into an alternative format.

Rather than returning the standard result, the query will return the output of the transformer function.

```go
result, err := neo4j.ExecuteQuery(ctx, driver,
    cypher,
    map[string]any{"name": name},
    func(result neo4j.ResultWithContext) (any, error) {
        var movies []string
        for _, record := range result.Records {
            title, _ := record.Get("title")
            role, _ := record.Get("role")
            movies = append(movies, fmt.Sprintf("Tom Hanks played %s in %s", role, title))
        }
        return movies, nil
    },
)

fmt.Println(result)  // ["Tom Hanks played Woody in Toy Story", ...]
```

## Working with DataFrames

The Go driver doesn't have built-in DataFrame support like Python, but you can easily transform results into structured data:

```go
type MovieRole struct {
    Title string `json:"title"`
    Role  string `json:"role"`
}

result, err := neo4j.ExecuteQuery(ctx, driver,
    cypher,
    map[string]any{"name": name},
    func(result neo4j.ResultWithContext) (any, error) {
        var movies []MovieRole
        for _, record := range result.Records {
            title, _ := record.Get("title")
            role, _ := record.Get("role")
            movies = append(movies, MovieRole{
                Title: title.(string),
                Role:  role.(string),
            })
        }
        return movies, nil
    },
)
```

## Reading and writing

By default, `neo4j.ExecuteQuery()` runs in **WRITE** mode. In a clustered environment, this sends all queries to the cluster leader, putting unnecessary load on the leader.

When you're only reading data, you can optimize performance by setting the routing control to READ mode.
This distributes your read queries across all cluster members.

```go
result, err := neo4j.ExecuteQuery(ctx, driver,
    cypher,
    map[string]any{"name": name},
    neo4j.EagerResultTransformer,
    neo4j.ExecuteQueryWithRoutingControl(neo4j.ReadRouting), // <1>
)
```

You can also use `neo4j.WriteRouting` for write mode.

## Summary

In this lesson, you learned how to execute one-off Cypher statements using the `ExecuteQuery()` method and access the results.

The Go driver provides flexible result transformation and routing control for optimal performance.
