# Executing Cypher Statements

Learn how to execute Cypher queries, handle parameters, process results, and optimize performance with routing.

## Basic Query Execution

```go
import (
    "context"
    "fmt"
    "github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

// Execute parameterized queries safely
func executeParameterizedQuery(ctx context.Context, driver neo4j.Driver) {
    cypher := `
    MATCH (p:Person {name: $name})-[r:ACTED_IN]->(m:Movie) 
    RETURN m.title AS title, r.role AS role
    `
    
    result, err := neo4j.ExecuteQuery(ctx, driver,
        cypher,                                    // Cypher query string
        map[string]any{"name": "Tom Hanks"},      // Parameters (always use for security)
        neo4j.EagerResultTransformer,             // Result transformer
    )
    if err != nil {
        panic(err)
    }

    // Process results
    for _, record := range result.Records {
        title, _ := record.Get("title")
        role, _ := record.Get("role")
        fmt.Printf("%s played %s in %s\n", "Tom Hanks", role, title)
    }
}
```

## Understanding Query Results

```go
// Explore the ResultWithContext structure
func exploreResults(ctx context.Context, driver neo4j.Driver) {
    result, err := neo4j.ExecuteQuery(ctx, driver,
        "MATCH (p:Person) RETURN p.name AS name, p.born AS born LIMIT 5",
        nil,
        neo4j.EagerResultTransformer,
    )
    if err != nil {
        panic(err)
    }

    // Result components
    fmt.Printf("Keys: %v\n", result.Keys)           // Column names: [name born]
    fmt.Printf("Record count: %d\n", len(result.Records)) // Number of rows
    fmt.Printf("Summary: %v\n", result.Summary)     // Query execution metadata
    
    // Access individual records
    for i, record := range result.Records {
        name, _ := record.Get("name")
        born, _ := record.Get("born")
        fmt.Printf("Record %d: %s (born %v)\n", i, name, born)
    }
}
```

## Custom Result Transformers

```go
// Transform results into custom data structures
type MovieRole struct {
    Actor string `json:"actor"`
    Movie string `json:"movie"`
    Role  string `json:"role"`
}

func customTransformer(ctx context.Context, driver neo4j.Driver) {
    // Custom transformer that returns structured data
    result, err := neo4j.ExecuteQuery(ctx, driver,
        "MATCH (p:Person)-[r:ACTED_IN]->(m:Movie) RETURN p.name, m.title, r.role LIMIT 10",
        nil,
        func(result neo4j.ResultWithContext) (any, error) {
            var roles []MovieRole
            for _, record := range result.Records {
                actor, _ := record.Get("p.name")
                movie, _ := record.Get("m.title")
                role, _ := record.Get("r.role")
                
                roles = append(roles, MovieRole{
                    Actor: actor.(string),
                    Movie: movie.(string),
                    Role:  role.(string),
                })
            }
            return roles, nil
        },
    )
    if err != nil {
        panic(err)
    }
    
    // Result is now []MovieRole instead of standard ResultWithContext
    roles := result.([]MovieRole)
    for _, role := range roles {
        fmt.Printf("%s played %s in %s\n", role.Actor, role.Role, role.Movie)
    }
}
```

## Database Routing and Performance

```go
// Optimize performance with read/write routing
func optimizedQueries(ctx context.Context, driver neo4j.Driver) {
    // Read queries - distribute across cluster members
    readResult, err := neo4j.ExecuteQuery(ctx, driver,
        "MATCH (p:Person) RETURN p.name LIMIT 10",
        nil,
        neo4j.EagerResultTransformer,
        neo4j.ExecuteQueryWithReadersRouting(), // Route to read replicas
    )
    if err != nil {
        panic(err)
    }
    
    // Write queries - send to cluster leader (default behavior)
    writeResult, err := neo4j.ExecuteQuery(ctx, driver,
        "CREATE (p:Person {name: $name}) RETURN p",
        map[string]any{"name": "Alice"},
        neo4j.EagerResultTransformer,
        neo4j.ExecuteQueryWithWritersRouting(), // Explicit write routing
    )
    if err != nil {
        panic(err)
    }
    
    fmt.Printf("Read %d records, created %d records\n", 
        len(readResult.Records), len(writeResult.Records))
}
```

## Multi-Database Support

```go
// Target specific databases in multi-database setups
func multiDatabaseQueries(ctx context.Context, driver neo4j.Driver) {
    // Query the main database
    mainResult, err := neo4j.ExecuteQuery(ctx, driver,
        "MATCH (n) RETURN count(n) AS count",
        nil,
        neo4j.EagerResultTransformer,
        neo4j.ExecuteQueryWithDatabase("neo4j"), // Target main database
    )
    
    // Query analytics database
    analyticsResult, err := neo4j.ExecuteQuery(ctx, driver,
        "MATCH (n) RETURN count(n) AS count",
        nil,
        neo4j.EagerResultTransformer,
        neo4j.ExecuteQueryWithDatabase("analytics"), // Target analytics database
    )
    
    if err == nil {
        mainCount, _ := mainResult.Records[0].Get("count")
        analyticsCount, _ := analyticsResult.Records[0].Get("count")
        fmt.Printf("Main DB: %v nodes, Analytics DB: %v nodes\n", mainCount, analyticsCount)
    }
}
```

## Error Handling Best Practices

```go
// Robust error handling for query execution
func robustQueryExecution(ctx context.Context, driver neo4j.Driver) {
    result, err := neo4j.ExecuteQuery(ctx, driver,
        "MATCH (p:Person {name: $name}) RETURN p",
        map[string]any{"name": "NonExistentPerson"},
        neo4j.EagerResultTransformer,
    )
    
    if err != nil {
        // Handle query execution errors
        fmt.Printf("Query failed: %v\n", err)
        return
    }
    
    // Handle empty results
    if len(result.Records) == 0 {
        fmt.Println("No records found")
        return
    }
    
    // Process successful results
    for _, record := range result.Records {
        person, exists := record.Get("p")
        if !exists {
            fmt.Println("Expected field 'p' not found in record")
            continue
        }
        fmt.Printf("Found person: %v\n", person)
    }
}
```

## Key Concepts

* **Parameterized Queries**: Use `map[string]any` for parameters to prevent injection attacks
* **Result Transformers**: Functions that process query results into custom formats
* **Routing Control**: Optimize performance by directing reads to replicas and writes to leaders
* **Multi-Database**: Target specific databases in Neo4j Enterprise multi-database setups
* **Error Handling**: Always check for errors and handle empty result sets gracefully

## Security Best Practices

* **Always use parameters** instead of string concatenation
* **Validate input data** before passing to queries
* **Use appropriate routing** to avoid unnecessary load on cluster leaders
* **Handle errors gracefully** without exposing internal details

[Reference: Executing Cypher Statements](https://graphacademy.neo4j.com/courses/drivers-go/1-driver/3-execute-query)