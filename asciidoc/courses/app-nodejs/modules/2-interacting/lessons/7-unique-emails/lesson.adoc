= Unique Email Addresses
:type: challenge
:branch: 04-handle-constraint-errors
:previous-branch: 03-registering-a-user
:test-number: 04


In the link:../5-registering[Registering a User challenge^], you updated the `register()` method in the link:{repository-blob}main/src/services/auth.service.js[`AuthService`^] to create a new User node in the database.

There is still one `// TODO` comment remaining in this file.

Currently, it is still possible to use the same email address twice, we should guard against that.

This functionality could be handled by checking the database before running the `CREATE` Cypher query, but this could still cause problems if the database is manually updated elsewhere.

Instead, you can pass the responsibility of handling the duplicate user error to the database by creating a Unique Constraint on the `:User` label, asserting that the `email` property must be unique.

To pass this challenge, you will need to:

1. <<Create a Unique Constraint>>
2. <<Add a Try/Catch Block>>


== Handling Constraint Errors

If we take a look at `register()` method, it has been hardcoded to throw a new `ValidationError` if the email address is anything other than `graphacademy@neo4j.com`.

.src/services/auth.service.js
[source,js,subs="attributes+",indent=0]
----
include::{repository-raw}/{previous-branch}/src/services/auth.service.js[tag=register]
----

The code also has no explicit error handling.
Any errors will be sent back up the stack and will result in a `500 Bad Request` error.
Instead, this error should be caught and reformatted in such a way that the server would return a `422 Unprocessable Entity` error.
This way, the error can be better handled by the UI.

To do this, you will need to rearange the code into `try`/`catch` blocks.

If we take a look at a generic `try`/`catch`,  it can be broken down into three parts; `try`, `catch` and `finally`.

.Try/Catch/Finally
[source,js]
----
try {
  // Attempt the code inside the block
}
catch (e) {
  // If anything goes wrong in the try block,
  // deal with the error here
}
finally {
  // Run this statement regardless of whether an error
  // is thrown or not
}
----

When a user _tries_ to register with an email address that has already been taken, the database will throw an `Neo.ClientError.Schema.ConstraintViolation` error.
Instead of this being treated as an internal server error, it should instead be treated as a `422 Unprocessable Entity`.
This will allow the front end to handle this error appropriately.

A `ValidationError` class already exists which is handled by an Express middleware.


== Completing the Challenge

To complete this challenge, you will first create a new constraint in your Sandbox database and modify the code to add a try/catch block.

=== Create a Unique Constraint

In order to ensure that a property and label combination is unique, you run a `CREATE CONSTRAINT` query.
In this case, we need to ensure that the `email` property is unique across all nodes with a `:User` label.

Click the **Run in Sandbox** button to create the constraint on your Sandbox.

[source,cypher]
----
include::{cypher-repository-raw}/main/cypher/2-interacting/6-unique-emails/constraint.cypher[]
----


=== Add a Try/Catch Block

In the method, we should:

1. **Try** to create a User with the supplied email, password and name.
2. **Catch** an error when it is thrown, using the `code` property to check and reformat a `Neo.ClientError.Schema.ConstraintValidationFailed` error into a `ValidationError`.
3. **Finally** ensure that the session is closed regardless of whether the query is successful or an error is thrown.

Your code should look like this:

[source,js,indent=0]
----
include::{repository-raw}/{branch}/src/services/auth.service.js[tag="catch"]
----

Update the `register()` method to reflect the changes above, then scroll to <<Testing>> to verify that the code works as expected.


== Working Solution

.Click here to reveal the fully-implemented `register()` method.
[%collapsible]
====
[source,js,indent=0]
----
include::{repository-raw}/{branch}/src/services/auth.service.js[tag="register"]
----
====

include::../../../../includes/test.adoc[]


include::./questions/verify.adoc[leveloffset=+1]


[.summary]
== Lesson Summary

In this Challenge, you have modified the `register()` function to catch specific errors thrown by the database.

If you wanted to go further, you could use a Regular Expression to extract more specific information about the `ConstraintValidationFailed` error.

Now that a user is able to successfully register, in the next Challenge, you will update the `authenticate()` method to find our user in the database.
