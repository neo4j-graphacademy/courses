= The Neo4j Type System
:type: lesson

At this point, we should take a look at the Cypher type system.
As Neo4j is written in Java (the _j_ in Neo4**j** stands for Java after all), there are only minor discrepancies between the types stored in the Neo4j database and native Java types.

Some values like strings, floats, booleans, and nulls map directly to Java types, but more complex types will depend on the data model defined in our application.

[%collapsible]
.Java Types to Neo4j Types
====
[cols="1,1,1"]
|===
| Java Type | Neo4j Cypher Type | Notes

| `String`
| `String`
|

| `Long`*
| `Integer`
| See <<Integers>>

| `Double`
| `Float`
| Double in Java can contain the smaller Float values, so Neo4j Float is mapped to the larger Java Double.

| `Boolean`
| `Boolean`
|

| `List`
| `List`
| Neo4j can only store a flat array containing strings, booleans, or numbers.

| `Map`
| `Map`
|

| `Object`
| `Object`
|

| `java.time.LocalDate`
| `Date`
|

| `java.time.OffsetTime`
| `Time`
|

| `java.time.LocalTime`
| `LocalTime`
|

| `java.time.ZonedDateTime`
| `DateTime`
| See <<Temporal Types>>

| `java.time.LocalDateTime`
| `LocalDateTime`
|

| `java.time.temporal.TemporalAmount`
| `Duration`
| See <<Temporal Types>>

| `org.neo4j.driver.types.Point`
| `Point`
| See <<Spatial Types>>

| `org.neo4j.driver.types.Node`
| `Node`
| See <<Nodes & Relationships>>. Note that the `org.neo4j.driver.types.Node` class is not used with Spring Repositories. Instead, nodes are mapped to the domain object.

| `org.neo4j.driver.types.Relationship`
| `Relationship`
| See <<Nodes & Relationships>>. Note that the `org.neo4j.driver.types.Relationship` class is not used with Spring Repositories. Instead, relationships are mapped to the domain object.

| `org.neo4j.driver.types.Path`
| `Path`
| Are not utilized with Spring Repositories, since database nodes and relationships are mapped to application domain objects.

| `null`, `null`
| `null`
|

|===
====

Let's take a look at some of these types in more detail.

== Integers

The Cypher Integer value is the same as the Java Long value. Both use 64-bit signed integer values (with a range of `-(2^64^- 1)` and `(2^63^- 1)`).

If the number is outside of the valid range, it will be returned as a string.

== Temporal Types

Some temporal types used in the Cypher type system are also handled differently. First, let's get a quick overview of the formats of each Cypher temporal type.

.Temporal Types
[cols="1,3,1,1"]
|===
| Neo4j Cypher Type | Description | Example

| `Date`
| Represents an instant capturing the date, but not the time, nor the timezone.
| `2020-01-02`

| `DateTime`
| Represents an instant capturing the date, the time and the timezone identifier.
| `2020-01-02T01:02:03+04:00`

| `LocalDateTime`
| Represents an instant capturing the date and the time, but not the timezone.
| `2020-01-02T01:02:03+04:00`

| `LocalTime`
| Represents an instant capturing the time of day, but not the date, nor the timezone.
| `12:34:56`

| `Time`
| Represents an instant capturing the time of day, and the timezone offset in seconds, but not the date.
| `12:34:56+04:00`
|===

More information on the Cypher temporal types can be found in the https://neo4j.com/docs/cypher-manual/5/values-and-types/temporal/[Cypher Manual^].

There are two cases where more than one Java type is mapped to a single Cypher type. When this happens, type information is lost. If the following objects are returned from procedures, the original types cannot be recreated:

1. Cypher Duration from java.time.Duration or java.time.Period - if Duration is returned, only the common interface java.time.temporal.TemporalAmount remains.
2. Cypher DateTime from java.time.OffsetDateTime - if DateTime is returned, it is converted into java.time.ZonedDateTime.

== Spatial Types

Cypher has built-in support for handling spatial values (points), and the underlying database supports storing these point values as properties on nodes and relationships.

=== Point

When using the `Point` spatial type, regardless of the coordinate reference system, an instance of the link:https://neo4j.com/docs/api/java-driver/current/org.neo4j.driver/org/neo4j/driver/types/Point.html[`Point`^] is returned.
The `Point` object has three methods:

* `srid()` - Retrieve the coordinate reference system (CRS) identifier (`4326` for the `wsg-84` or `wsg-84-3d` CRS).
* `x()` - Retrieve the x coordinate of the point.
* `y()` - Retrieve the y coordinate of the point.
* `z()` - Retrieve the z coordinate of the point or `Double.NaN` if point is 2-dimensional.

[WARNING]
.`x`, `y` and `z`
====
Regardless of the `srid` or whether the point is created using `latitude`, `longitude` (and `height`), the object returned by the Driver will *always* contain `x`, `y` and `z` properties.

When using `wsg-84` or `wsg-84-3d` coordinates, `x` will represent `longitude`, `y` will represent `latitude` and `z` will represent the height.
====

Spring Data Neo4j supports a few spatial types, including the Neo4j Point. More information is available in the https://docs.spring.io/spring-data/neo4j/docs/current/reference/html/#spatial-types[Spring Data Neo4j documentation^].

== Nodes & Relationships

Nodes and Relationships are separate entities in the Neo4j database, and they are also mapped to separate classes in our application. Depending on your domain model, you will map the database entities to your application entities directly.

Remember our Spring Data Neo4j building blocks lesson? The Neo4jTemplate and Spring Repositories layers apply the domain, skipping the driver object entirely. This means that the `org.neo4j.driver.types` classes will not be used (and their methods inaccessible) when using the Spring Repositories layer. Instead, objects coming from the database will be mapped to the domain object and those methods made accessible.

.Memory recap: Spring Data Neo4j building blocks
image::{repository-raw}/{path}/images/sdn-buildingblocks.png[Spring Data Neo4j building blocks,width=600,align=center]

Let's look at this using our coffee shop example from the previous lesson.

=== Nodes

We can retrieve the coffee shop orders by setting the return type on the repository method to the domain object (in this case, `Order`). The https://docs.spring.io/spring-data/neo4j/docs/current/reference/html/#mapping.annotations.node[`@Node` annotation^] on the `Order` class tells Spring to map this domain object to node entities in the database.

.Working with Nodes
[source,java,role=ncopy,subs="attributes+",indent=0]
----
include::{sdn-repository-raw}/main/example/results.java[tag=node]
include::{sdn-repository-raw}/main/example/results.java[tag=node-results]
----

Spring will try to map the object returned from the query to the `Order` class, and if it is unable to, the application will error. This is important to keep in mind when writing your queries that you must return the same object from the query that you want to map in the application domain.

The entity exposes the get and set methods that we define in our domain class for member variables. For example, the `Order` class has a `getTransactionId()` method that returns the `transaction` property of the node.

.Accessing Node Methods
[source,java,role=ncopy,subs="attributes+",indent=0]
----
include::{sdn-repository-raw}/main/example/results.java[tag=node-methods]
----

=== Relationships

`Relationship` objects are similar to those for `Node` in that they also are mapped to any domain objects specified. However, if there are no specific properties on the relationship, we can skip a separate domain object by mapping connections between nodes directly. Using the https://docs.spring.io/spring-data/neo4j/docs/current/reference/html/#mapping.annotations.relationship[`@Relationship` annotation^] notifies Spring that this variable maps to a relationship entity in the database.

.Working with Relationships
[source,java,role=ncopy,subs="attributes+",indent=0]
----
include::{sdn-repository-raw}/main/example/results.java[tag=rel]

include::{sdn-repository-raw}/main/example/results.java[tag=rel-results]
----

Just like with nodes, we can access relationship properties using getter and setter methods. For example, `receipt.getTotal()` for our `Receipt` relationship entity. However, since we can only return `Order` objects from the `OrderRepository`, we would need to traverse from the node to the relationship entity to access it.

Let's see what that looks like.

.Accessing Relationship Methods
[source,java,role=ncopy,subs="attributes+",indent=0]
----
include::{sdn-repository-raw}/main/example/results.java[tag=rel-methods]
----

In the above code, we access the order variable, then access the `invoice` variable (which is a `Receipt` type), and then access the `getTotal()` method on the `Receipt` entity.

== Check Your Understanding

include::questions/1-node-mapping.adoc[leveloffset=+1]

include::questions/2-rel-mapping.adoc[leveloffset=+1]

[.summary]
== Lesson Summary

In this lesson, we covered the mappings between the Neo4j Cypher type system and the Java type system. We also walked through the differences and how database node and relationship entities are mapped and handled in a Spring Data Neo4j application.

Next, we will begin the application you will create for this course, building the requirements and the data model that will underpin it.
