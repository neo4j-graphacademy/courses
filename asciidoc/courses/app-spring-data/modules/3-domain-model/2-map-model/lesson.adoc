= Application Domain to Graph Model
:type: lesson

In the last lesson, we talked about how a set of data is organized into a domain model for human understanding, and then mapped to an application domain model. In some cases, the application domain model also needs to be mapped to a database model. 

While this can be a one-to-one mapping where all three models are the same, it often isn't. This is because each model must fit the constraints of the system it is designed for. The human domain model must be easily translatable to stakeholders, business analysts, and developers. The application domain model must fit the constraints of the chosen programming language. The database model must fit the constraints of data types, relationship syntax, and typically efficient storage and query retrieval.

== Graph Data Model for the Win

Graphs help us to bridge the gap between data models. The graph data model is an excellent fit for the human model because it is flexible and naturally represents data as it exists in the real world, making it more easily understandable across technical and non-technical realms.

A graph data model is also a good fit for the application domain model because the entities and relationships found in the graph model also translate well into the object-oriented world of Java and Spring. Finally, the Neo4j graph database was designed to center around the graph data model, so there is no mapping required between the original human graph model and the database model.

The best way to grasp this concept is to see it in action. Let's see some examples!

== Coffee Shop Orders Example

Let's say we are building an application for a coffee shop. The application will allow customers to place orders for coffee and other items, and allow baristas to fulfill those orders. Managers could also use the sales data to track product popularity and make decisions about what to stock or on which items to run promotions.

With this information, let's build a human domain model. Most of us probably gravitate towards a whiteboard or piece of paper to start drawing out our ideas for mapping the data.

=== Domain Model

Try to create your version of the model, and then feel free to reveal the one below to compare them. Your data model may differ, and that's ok. It's valuable to see how others take the same description of a data set and come up with a completely different model.

[%collapsible]
.Click to reveal a sample domain model
====
Sample Coffee Shop Order Domain Model

image::{repository-raw}/{path}/images/coffee-shop-domain-model.png[Coffee Shop Order domain model,width=600]
====

Is your data model different? If so, how (i.e. drawing style, different entities, properties/no properties)? What decisions or perspectives might have influenced the differences?

For example, if you are used to working with relational diagramming, did you style your drawing like an Entity-Relationship Diagram (ERD)? Or did you already start normalizing the model by adding an associative entity between orders and products?

No matter what your model looks like, it's important to note that there is no right or wrong way to draw it. For the next step, we could model a bottom's up approach to create the database model, then the application model, or we could use a top-down approach and create the application model before the database one. Since the database model is traditionally more restrictive, let's map our human model to a database model first.

=== Database Model

Feel free to choose whichever database modeling structure you are most comfortable - relational, document, etc. We will create a sample model that would work for either relational or document before we look at a graph version. You can use the human model you just created or our version above for your database model. Again, when you're ready, reveal the one below to compare.

[%collapsible]
.Click to reveal sample database model
====
Sample Coffee Shop Order Database Model

image::{repository-raw}/{path}/images/coffee-shop-relational-model.png[Coffee Shop Order Relational model,width=600]
====

There is a lot more room for differences in this model, mostly because we did not give a lot of details about the data set. For example, this model uses the combination of `transactionId` and `lineItemNumber` to uniquely identify a unique order line item. However, someone else's model might ensure you cannot have different line items for the same product on an order (combine them by increasing quantity and use combination of `transactionId` and `productId` for a unique line item).

Did you allow a customer to be entered into the system without an order? According to the model above, you cannot have a customer added to the system with no associated order (relationship cardinality of 1 or many). Did you put a `total` property the `Order` entity? Or plan to calculate a total ad hoc based on the `quantity` and `price` of each line item?

In our model, notice that we created an associative (or JOIN) entity between `Order` and `Product`. This is a common pattern in relational databases, but it is not the only way to model this relationship. For example, a document database might store the products as subdocuments on the order.

Now let's see a sample graph model.

[%collapsible]
.Click to reveal sample graph model
====
Sample Coffee Shop Order Graph Model

image::{repository-raw}/{path}/images/coffee-shop-graph-model.png[Coffee Shop Order Graph model,width=600]
====

Notice that the graph model is very similar to the human model. This is intentional because graphs are designed for the human domain model. The graph model also translates well to the application domain model, which we will see in the next section.

=== Application Model

//should we let users create their own models here? Or just show them an example and let them create their own in the next section?

//LEFT OFF HERE!

//old
Your challenge is to add a new Driver instance to an existing file with the connection details provided.
Once you have created the Driver, you will need to open a new session and run a Cypher statement to find the director of the movie **Toy Story**.


link:./lab[Open Challenge in an Online IDE â†’^, role=btn]

== Steps

1. Install the Neo4j JavaScript Driver in the integrated terminal window
+
include::{repository-raw}/main/README.adoc[tag=install]

2. Use the `neo4j` object to create a new instance of the Driver with the credentials provided:
  * `NEO4J_URI` is the connection string
  * `NEO4J_USERNAME` and `NEO4J_PASSWORD` should be used to create the authentication token.

3. Once you have created the Driver, open a new session and run the following query: +
+
.Find the Director
[source, cypher]
----
include::{repository-raw}/main/cypher/movie-director.cypher[]
----

4. To find the answer, click the Debug icon to the left of the window and run **Create Driver Challenge** task, or use the integrated terminal window to run the following command: +
+
.Run The Challenge
[source,sh,subs=attributes+]
----
ts-node {lab-file}
----

5. Once you have the result, copy and paste it into the text box below and click **Check Answer**.


== Your Answer

include::questions/1-director.adoc[leveloffset=+1]
//end old

=== Reading Data from Neo4j

The Driver uses data from the Routing Table to distribute read statements across the cluster in a least-connected fashion, ensuring that the cluster is evenly utilised.

To execute a Cypher statement within a read transaction, call the `executeRead()` method.

[source,ts]
.Read Transactions
----
include::{repository-raw}/main/src/example.ts[tag=executeread,indent=0]
----

The `executeRead()` method executes a unit of work, represented as a callback function (1), before marking the transaction as successful.
The callback function is passed an instance of a `ManagedTransaction`, on which the `run()` method can be called multiple times to execute Cypher statements (2).

The `run()` method is similar to `session.run()` in that it accepts two parameters; a Cypher statement and an object representing the query parameters.

=== Writing Data to Neo4j

The cluster will always contain one instance, known as the **Leader**, which has the responsibility of processing write transactions.
The Leader is responsible for distributing the transaction's outcome across the cluster.
Once the majority of core servers acknowledge this information, the transaction is considered _committed_ and acknowledgement is sent back to the Driver along with any data requested by the Cypher statement.

To execute a Cypher statement within a write transaction, call the `executeWrite()` method.

[source,ts]
.Write Transactions
----
include::{repository-raw}/main/src/example.ts[tag=executewrite,indent=0]
----

== Result Processing

Two methods are available for consuming results from a transaction, the **Promise API** and the **Streaming API**.

=== Promise API

The most common method of consuming results is with the Promise API.
Both `session.run()` and `tx.run()` return an instance of a `Result`, a Promise-like class upon which you can chain `.then()`, `.catch()` and `.finally()` methods.

Once the statement has been executed, and all results returned, the Result will _resolve_ to a `QueryResult` object.

[source,ts]
----
include::{repository-raw}/main/src/example.ts[tags="executeread,promise",indent=0]
----

You can also iterate over the result returned by `tx.run()` or `session.run()` within a `for` loop.

.Using AsyncIterator
[source,js,role=nocopy,subs="attributes+",indent=0]
----
include::{repository-raw}/main/src/example.ts[tag=iterate]
----

If you have long-running queries that explore a large part of the graph, it may take a while for the results to become available.
In this case, you should use the Streaming API.

=== Streaming API

There may be occasions where you have slower-running or more complex queries but wish to process results as they become available.

For example, many Flight search websites have complex queries that take up to a minute to complete, but shorter, less complex graph patterns may be available immediately.

In this case, you can use the `subscribe()` method to consume results as they become available.
This method is available when calling `session.run()` or `tx.run()` within a transaction function.

You can use this method with WebSockets or similar technologies to update the front-end application with new results as they are made available.

The `subscribe()` method accepts one argument, an object of callbacks:

* `onKeys` - called when keys are made available for all records.
* `onNext` - called when the next Record is available.
* `onError` - called if an error occurs.
* `onCompleted` - called when all records have been consumed, and no error has occurred.

[source,ts,indent=0]
----
include::{repository-raw}/main/src/example.ts[tag=streaming]
----

=== Individual Results

In both examples above, individual records are accessed through an implementation of the `Record` type exported from `neo4j-driver`.
The `Record` type contains methods for interacting with each Record.

The `.keys()` method provides an array of available keys on the Record, and the `.has()` method can be called to check that a key exists on the Record.

.Get Keys
[source,ts,indent=0]
----
include::{repository-raw}/main/src/example.ts[tag=keys]
----

There are several ways to iterate over a record; `.forEach()` and `.map()` work as if the record were an `array`, and you can also call `.entries()` or `.values()` to act on the Record as if it were a `Map` object.
You can also access values within a `for` loop.

.For Loop
[source,ts,indent=0]
----
include::{repository-raw}/main/src/example.ts[tag=forloop]
----

To retrieve an individual value from a Record, call the `.get()` method.
The method accepts a single parameter, the alias of the value stated in the `RETURN` statement or the 0-based index of the value.

.Accessing a Value
[source,ts,indent=0]
----
include::{repository-raw}/main/src/example.ts[tag=value]
----

You can quickly convert the Record to a JavaScript object using the `.toObject()` method, a convenient way of converting nested values without recursively iterating through the Record.

.toObject
[source,ts,indent=0]
----
console.log(Record.toObject()) // {p: Node, r: Relationship, m: Node}
----

== Check Your Understanding

include::questions/1-read-transaction.adoc[leveloffset=+1]
include::questions/2-write-transaction.adoc[leveloffset=+1]
include::questions/3-promise-api.adoc[leveloffset=+1]
include::questions/4-get-method.adoc[leveloffset=+1]

= Reading Data from Neo4j
:type: quiz

Complete the code block below by identifying the correct method for executing a Cypher statement in a **read** transaction.

include::questions/complete.adoc[leveloffset=+1]
//end old

= Writing Data to Neo4j
:type: challenge
:lab-file: src/challenges/write/challenge.ts
:lab-solution: src/challenges/write/solution.ts
:lab: {repository-blob}/main/{lab-file}

Your challenge is to modify another pre-written file to add yourself as an actor in The Matrix.

link:./lab[Open Challenge in an Online IDE â†’^, role=btn]

== Steps

1. Update the `params` object to use your name.
This step isn't strictly required, just a bit of fun.


2. The Cypher statement is already written for you.
Call the `session.executeWrite()` method, passing a callback function to represent the unit of work.


3. In that function you must call the `run()` method on the first parameter passed to the function, using the `cypher` and `params` variables.

4. `await` the results and use `console.log` to check that the code has executed correctly.

5. To add the new node and relationship to the database, click the Debug icon to the left of the window and run **Writing Data Challenge** task, or use the integrated terminal window to run the following command: +
+
.Run The Challenge
[source,sh,subs=attributes+]
----
ts-node {lab-file}
----

6. Once the code has run, click **Verify** and we will check that the node has been added to the database.

include::questions/verify.adoc[leveloffset=+1]

[.summary]
== Lesson Summary

In this challenge, you used your knowledge to create a driver instance and run a Cypher statement.

Next, we will look at the Neo4j Type System and some of the considerations that you need to make when working with values coming from Neo4j in your TypeScript application.
