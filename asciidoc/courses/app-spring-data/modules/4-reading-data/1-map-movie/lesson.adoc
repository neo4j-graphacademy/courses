= Creating Movie classes
:type: lesson

Our data model shows entities for movies, people, and relationships between them. Let's start creating our application domain with the Movie entity.

== Movie domain class

We need a Java class to represent the Movie entity. We will use the `@Node` annotation to mark the class as a node entity, so that Spring knows this class represents a node in our database. We will also use the `@Id` annotation to mark the `id` field as the node identifier. While we wouldn't need to map all of the fields on the `Movie` node, we will go ahead and map all of them for this example. Once all the fields are created, we will need getter and setter methods and a class constructor to allow us to access them.

Here are all of the properties (and their data types) on the `Movie` nodes in Neo4j:

[source,text]
----
{
  budget:"INTEGER", 
  movieId:"STRING", 
  tmdbId:"STRING", 
  imdbVotes:"INTEGER", 
  runtime:"INTEGER", 
  countries:"LIST OF STRING", 
  imdbId:"STRING", 
  url:"STRING", 
  plot:"STRING", 
  released:"STRING", 
  languages:"LIST OF STRING", 
  imdbRating:"FLOAT", 
  title:"STRING", 
  poster:"STRING", 
  year:"INTEGER", 
  revenue:"INTEGER"
}
----

Now let's use that to create our domain class. Create a new class file called `Movie.java` in the `src/main/java/com/example/appspringdata` directory and add the fields, as shown below. Review the https://neo4j.com/docs/java-reference/current/extending-neo4j/values-and-types/[data type mappings^] from the documentation (Table 1), if needed.

[source,java]
----
@Node
public class Movie {
    @Id
    private String movieId;

    private String title;
    private String plot;
    private String poster;
    private String url;
    private String imdbId;
    private String tmdbId;
    private String released;

    private Long year;
    private Long runtime;
    private Long budget;
    private Long revenue;
    private Long imdbVotes;

    private Double imdbRating;

    private String[] languages;
    private String[] countries;

    //constructor, getters, and setters
}
----

[NOTE]
----
We have set a placeholder for the constructor, getter methods, and setter methods. Those are standard Java practices and many IDEs will generate them for you.
----

There shouldn't be surprises, since all of these property data types match up. This looks pretty good, so let's move on and create the repository interface for querying `Movie` entities from the database.

== Movie repository interface

Start by creating a new interface file called `MovieRepository.java` in the `src/main/java/com/example/appspringdata` directory and extend it to match the following:

[source,java]
----
interface MovieRepository extends Neo4jRepository<Movie, String> {
}
----

Spring Data provides repository extensions for many of its supported projects. They include methods and functionality specifically designed and optimized for the data store. In this case, we are extending the `Neo4jRepository` interface. The first type parameter is the domain class that the repository will be working with, and the second type parameter is the type of the identifier for that domain class. In this case, we are using the `Movie` domain class and the `String` type for the identifier.

Spring Data also implements a few standard methods for us, such as `save`, `findById`, `findAll`, and `deleteById`. This is why we don't need to define queries and methods to start out. We will see how to define custom implementations later in this course.

Let's move on to the controller class, which will expose the results from our queries to users via an API.

== Movie controller class

Create a new class file called `MovieController.java` in the `src/main/java/com/example/appspringdata` directory and add the following code:

[source,java]
----
@RestController
@RequestMapping("/movies")
public class MovieController {
    private final MovieRepository movieRepo;

    public MovieController(MovieRepository movieRepo) {
        this.movieRepo = movieRepo;
    }

    @GetMapping()
    Iterable<Movie> findAllMovies() {
        return movieRepo.findAll();
    }

    @GetMapping("/{movieId}")
    Optional<Movie> findMovieById(@PathVariable String movieId) {
        return movieRepo.findById(movieId);
    }
}
----

This is a standard Spring MVC controller class. We have annotated it with `@RestController` to tell Spring that this class will be used to handle requests and responses and used `@RequestMapping` to handle requests at the `/movies` endpoint. The first line inside the class injects the repository interface, so that we can access and call our repository methods, then a constructor takes a `MovieRepository` instance as a parameter. This is called dependency injection and is a standard practice in Spring applications.

We have defined two methods to handle requests. The first method is annotated with `@GetMapping` and will handle requests to the `/movies` endpoint. It calls one of the out-of-the-box methods that Spring provides, the derived `findAll` method and returns a list of movies. The second method will handle requests to the `/movies/{movieId}` endpoint, including a path variable in the URL for a distinct movie id. It calls the derived `findById` method on the repository (passing in the path variable value) and returns the results.

We have now created a domain class, repository interface, and controller class. Let's run our application and test it out.

== Running and testing the application

We can run our application from our IDE or at the command line using `./mvnw spring-boot:run`. Once the application is running, we can open a browser and navigate to `http://localhost:8080/movies` to see the results of the `findAll` method. We can also navigate to `http://localhost:8080/movies/tt0114709` to see the results of the `findById` method.

.FindAll Results (example)
----
{
  "movieId":"1",
  "title":"Toy Story",
  "plot":"A cowboy doll is profoundly threatened and jealous when a new spaceman figure supplants him as top toy in a boy's room.",
  "poster":"https://image.tmdb.org/t/p/w440_and_h660_face/uXDfjJbdP4ijW5hWSBrPrlKpxab.jpg",
  "url":"https://themoviedb.org/movie/862",
  "imdbId":"0114709",
  "tmdbId":"862",
  "released":"1995-11-22",
  "year":1995,
  "runtime":81,
  "budget":30000000,
  "revenue":373554033,
  "imdbVotes":591836,
  "imdbRating":8.3,
  "languages":[
    "English"
  ],
  "countries":[
    "USA"
  ]
},
//additional results
----

.FindById Results (example)
----
{
  "movieId": "2",
  "title": "Jumanji",
  "plot": "When two kids find and play a magical board game, they release a man trapped for decades in it and a host of dangers that can only be stopped by finishing the game.",
  "poster": "https://image.tmdb.org/t/p/w440_and_h660_face/vgpXmVaVyUL7GGiDeiK1mKEKzcX.jpg",
  "url": "https://themoviedb.org/movie/8844",
  "imdbId": "0113497",
  "tmdbId": "8844",
  "released": "1995-12-15",
  "year": 1995,
  "runtime": 104,
  "budget": 65000000,
  "revenue": 262797249,
  "imdbVotes": 198355,
  "imdbRating": 6.9,
  "languages": [
    "English",
    " French"
  ],
  "countries": [
    "USA"
  ]
}
----

[NOTE]
----
Results may not be in the same order or formatted exactly as shown above. Formatted results depend on whether pretty-printing is enabled in your browser or command line styling.
----

[.summary]
== Summary

In this lesson, you created the Movie domain, repository, and controller classes. You also ran and tested the application, which uses an API to call repository methods that query the database and return the results.

Next, you will complete a challenge to apply the skills you learned here to create the Person domain, repository, and controller classes.