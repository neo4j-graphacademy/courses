= Building the Recommendation Query
:type: lesson
:order: 1
:duration: 10

[.slide.discrete]
== Introduction

You've imported the nodes.  You've created the relationships.  You've practiced writing queries.

Now you'll build the complete recommendation query that answers: **"What products do people like me buy, that I haven't bought yet?"**

In this lesson, you will construct the recommendation algorithm step by step.


[.slide]
== Understanding the recommendation algorithm

**Collaborative filtering** finds recommendations based on similar customers:

1. **Find my products** - What I've purchased
2. **Find similar customers** - Who else bought those products
3. **Find their products** - What they purchased
4. **Exclude my products** - Only show things I haven't bought
5. **Rank by popularity** - Most recommended first


[.slide.col-2]
== Step 1: finding my products

Start with what customer ALFKI has purchased:

[.col]
====
[source,cypher]
.My purchase history
----
MATCH (me:Customer {id: 'ALFKI'})-[:PLACED]->(:Order)-[:CONTAINS]->(myProduct:Product)  // <1>
RETURN DISTINCT myProduct.name                                                                   // <2>
ORDER BY myProduct.name;                                                                         // <3>
----
====

[.col]
====
<1> **Find customer and traverse** - Start at customer, follow PLACED to orders, then CONTAINS to products
<2> **Return products** - Get unique product names
<3> **Sort results** - Alphabetically by product name

This finds all products ALFKI has ever bought.
====



[.slide.col-2]
== Step 2: finding similar customers

Who else bought the same products?

[.col]
====
[source,cypher]
.Customers with similar purchases
----
MATCH (me:Customer {id: 'ALFKI'})-[:PLACED]->(:Order)-[:CONTAINS]->(myProduct:Product)
MATCH (myProduct)<-[:CONTAINS]-(:Order)<-[:PLACED]-(other:Customer)                             // <1>
WHERE other <> me
RETURN other.name, count(DISTINCT myProduct) AS sharedProducts
ORDER BY sharedProducts DESC
LIMIT 10;
----
====

[.col]
====
<1> **Similar customers** - Backward traversal from my products to find other customers who bought the same products

This finds customers with the most similar taste.
====



[.slide.col-2]
== Step 3: finding their products

What did similar customers buy?

[.col]
====
[source,cypher]
.Products similar customers bought
----
MATCH (me:Customer {id: 'ALFKI'})-[:PLACED]->(:Order)-[:CONTAINS]->(myProduct:Product)
MATCH (myProduct)<-[:CONTAINS]-(:Order)<-[:PLACED]-(other:Customer)
WHERE other <> me
MATCH (other)-[:PLACED]->(:Order)-[:CONTAINS]->(rec:Product)                                    // <1>
RETURN DISTINCT rec.name, count(DISTINCT other) AS recommendedBy
ORDER BY recommendedBy DESC
LIMIT 10;
----
====

[.col]
====
<1> **Their products** - Forward traversal from similar customers to find what they bought

However, this includes products ALFKI already bought!
====



[.slide.col-2]
== Step 4: excluding my products

Add a filter to exclude products I already own:

[.col]
====
[source,cypher]
.Recommendations excluding my purchases
----
MATCH (me:Customer {id: 'ALFKI'})-[:PLACED]->(:Order)-[:CONTAINS]->(myProduct:Product)
MATCH (myProduct)<-[:CONTAINS]-(:Order)<-[:PLACED]-(other:Customer)
WHERE other <> me
MATCH (other)-[:PLACED]->(:Order)-[:CONTAINS]->(rec:Product)
RETURN rec.name, count(DISTINCT other) AS recommendedBy
WHERE NOT (me)-[:PLACED]->(:Order)-[:CONTAINS]->(rec)                                           // <1>
ORDER BY recommendedBy DESC
LIMIT 10;
----
====

[.col]
====
<1> **Exclude my purchases** - Only recommend products I haven't already bought
====



[.slide.col-2]
== Step 5: adding product details

Enrich with price and availability:

[.col]
====
[source,cypher]
.Complete recommendations with details
----
MATCH (me:Customer {id: 'ALFKI'})-[:PLACED]->(:Order)-[:CONTAINS]->(myProduct:Product)
MATCH (myProduct)<-[:CONTAINS]-(:Order)<-[:PLACED]-(other:Customer)
WHERE other <> me
MATCH (other)-[:PLACED]->(:Order)-[:CONTAINS]->(rec:Product)
WHERE NOT (me)-[:PLACED]->(:Order)-[:CONTAINS]->(rec)
  AND rec.unitsInStock > 0                                                                       // <1>
RETURN rec.name,
       rec.unitPrice,                                                                            // <2>
       rec.unitsInStock,
       count(DISTINCT other) AS recommendedBy
ORDER BY recommendedBy DESC, rec.unitPrice                                                       // <3>
LIMIT 10;
----
====

[.col]
====
<1> **Filter available** - Only show in-stock products
<2> **Add product details** - Include price and stock information
<3> **Secondary sort** - Sort by popularity first, then by price
====


[.slide]
== Comparing to SQL

Here's the same query in SQL (simplified):

[source,sql]
----
-- Find my products
WITH my_products AS (
  SELECT DISTINCT od.productID
  FROM customers c
  JOIN orders o ON c.customerID = o.customerID
  JOIN order_details od ON o.orderID = od.orderID
  WHERE c.customerID = 'ALFKI'
),
-- Find similar customers
similar_customers AS (
  SELECT DISTINCT c2.customerID
  FROM customers c2
  JOIN orders o2 ON c2.customerID = o2.customerID
  JOIN order_details od2 ON o2.orderID = od2.orderID
  WHERE od2.productID IN (SELECT productID FROM my_products)
    AND c2.customerID <> 'ALFKI'
),
-- Find recommendations
recommendations AS (
  SELECT od3.productID, COUNT(DISTINCT sc.customerID) as recommendedBy
  FROM similar_customers sc
  JOIN orders o3 ON sc.customerID = o3.customerID
  JOIN order_details od3 ON o3.orderID = od3.orderID
  WHERE od3.productID NOT IN (SELECT productID FROM my_products)
  GROUP BY od3.productID
)
SELECT p.name, p.unitPrice, p.unitsInStock, r.recommendedBy
FROM recommendations r
JOIN products p ON r.productID = p.productID
WHERE p.unitsInStock > 0
ORDER BY r.recommendedBy DESC, p.unitPrice
LIMIT 10;
----

**38 lines vs 11 lines!**


[.slide]
== Analyzing Cypher vs SQL

[options="header"]
|===
| Metric                 | Cypher                             | SQL
| Lines of code          | 11                                 | 38
| JOINs                  | 0                                  | 7
| CTEs/Subqueries        | 0                                  | 3 CTEs + 2 subqueries
| Readability            | Reads like the question            | Complex nested logic
| Performance            | O(k) - scales with connections     | O(n × m) - table scans
| Maintainability        | Easy to modify                     | Hard to debug
|===

**Graph databases excel at connected data queries.**


[.slide]
== Experimenting with the query

**Modify the query:**

1. Change customer ID to `'ANTON'` or `'BOLID'`
2. Change LIMIT to see more recommendations
3. Add price filter: `AND rec.unitPrice < 50`
4. Remove stock filter to see all products
5. Show top 20 instead of 10

**Experiment further:** Why not try and create a weighted score that considers both popularity and price?

read::Mark as completed[]

[.summary]
== Summary

In this lesson, you built the recommendation query:

* **Step 1:** Find my products (forward traversal)
* **Step 2:** Find similar customers (backward traversal)
* **Step 3:** Find their products (forward again)
* **Step 4:** Exclude my products (WHERE NOT pattern)
* **Step 5:** Add filters and details (stock, price)
* **Result:** Production-ready collaborative filtering in 11 lines
* **Comparison:** 11 lines Cypher vs 38 lines SQL
* **Performance:** O(k) graph traversal vs O(n × m) joins

**You've modeled your data and written a recommendation query that is simpler to understand and faster to execute than SQL!**

