= Introduction to Cypher
:type: lesson
:order: 1

[.slide.discrete]
== Introduction to Cypher

You have imported data into your Northwind graph. To query and explore that data, you need to learn Cypher, Neo4j's graph query language.

In this lesson, you will learn the basics of Cypher syntax and how to write simple queries.


[.slide]
== Understanding Cypher

*Cypher* is Neo4j's graph query language.

It's designed to be intuitive and readable, using ASCII-art patterns to represent graph structures.

Just as SQL is used to query relational databases, Cypher is used to query graph databases.


[.slide]
== Why use Cypher?

Cypher makes graph queries natural and expressive:

*Example:* Find customers who placed orders

*SQL (Complex joins):*

[source,sql]
----
SELECT c.companyName, o.orderId
FROM customers c
JOIN orders o ON c.customerID = o.customerID;
----

*Cypher (Pattern matching):*

[source,cypher]
----
MATCH (c:Customer)-[:PLACED]->(o:Order)
RETURN c.companyName, o.orderId;
----

The Cypher version reads like a sentence and matches the visual structure of the graph!


[.slide]
== Learning Cypher basics

[.slide]
=== Representing nodes

Nodes are represented with parentheses `()`. Let's explore the different ways to match nodes, from the most general to the most specific.

[source,cypher]
.Node pattern variations
----
MATCH (n)                                     // (1)
RETURN n LIMIT 1;

MATCH (c:Customer)                            // (2)
RETURN c LIMIT 1;

MATCH (c:Customer {customerId: 'ALFKI'})      // (3)
RETURN c;
----

<1> **Any node** - `(n)` matches any node in the graph and assigns it to variable `n`
<2> **Label filter** - `(c:Customer)` matches only nodes with the Customer label
<3> **Property filter** - Add curly braces `{customerId: 'ALFKI'}` to match a specific node by its properties

The syntax gets more specific from top to bottom - start with `()` for any node, add `:Label` to filter by type, add `{property: value}` to find exact matches.

Click **Run** on each query to see how the patterns match different nodes in your Northwind graph.


[.slide]
=== Representing relationships

Relationships connect nodes and are represented with arrows. The arrow direction and syntax determine how you traverse the graph.

[source,cypher]
.Relationship pattern variations
----
MATCH (c:Customer)-[:PLACED]->(o:Order)       // <1>
RETURN c.companyName, o.orderId LIMIT 1;

MATCH (c:Customer)-[r:PLACED]->(o:Order)      // <2>
RETURN r LIMIT 1;

MATCH (c:Customer)-[:PLACED]-(o:Order)        // <3>
RETURN c, o LIMIT 1;
----

<1> **Directional relationship** - `-[:PLACED]->` follows the PLACED relationship from Customer to Order (the arrow shows direction)
<2> **Relationship variable** - `[r:PLACED]` assigns the relationship to variable `r` so you can access its properties or return it
<3> **Bidirectional match** - `-[:PLACED]-` matches in either direction, useful when direction doesn't matter for your query

The square brackets `[]` contain the relationship type and optional variable. The arrow direction (`->`, `<-`, or `-`) determines which way you traverse.

Click **Run** to see how these patterns match customer orders in different ways.


[.slide]
=== Forming patterns

Combine nodes and relationships to form patterns that match the structure of your graph. Each pattern represents a path through connected data.

[source,cypher]
.Common Northwind patterns
----
MATCH (c:Customer)-[:PLACED]->(o:Order)                // (1)
RETURN c.companyName, o.orderId LIMIT 1;

MATCH (o:Order)-[:ORDERS]->(p:Product)                 // (2)
RETURN p.productName LIMIT 1;

MATCH (p:Product)-[:PART_OF]->(cat:Category)           // (3)
RETURN cat.categoryName LIMIT 1;
----

<1> **Customer to Order** - Traverses from a customer to the orders they placed
<2> **Order to Product** - Finds products that appear in orders (the line items)
<3> **Product to Category** - Navigates from a product to its category classification

[source,mermaid]
....
graph LR
    A((Customer)) -->|PLACED| B((Order))
    B -->|ORDERS| C((Product))
    C -->|PART_OF| D((Category))
....

These patterns can be chained together to traverse multiple relationships in a single query. Try running each query to see what data they return.


[.slide]
== Using core Cypher clauses

*Key clauses you will use:*

* *MATCH* - Find patterns in the graph
* *WHERE* - Filter results
* *RETURN* - Specify what to return
* *CREATE* - Create new nodes/relationships
* *DELETE* - Delete nodes/relationships
* *SET* - Update properties
* *REMOVE* - Remove properties/labels


[.slide]
== Breaking down a simple query

Let's analyze a complete query that combines multiple Cypher clauses to answer a business question: "Which German customers place the most orders?"

[source,cypher]
----
MATCH (c:Customer)-[:PLACED]->(o:Order)              // (1)
WHERE c.country = 'Germany'                          // (2)
RETURN c.companyName, count(o) AS orderCount        // (3)
ORDER BY orderCount DESC                             // (4)
LIMIT 5                                              // (5)
----

<1> **MATCH clause** - Finds the pattern of customers connected to their orders via PLACED relationships
<2> **WHERE clause** - Filters to include only customers located in Germany
<3> **RETURN clause** - Returns the company name and counts how many orders each customer has (aliased as `orderCount`)
<4> **ORDER BY clause** - Sorts results by order count in descending order (highest first)
<5> **LIMIT clause** - Restricts output to the top 5 results

Click **Run** to see which German customers are the most active. You'll see results similar to:

[options="header",cols="2,1"]
|===
| companyName | orderCount

| Königlich Essen | 10
| QUICK-Stop | 8
| Toms Spezialitäten | 7
|===


[.slide]
== Using variables

Variables give you a way to reference nodes and relationships throughout your query. Once you assign a variable in the MATCH clause, you can use it in WHERE, RETURN, and other clauses.

[source,cypher]
----
MATCH (c:Customer)-[r:PLACED]->(o:Order)    // (1)
RETURN c, r, o                               // (2)
LIMIT 5;
----

<1> **Assigning variables** - `c` is assigned to Customer nodes, `r` to PLACED relationships, and `o` to Order nodes
<2> **Using variables** - Return the complete pattern by referencing all three variables

Variable naming conventions:
* Use descriptive names: `customer`, `c`, `order`, `o`
* Node variables: `(c:Customer)` - variable before the colon
* Relationship variables: `[r:PLACED]` - variable before the type in square brackets

Click **Run** to see the complete pattern visualized in graph form. The Query tool will show you the nodes and relationships together.


[.slide]
== Accessing properties

Once you've matched nodes or relationships, you access their properties using dot notation. This lets you return specific data instead of the entire node.

[source,cypher]
----
MATCH (c:Customer)                                // (1)
RETURN c.companyName, c.city, c.country          // (2)
LIMIT 10;
----

<1> **Match the node** - Find Customer nodes and assign them to variable `c`
<2> **Access properties** - Use `c.propertyName` to access individual properties of the customer node

The dot notation `variable.property` works for both nodes and relationships. For example, `r.quantity` would access the quantity property of a relationship assigned to variable `r`.

Click **Run** to see customer properties displayed in a table format. Try adding more properties like `c.contactName` or `c.phone` to the RETURN clause.


[.slide]
== Following Cypher style conventions

*Best practices:*

* *Labels*: PascalCase (Customer, Product)
* *Relationship types*: UPPER_SNAKE_CASE (PLACED, PART_OF)
* *Properties*: camelCase (companyName, unitPrice)
* *Variables*: camelCase (c, customer, o, order)
* *Keywords*: UPPERCASE (MATCH, WHERE, RETURN)


[.slide]
== Running Cypher queries

In Neo4j Aura, open the *Query* tool to run Cypher:

1. Type your Cypher query in the editor
2. Click *Run* or press `Ctrl+Enter` (`Cmd+Enter` on Mac)
3. View results as graph or table


[.summary]
== Lesson Summary

In this lesson, you learned the basics of Cypher, Neo4j's graph query language:

* *Cypher* is designed to be intuitive and readable, using ASCII-art patterns to represent graph structures
* *Node syntax*: `(n:Label {property: value})`
* *Relationship syntax*: `-[:TYPE]\->`
* *Pattern syntax*: `(a)-[:REL]\->(b)`
* *Core clauses*: MATCH, WHERE, RETURN, CREATE, DELETE, SET, REMOVE
* *Variables* let you reference nodes and relationships in queries
* *Dot notation* (`c.companyName`) accesses properties
* *Style conventions*: PascalCase for labels, UPPER_SNAKE_CASE for relationships, camelCase for properties and variables

In the next lesson, you will read data from the Northwind graph using Cypher queries.


read::It's time to learn Cypher![]
