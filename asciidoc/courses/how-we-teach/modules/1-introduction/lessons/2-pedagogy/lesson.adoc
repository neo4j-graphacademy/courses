= Pedagogy
:type: lesson
:order: 2

== Iterative learning

We aim to provide an iterative learning experience of _learn, recognize, recall_.

1. **Learn** - the learner will be introduced to a concept with a combination of text content and graphics and visualizations.  This learner _should_ also be given the option to watch a video. [link:#[Example^]]

2. **Recognize** - in the next lesson, the user will be challenged to recognise the information, reinforcing the ideas and concepts they have just learned.  This is usually with a quiz.  [link:#[Example^]]

3. **Recall** - with the concept fresh in their mind, they will be challenged to recall what they have learned and recognized in the previous two lessons.  They should feel supported by the appropriate content in the lesson (skaffolding).  This further reinforces the ideas or concept.  [link:#[Example^]]

There should be a maximum of three iterations of this cycle in any module.


== Principles 

We use a set of principles which we apply to our teaching. These are not rules, but guidelines which we use to help us create better learning experiences:

* *Lead with concepts*
+ 
Knowledge and skills can be applied more effectively if you understand the concept. It may not be essential to understand what an index is to create a index, but if you do you have a better chance of being able to interpret the results (and how to troubleshoot when things go wrong). 
+
If you understand the concepts its a lot easier to apply the learning to something else.
* *Make concrete*
+ 
Many of the concepts our users need to understand are abstract and hard to understand. We make these concrete (or solid) through examples, providing context, use cases and relate them to the real world. 
+
Why is a vector index helpful? Because it helps you to find meaning in unstructured data, for example finding similar customer queries (or movie plots).
* *Unplug, unpack, repack*
+
Semantic waves - take the concept out (unplug) of the immediate need of the learner, unpack the terminology and make it simpler for them to understand, provide examples which are relatable, repack it by relating the examples back to the concept. 
+
_Graphs are a mathematical structure of vertices and edges used to model relationships between objects. Neo4j models data as a graph allowing you to more effectively understand the relationships between data. Vertices and edges are known as nodes and relationships in Neo4j._
* *Model everything*
+ 
Provide worked and scaffolded examples, live coding, give opportunities to “have a go” or “run the code”, describe not only the input to a solution but the output, show what happens when things don't work. This can also really help build confidence.
* *Challenge misconceptions* (Things that people believe are right but are actually wrong)
+ 
_If I put the data in a graph my query will definitely be faster_. 
+
Understand the common misconceptions and address them. Use notes, tips, highlights. Where you know or expect someone will misunderstand take efforts to spell it out. It takes a long time to dispel a misconception.
* *Get hands on*
+ 
Make things, create something. Research has shown that when someone creates something which is “their own”, they retain the knowledge longer.
* *Add variety*
+
In examples, in ways of teaching. Learning the same thing in different ways or with a different contexts is helpful. You don't just have to have 1 example or 1 guide. When it comes to learning, duplication is ok.
* *Read and explore code first (PRIMM)*
+ This stems from the idea that you learn to read before you learn to write for a good reason. It is easy to consume text which has been written for you, before you have the knowledge, skills and understanding to be able to write your own.

You DONT have to use these all the time, but they are good tools which help.



== PRIMM

PRIMM is a framework for teaching programming which can be useful for introducing new practical tasks in our courses. 

PRIMM stands for:

* **P**redict - what do you think the code will do?
* **R**un - run the code and see what it does
* **I**nvestigate - look at the code and see how it works
* **M**odify - change the code and see what happens
* **M**ake - create your own code based on what you have learned

PRIMM allows learners to move from being passive consumers of code to active creators. It encourages them to think critically about the code they are working with and to develop their own solutions.

An objective is to give learners agency, PRIMM moves them through the stages of:

- Not mine (Predict, Run, Investigate)
- Mine (Modify)
- All mine (Make)

read::Move On[]

[.summary]
== Summary

In this lesson, you learned about the GraphAcademy pedagogy and learning approach, including the iterative learning cycle and the principles we apply to our teaching.

In the next lesson, you will learn about the tone and style of GraphAcademy content, and how to create engaging and effective learning experiences.