= Unwinding Lists
:type: quiz
:sandbox: true

//[.video]
//video::ImKvXY72SA0[youtube,width=560,height=315]

//[.transcript]
== Using UNWIND

You have learned that in a query, you can create lists of nodes, strings, or numbers using collect().
Sometimes it is useful to collect elements as intermediate results that are passed on to a later part of a query.
For example, the graph  you are working with contains languages and countries lists for each Movie node.
If you wanted to refactor the graph to create a Language node and associate it with any Movie node that had that particular language in its languages list, you could unwind the list to access each element in the list.

`UNWIND` returns a row for each element of a list.

Here is an example:

[source,cypher]
----
MATCH (m:Movie)-[:ACTED_IN]-(a:Actor)
WHERE a.name = 'Tom Hanks'
UNWIND m.languages AS lang
RETURN m.title AS Movie, m.languages AS Languages, lang AS Language
----

In this query a Movie is retrieved that Tom Hanks acted in.
The languages property, which is a list is unwound and each value is referenced as lang.
The rows returned will be the movie title and the languages property repeated for multiple rows and the lang value.
In this code,  you could imagine that you could create a Language node with a name property which is lang.

Let's now look at a more useful example.

[source,cypher]
----
MATCH (m:Movie)
UNWIND m.languages AS lang
WITH m, trim(lang) AS language
// this automatically, makes the language distinct because it's a grouping key
WITH language, collect(m.title) AS movies
RETURN language, movies[0..10]
----

This query retrieves all Movie nodes.
For each Movie node, it unwinds the languages list to create a list called lang.
Notice  that we use the trim() function to ensure there are no extraneous whitespace characters in the language name.
Then  we use the element of the list to find all Movies that use that language.
Finally, we return a row that contains each language name and the list of up to 10 movie titles for that language.

== Check your understanding

include::questions/1-complete-query.adoc[leveloffset=+1]
include::questions/2-select-answer.adoc[leveloffset=+1]

[.summary]
== Summary

In this lesson, you learned how  `UNWIND` can be used to create intermediate results that can be used for pipelining queries.

In the next challenge, you will modify a query that uses `UNWIND`.

