= Challenge: Projection modeling and analysis
:type: challenge
:order: 5
:sandbox: true

[.transcript]
== Introduction

In the previous lesson, you learned how to design projections based on analytical questions. Now it's time to apply that skill independently.

You'll be given an analytical question, and you need to:

. Design an appropriate projection
. Choose a suitable algorithm
. Run the analysis
. Interpret the results


== Your analytical question

**"Which directors have the most influence in the film industry based on their actor collaborations?"**

This question requires you to think about:

- What does "influence" mean in this context?
- What node types should appear in your projection?
- What relationships capture the concept of influence?
- Which algorithm can measure influence?

== Your task

=== Step 1: Design your projection

Design a projection called `'director-influence'` that captures director influence through actor collaborations.

**Consider:**

- Directors who work with the same actors might be in similar circles
- Influence could be measured by how many actors a director has worked with
- Or influence could be about being a "bridge" between different actor groups

**Ask yourself:**

- Should this be monopartite (Director -> Director) or bipartite (Director -> Actor)?
- Do you need to infer relationships or project existing ones?
- Should relationships be weighted? If so, by what?

Make sure you refer to the link:https://neo4j.com/docs/graph-data-science/current/algorithms/[algorithm docs] if you are uncertain.

=== Step 2: Build your projection

Write the Cypher projection query and verify it was created successfully using `gds.graph.list()`.


=== Step 3: Choose and run an algorithm

Based on your projection design and the question about "influence," choose an appropriate algorithm from:

- **Degree Centrality**: Counts direct connections (link:https://neo4j.com/docs/graph-data-science/current/algorithms/degree-centrality/[Degree centrality docs])
- **PageRank**: Measures importance through connections to important nodes (link:https://neo4j.com/docs/graph-data-science/current/algorithms/page-rank/[PageRank docs])
- **Betweenness Centrality**: Measures bridge positions in the network (link:https://neo4j.com/docs/graph-data-science/current/algorithms/betweenness-centrality/[Betweenness centrality docs])

Run your chosen algorithm in `stream` mode and return the top 10 directors with the most influence.

Remember to use `gds.util.asNode()` or `gds.util.asNodeProperty()` to access director names and other properties in your results.

=== Step 4: Validate your results

Check your top results. Do they make sense? Are well-known, prolific directors ranking highly?


== Hints

**Projection design hint:**

Think about whether you want to measure:

- Direct connections (how many actors a director has worked with)
- Network position (how "central" a director is in the collaboration network)
- Bridge positions (directors who connect or 'control' the flow of information between different communities)


== Solution approach

[%collapsible]
====
**Step 1: Design the projection**

For measuring director influence through actor collaborations, a **monopartite Director-Director projection** works best. Directors who share actors are connected, and we can use centrality algorithms to measure influence.

**Step 2: Build the projection**

[source,cypher]
.Solution: Project director-director network through shared actors
----
MATCH (source:Person)-[:DIRECTED]->(:Movie)<-[:ACTED_IN]-(a:Actor)
      -[:ACTED_IN]->(:Movie)<-[:DIRECTED]-(target:Person)
WHERE source <> target
WITH gds.graph.project(
  'director-influence',
  source,
  target
) AS g
RETURN g.graphName AS graph, g.nodeCount AS nodes, g.relationshipCount AS rels
----

**Projection breakdown**

1. Match Person nodes (directors) connected through Movies with shared Actors
2. Filter out self-connections
3. Call the GDS projection function
4. Name the projection 'director-influence'
5. Include source (Person/Director) nodes
6. Include target (Person/Director) nodes
7. Return projection statistics

**Key components:**

- The pattern `Director -> Movie <- Actor -> Movie <- Director` connects directors who worked with the same actors
- This creates a monopartite director network
- The more actors two directors share, the more relationships connect them

**Step 3: Run PageRank**

[source,cypher]
.Solution: Run PageRank to measure director influence
----
CALL gds.pageRank.stream(
  'director-influence'
)
YIELD nodeId, score
RETURN 
  gds.util.asNode(nodeId).name AS director,
  score AS influence
ORDER BY influence DESC
LIMIT 10
----

**Algorithm breakdown**

1. Call PageRank in stream mode
2. Run on 'director-influence' projection
3. Yield node IDs and PageRank scores
4. Convert node IDs to director names
5. Return director name and influence score
6. Sort by influence in descending order
7. Limit to top 10 directors

**Alternative: Degree Centrality**

You could also use Degree Centrality for a simpler measure of influence:

[source,cypher]
.Alternative: Use Degree Centrality
----
CALL gds.degree.stream(
  'director-influence'
)
YIELD nodeId, score
RETURN 
  gds.util.asNode(nodeId).name AS director,
  score AS actor_connections
ORDER BY actor_connections DESC
LIMIT 10
----

**What the results mean:**

- **PageRank**: Directors with high scores are influential because they're connected to other influential directors (those who work with many actors)
- **Degree Centrality**: Directors with high scores have worked with many actors who also worked with other directors
- Both metrics reveal directors who are well-connected in the Hollywood collaboration network
====


[.quiz]
== Check your understanding

include::questions/1-monopartite-vs-bipartite.adoc[leveloffset=+1]

include::questions/2-projection-question-match.adoc[leveloffset=+1]

include::questions/3-algorithm-assumptions.adoc[leveloffset=+1]


[.summary]
== Summary

You've completed a full GDS analysis workflow starting from an analytical question. This is how real-world GDS projects begin: with a question that drives projection design, algorithm selection, and result interpretation.

The key skill is recognizing that the same data can be projected in multiple ways, and the right projection depends on what you're trying to measure.

In the next lesson, you'll recap everything you've learned in this module.


