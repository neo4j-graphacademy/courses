= Module recap
:type: lesson
:order: 6

[.transcript]
== What you've learned

You now understand how to work with GDS algorithms at a fundamental level.


=== Algorithm categories

GDS provides 40+ algorithms across five categories:

- **Centrality** - Identify important or influential nodes (Degree, PageRank, Betweenness)
- **Community Detection** - Find natural clusters and groups (Louvain, Leiden, Label Propagation)
- **Pathfinding** - Discover optimal routes through networks (Dijkstra)
- **Similarity** - Find structurally similar nodes (Node Similarity, FastRP)
- **Embeddings** - Create vector representations of nodes (FastRP, GraphSAGE)


=== Five execution modes

You learned that every algorithm supports five modes:

- **Stats** - Get summary statistics without individual results
- **Stream** - View results directly without storing them
- **Mutate** - Store results in the projection for chaining algorithms
- **Write** - Persist results back to the database
- **Estimate** - Check memory requirements before running

Each mode serves a different purpose in your workflow. You practiced using stats and stream for exploration, and learned when to use mutate for algorithm chaining.


=== Working with Algorithm Results

You learned to use GDS utility functions to work with algorithm outputs:

- **`gds.util.asNode()`** - Convert GDS node IDs to database nodes for property access
- **`gds.util.nodeProperty()`** - Access specific properties directly
- **`gds.util.asNodes()`** - Convert multiple node IDs at once

These functions are essential when working in stream mode, allowing you to retrieve node names, properties, and other attributes from algorithm results.


=== Reading GDS documentation

You can now independently learn any GDS algorithm by understanding how to read the documentation:

- **Introduction** - Understand the algorithm's purpose and when to use it
- **Syntax** - Find required parameters and modes
- **Configuration** - Explore customization options
- **Attributes** - Check whether the algorithm supports directed, undirected, weighted, or heterogeneous graphs


=== Algorithm configuration

You practiced customizing algorithms with both universal and algorithm-specific configurations:

- **Universal options**: `nodeLabels`, `relationshipTypes`, `concurrency`
- **Orientation options**: `undirectedRelationshipTypes` for making relationships bidirectional
- **Weight options**: `relationshipWeightProperty` to use weighted relationships
- **Algorithm-specific options**: `dampingFactor` for PageRank, `gamma` and `theta` for Leiden

You ran algorithms with different configurations to see how they affect results:

- **Directed vs. Undirected**: Compared PageRank on directed and undirected actor networks
- **Unweighted vs. Weighted**: Ran Leiden with and without rating weights
- **Configuration tuning**: Experimented with Leiden's resolution parameters


=== Relationship aggregation

You learned how to aggregate multiple relationships during projection using `count(r)`:

- **What it does**: Collapses parallel relationships into single weighted relationships
- **Why it matters**: Reduces graph size while preserving connection strength
- **When to use it**: When multiple relationships represent repeated interactions (actor collaborations, shipment frequency)

You practiced building aggregated projections for actor collaboration networks, director-actor networks, and user-genre networks.


=== Projection modeling

You learned to design projections based on analytical questions:

- **Start with the question**: "Which actors are most influential?" or "Which directors work in the same circles?"
- **Choose node types**: Monopartite (Actor -> Actor) or Bipartite (User -> Movie)
- **Determine relationships**: Direct, inferred, weighted, or aggregated
- **Select the algorithm**: Match algorithm assumptions to your projection structure

You practiced designing projections for centrality, community detection, and influence questions, understanding that the same data can be projected different ways depending on what you're trying to measure.


== The skills you have

You can now:

1. Understand what GDS algorithms do and when to use them
2. Read GDS documentation independently to learn new algorithms
3. Choose the right execution mode for your workflow
4. Use utility functions to access node properties from results
5. Configure algorithms for directed, undirected, and weighted relationships
6. Aggregate relationships during projection to create meaningful weights
7. Design projections that match your analytical questions
8. Run complete GDS workflows from question to projection to analysis


== What's Next: Real-World Applications

Congratulations! You've completed **Getting Started with Graph Data Science**.

You now have a strong foundation in GDS fundamentals. You understand how to:

- Create projections tailored to analytical questions
- Choose appropriate algorithms for different problem types
- Configure algorithms with orientation, weights, and parameters
- Interpret and work with algorithm results
- Read GDS documentation independently

Ready to try these skills in a real-world scenario?

Continue with link:https://graphacademy.neo4j.com/courses/gds-applied-algorithms/[**Applied Algorithms in GDS**^], where you'll explore real-world use cases:

- **Manufacturing Optimization** - Root cause analysis using centrality and community detection
- **Fraud Detection** - Network-based fraud identification
- **Supply Chain Logistics** - Route optimization with pathfinding algorithms
- **Citation Networks** - Find influential papers within a large graph

Each module demonstrates when and why specific algorithms work, showing you not just *how* to run them, but *when* and *why* professionals choose specific approaches for complex problems.


[.summary]
== Summary

You've completed the foundational course in Graph Data Science! You've learned algorithm categories, execution modes, utility functions, configuration, relationship aggregation, and projection modeling.

Continue your journey with link:https://graphacademy.neo4j.com/courses/gds-applied-algorithms/[Applied Algorithms in GDS^] to see these techniques solve real-world problems across industries.

read::Mark this lesson complete[]
