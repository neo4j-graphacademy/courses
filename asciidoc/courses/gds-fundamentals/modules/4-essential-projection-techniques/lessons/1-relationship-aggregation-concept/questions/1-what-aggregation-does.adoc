[.question]
= Understanding relationship aggregation

Robert De Niro and Joe Pesci appeared in 4 movies together. Without aggregation, your actor collaboration projection would have 4 separate relationships between them.

What does relationship aggregation with `count(r)` do?

* [ ] It removes all but one relationship and discards the collaboration count
* [ ] It averages the properties of the 4 relationships into a single relationship  
* [x] It creates 1 relationship with a weight property representing the count of 4
* [ ] It validates that exactly 4 collaborations exist before proceeding

[TIP,role=hint]
.Hint
====
Think about what "aggregation" means and what information needs to be preserved when collapsing multiple relationships.
====

[TIP,role=solution]
.Solution
====
**It creates 1 relationship with a weight property representing the count of 4.**

Relationship aggregation collapses parallel relationships while preserving the count as a weight:

**Without aggregation:**
```
(De Niro)-[:COLLABORATED]->(Pesci)  // Movie 1
(De Niro)-[:COLLABORATED]->(Pesci)  // Movie 2
(De Niro)-[:COLLABORATED]->(Pesci)  // Movie 3
(De Niro)-[:COLLABORATED]->(Pesci)  // Movie 4
```

**With aggregation using count(r):**
```
(De Niro)-[:COLLABORATED {rels: 4}]->(Pesci)
```

The key benefits:

- **Reduces graph size**: 1 relationship instead of 4
- **Preserves information**: The `rels: 4` property captures collaboration frequency
- **Improves performance**: Algorithms traverse fewer relationships
- **Enables weighted analysis**: Algorithms can use `rels` as a connection strength measure

The pattern is: `WITH source, target, count(r) AS rels` before projecting, then project with `{relationshipProperties: {rels: rels}}`.
====


