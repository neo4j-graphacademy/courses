[.question]
= Chaining graph operations

In Task 3, you dropped all graphs at once by chaining `gds.graph.list()` and `gds.graph.drop()` in a single query.

Why does this pattern work?

* [ ] GDS has a special "drop all" function that runs automatically
* [x] The `graphName` output from `list()` becomes the input to `drop()` for each graph
* [ ] Cypher automatically detects when you want to drop multiple graphs
* [ ] The `YIELD` clause tells GDS to process all graphs in batch mode

[TIP,role=hint]
.Hint
====
Look at the query structure: what does `YIELD graphName` from `list()` provide to the next `CALL` statement?
====

[TIP,role=solution]
.Solution
====
**The `graphName` output from `list()` becomes the input to `drop()` for each graph.**

This is a fundamental Cypher pattern: using the output of one procedure as input to another.

Here's how it works:

1. `gds.graph.list()` returns a row for each graph with its `graphName`
2. For each row, the `graphName` value is passed to `gds.graph.drop()`
3. Each graph gets dropped individually, but within a single query

This pattern is powerful because:

- You don't need to know graph names in advance
- You can filter or transform data between operations  
- You can build complex workflows in a single query

You'll use this chaining pattern frequently when working with GDS: listing graphs to check memory, filtering by properties, then operating on the filtered results.
====


