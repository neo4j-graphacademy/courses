= Challenge: Clean your catalog
:type: challenge
:order: 10
:sandbox: true

[.transcript]
== Challenge: Managing your catalog

Throughout this module, you've created many graph projections for learning purposes. Now it's time to practice good memory management by cleaning up your catalog.

Before you begin, let's recap what you've learned about graph catalog operations:


== Quick Recap

You've learned three essential operations for managing graphs in the catalog.

**Listing graphs** shows you all projections currently in memory:

[source,cypher]
.List all graphs with details
----
CALL gds.graph.list() // <1>
YIELD graphName, nodeCount, relationshipCount, memoryUsage // <2>
RETURN graphName, nodeCount, relationshipCount, memoryUsage // <3>
----

1. Call the graph list procedure
2. Yield graph statistics including memory usage
3. Return the graph information

**Checking existence** verifies whether a specific graph is available:

[source,cypher]
.Check if a graph exists
----
CALL gds.graph.exists('graph-name') // <1>
YIELD graphName, exists // <2>
RETURN graphName, exists // <3>
----

1. Call the exists procedure with a graph name
2. Yield the graph name and existence status
3. Return the result

**Dropping graphs** removes them from memory and frees up resources:

[source,cypher]
.Drop a graph
----
CALL gds.graph.drop('graph-name') // <1>
YIELD graphName, memoryUsage // <2>
RETURN graphName, memoryUsage // <3>
----

1. Call the drop procedure with a graph name
2. Yield the graph name and memory freed
3. Return the dropped graph information

Now let's put these operations to work.


== Your Challenge

Complete the following tasks to clean up your graph catalog:

**Task 1:** List all graphs currently in your catalog and note how much memory they're using.

**Task 2:** Drop one graph from your catalog to practice the basic operation.

**Task 3:** Now drop all remaining graphs at once using a single query. You'll need to combine list and drop operations.

**Task 4:** Verify that your catalog is empty by listing all graphs again.


== Hints

For Task 1, you'll want to see the `memoryUsage` field to understand how much space each graph is consuming.

For Task 2, choose any graph and drop it using `gds.graph.drop()`.

For Task 3, here's a template to help you drop all remaining graphs at once. Think about how you can use the output from one operation as input to another:

[source,cypher,role=nocopy noplay]
.Drop all graphs at once (replace ?????)
----
CALL gds.graph.?????() // <1>
YIELD ????? // <2>
CALL gds.graph.?????(?????) // <3>
YIELD graphName AS droppedGraph // <4>
RETURN droppedGraph // <5>
----

1. Call the graph list procedure (fill in procedure name)
2. Yield the graph name (fill in field name)
3. Call the drop procedure with the graph name (fill in procedure and parameter)
4. Yield the dropped graph name
5. Return the list of dropped graphs

For Task 4, when you list graphs after dropping them all, you should see an empty result.


== Solution

[%collapsible]
====
**Task 1: List all graphs**

[source,cypher]
.Solution: List all graphs with memory usage
----
CALL gds.graph.list() // <1>
YIELD graphName, nodeCount, relationshipCount, memoryUsage // <2>
RETURN graphName, nodeCount, relationshipCount, memoryUsage // <3>
ORDER BY graphName ASC // <4>
----

1. Call the graph list procedure
2. Yield graph statistics including memory usage
3. Return the graph information
4. Sort by graph name alphabetically

This shows you all graphs in your catalog with their memory usage.

**Task 2: Drop one graph**

[source,cypher]
.Solution: Drop a single graph
----
CALL gds.graph.drop('actor-collaboration') // <1>
YIELD graphName, memoryUsage // <2>
RETURN graphName, memoryUsage // <3>
----

1. Call the drop procedure to remove 'actor-collaboration'
2. Yield the graph name and memory freed
3. Return the dropped graph information

Choose any graph name from your catalog. The procedure returns information about the dropped graph.

**Task 3: Drop all remaining graphs at once**

[source,cypher]
.Solution: Drop all graphs
----
CALL gds.graph.list() // <1>
YIELD graphName // <2>
CALL gds.graph.drop(graphName) // <3>
YIELD graphName AS droppedGraph // <4>
RETURN droppedGraph // <5>
----

1. Call the graph list procedure
2. Yield each graph name
3. Drop each graph by piping the name to the drop procedure
4. Yield the dropped graph name
5. Return the list of all dropped graphs

This query lists all graphs and drops each one in a single operation. The key insight is that you can use the `graphName` output from `list()` as the input to `drop()`.

**Task 4: Verify catalog is empty**

[source,cypher]
.Solution: Verify all graphs are gone
----
CALL gds.graph.list() // <1>
YIELD graphName // <2>
RETURN graphName // <3>
----

1. Call the graph list procedure
2. Yield graph names
3. Return graph names (should be empty)

This should return no results, confirming all graphs have been removed.

**Key takeaway:** Chaining operations like this is a powerful pattern in Cypher. You can use the output of one procedure as input to another, enabling complex workflows in a single query.
====


[.quiz]
== Check your understanding

include::questions/1-chaining-operations.adoc[leveloffset=+1]


[.summary]
== Summary

You've successfully cleaned up your graph catalog by listing all graphs, dropping them to free memory, and verifying they're gone. These operations are essential for efficient memory management in production workflows.

You've now completed all the fundamental concepts: projections, graph types, and catalog management. In the next module, you'll dive deep into GDS algorithmsâ€”learning how to read documentation, configure settings, and model projections for specific analytical questions.

