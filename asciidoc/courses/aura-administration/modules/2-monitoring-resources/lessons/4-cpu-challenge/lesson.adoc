=  CPU Crisis
:type: challenge
:order: 4


== Scenario

It's Monday morning at 9:15 AM, and you receive alerts that the application is experiencing severe slowness.

Checking the Metrics dashboard, you observe:

* **CPU Usage**: Spiked to 8 cores (100% of available) at 9:00 AM and has stayed there
* **Query Rate**: 3,000 queries/minute (normal peak is 1,200)
* **Failed Queries**: 15% of queries failing (normally <0.1%)

Looking at query logs filtered for "last 15 minutes":

* A new query pattern started at 9:00 AM: `MATCH (u:User) MATCH (p:Product) WHERE u.region = p.region RETURN count(*)`
* This query is being executed 500+ times per minute
* Each execution takes 2,000-5,000ms (normally queries take 10-50ms)
* The query was introduced in a deployment Friday evening


include::questions/1-cpu-crisis.adoc[leveloffset=+1]


[.summary]
== Summary

When a specific query is causing resource exhaustion, the fastest recovery is to stop the problematic application behavior.

Why this is the best approach:

* **Immediate relief**: Stopping the queries frees CPU resources within seconds
* **No downtime**: Instance remains available for other operations
* **Preserves data**: No risk of data loss from scaling operations
* **Time to fix**: Allows proper query optimization before re-deployment

The problematic query has a Cartesian product (`MATCH (u:User) MATCH (p:Product)`) that's creating massive intermediate results.

After stopping the deployment:

1. Work with developers to add proper relationship or optimize with `WITH` clause
2. Test the fixed query in a test environment
3. Monitor resource usage during re-deployment
4. Consider scaling if baseline usage is high even after fix

