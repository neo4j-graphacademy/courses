=  Garbage Collection Impact
:type: challenge
:order: 8


== Scenario

Your company runs a customer-facing recommendation engine powered by Neo4j.

Users are complaining about "the app freezing for a few seconds randomly."

Investigating the Instance metrics:

* **Total GC Time**: 8% of runtime
* **Young Gen GC**: 3% (frequent, every few seconds)
* **Old Gen GC**: 5% (occurring every 5-10 minutes, each taking 3-5 seconds)
* **Heap Memory Usage**: 88-92% consistently
* **Page Cache Hit Ratio**: 99%
* **CPU Usage**: 70%

Correlation with user complaints:

* Complaints align with timing of Old Gen GC events
* During GC, all queries pause
* Users experience 3-5 second delays


== The Challenge

What will eliminate the user-facing freezes?


include::questions/1-gc-impact.adoc[leveloffset=+1]


[.summary]
== Summary

Old Gen GC pauses directly impact user experience when heap usage is too high. Scale the instance to reduce heap pressure and eliminate user-facing freezes

**Why scaling helps:**

* More heap memory reduces memory pressure
* Old Gen GC becomes less frequent
* When it does run, it completes faster
* Heap usage drops to healthier 60-70% range

**Heap usage targets:**

* **Healthy**: 30-70% normal, spikes to 80% acceptable
* **Warning**: 80-85% sustained
* **Problem**: >85% sustained (causes excessive GC)

**Alternative approach** (if scaling isn't immediate option):
* Review query logs for memory-intensive queries
* Optimize queries that create large intermediate results
* Reduce concurrent query execution

But scaling is usually the most effective solution for sustained high heap usage

This scenario demonstrates how GC metrics directly correlate with user experience.

