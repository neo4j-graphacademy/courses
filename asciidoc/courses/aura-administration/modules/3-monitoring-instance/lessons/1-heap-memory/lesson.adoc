= Heap Memory Usage
:type: lesson
:order: 1


[.discrete]
== Introduction

The heap is a critical memory area where Neo4j stores temporary data during query execution and transaction processing.

In this lesson, you'll learn how to monitor heap memory usage and identify when memory pressure is affecting your performance.


== Understanding Heap Memory

// UI Description: The percentage of configured heap memory in use. The heap space is used for query execution, 
// transaction state, management of the graph etc. The size needed for the heap is very dependent on the nature 
// of the usage of Neo4j. For example, long-running queries, or very complicated queries, are likely to require 
// a larger heap than simpler queries. To improve performance, the heap should be large enough to sustain 
// concurrent operations. This value should not exceed 80% for long periods, short spikes can be normal. 
// In case of performance issues, you may have to tune your queries, and monitor their memory usage, to determine 
// whether the heap needs to be increased. If the workload of Neo4j and performance of queries, indicates that 
// more heap space is required, consider increasing the size of your instance. This helps avoid unwanted pauses 
// for garbage collection.

The heap is used for:

* Query execution and result building
* Transaction state management
* Caching query plans
* Graph algorithm computations
* Internal data structures


The amount of heap memory needed depends on:

* Query complexity
* Number of concurrent queries
* Transaction size
* Working set size


== Reading the Heap Memory Metric

The Heap Memory metric shows the **percentage of configured heap memory in use**.

The chart displays:

* Current heap usage as a percentage
* Historical heap usage patterns
* Trends over the selected time period


=== Healthy Heap Usage

Normal heap usage patterns:

* **Baseline usage**: 20-50% during regular operations
* **Query peaks**: Temporary spikes to 60-80% during complex queries
* **Recovery**: Returns to baseline after query completion

[TIP]
.Understanding heap spikes
====
Occasional spikes to 70-80% are normal, especially during complex queries.

The concern is sustained high usage, not temporary peaks.
====


== Identifying Memory Issues


=== Sustained High Usage (>80%)

If your heap usage stays above 80% for extended periods, you've got an issue:

* Your queries may be consuming too much memory
* The instance might be under-provisioned for your workload
* There could be memory leaks (though this is rare)

**Impact**:

* Increased garbage collection frequency
* Slower query execution
* Risk of out-of-memory errors


=== Constantly Near 100%

Heap usage consistently near 100% indicates:

* Immediate memory pressure
* Queries may fail with out-of-memory errors
* Performance is severely degraded
* Garbage collection is constant

**Action required**: This requires immediate investigation and likely instance scaling.


=== Memory Spikes with Poor Recovery

If heap usage spikes and doesn't return to baseline:

* Memory is not being released properly
* Long-running transactions may be holding memory
* Query result sets may be too large

**Action required**: Review query patterns and transaction management.


== When to Scale Your Instance

Consider increasing instance size when:

* Heap usage consistently exceeds 80%
* Queries fail with out-of-memory errors
* Performance is degraded despite query optimization

Garbage collection time is excessive (covered in the next lesson)

[WARNING]
.Scaling isn't always the answer
====
Here's an important point: scaling gives you more heap memory, but inefficient queries will eventually consume any amount of memory you throw at them.

Always investigate your query patterns before you scale.
====


== Optimizing Heap Usage

Before scaling, try these optimization strategies:


=== Query Optimization

* Avoid returning large result sets - use `LIMIT` clauses
* Use aggregations instead of collecting all results
* Break complex queries into smaller operations
* Stream results when possible using drivers


=== Transaction Management

* Keep transactions short-lived
* Avoid holding transactions open for extended periods
* Commit or rollback transactions promptly
* Use explicit transactions only when necessary


=== Query Pattern Changes

* Paginate large result sets
* Avoid collecting all nodes/relationships in memory
* Use `CALL {} IN TRANSACTIONS` for batch operations
* Process data in smaller chunks


=== Workload Distribution

* Spread complex queries across time instead of running concurrently
* Schedule heavy operations during off-peak hours
* Limit concurrent complex query execution
* Use queue systems for background processing


== Monitoring Heap for Different Scenarios


=== Normal Operations

* Heap usage: 30-60%
* Occasional spikes to 70%
* Quick recovery to baseline


=== Complex Query Execution

* Temporary spike to 70-80%
* Returns to baseline within seconds/minutes
* Expected and healthy behavior


=== Memory Pressure

* Sustained usage >80%
* Slow or no recovery
* Requires investigation


=== Memory Crisis

* Usage constantly 95-100%
* Queries failing
* Requires immediate action


[.quiz]
== Check Your Understanding

include::questions/1-heap-threshold.adoc[leveloffset=+1]


[.summary]
== Summary

You now know how to monitor heap memory usage for your Aura instances.

You've learned to identify normal heap usage patterns, recognize memory pressure, and determine when you need to scale your instance or optimize queries.

Remember: heap usage shouldn't exceed 80% for long periods. Sustained high usage means you need optimization or scaling.

In the next lesson, you'll learn about page cache metrics and how they affect query performance.

