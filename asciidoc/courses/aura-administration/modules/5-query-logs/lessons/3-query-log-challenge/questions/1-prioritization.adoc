[.question]
= Query Optimization Priority

Users report "the application has been slow since 9 AM." It's now 11 AM.

Query logs Summary tab (last 3 hours, sorted by total time spent):

| Query | Count | Total Time | Avg Time | Max Time |
|-------|-------|------------|----------|----------|
| A: `MATCH (u:User)-[:FRIEND*]->(f) RETURN f.name` | 2,500 | 375min | 9,000ms | 12,000ms |
| B: `MATCH (p:Product) WHERE p.price > $min RETURN p` | 15,000 | 75min | 300ms | 800ms |
| C: `MATCH (o:Order {id: $id}) RETURN o` | 10,000 | 5min | 30ms | 50ms |

Which query should you prioritize optimizing for the biggest impact?

* [ ] Query C - highest execution count

* [ ] Query B - good candidate for indexing

* [x] Query A - consumes most total database time

* [ ] All three need equal attention

[TIP,role=hint]
.Hint
====
Calculate frequency × duration = total impact. Which query is using the most database resources overall?
====

[TIP,role=solution]
.Solution
====
**Query A - consumes most total database time** is correct.

**Total impact calculation**:

**Query A**: 2,500 executions × 9 seconds = 22,500 seconds = **375 minutes**. These are the slowest queries (9 seconds each) with moderate frequency (2,500 times), creating a MASSIVE total impact (6+ hours of database time!).

**Query B**: 15,000 executions × 0.3 seconds = 4,500 seconds = **75 minutes**. These are fast queries (300ms each) with very high frequency (15,000 times), creating a moderate total impact.

**Query C**: 10,000 executions × 0.03 seconds = 300 seconds = **5 minutes**. These are very fast queries (30ms each) with high frequency (10,000 times), creating minimal total impact (performing excellently!).

**Priority**: Query A → Query B → Query C (already fine)

**Why Query A is the problem**:

[source,cypher]
----
// The problematic query
MATCH (u:User)-[:FRIEND*]->(f) RETURN f.name
// No maximum depth on variable-length path = DISASTER
----

**The fix**:
[source,cypher]
----
// Option 1: Add maximum depth
MATCH (u:User)-[:FRIEND*..3]->(f) RETURN f.name

// Option 2: Use specific depth
MATCH (u:User)-[:FRIEND]->()-[:FRIEND]->(f) RETURN f.name
----

**Expected improvement**: Query A execution time drops from 9,000ms to ~50ms (180x faster!), total impact drops from 375 minutes to 2 minutes (saving **373 minutes/day**), and user experience is dramatically improved.

**After fixing Query A**, then optimize Query B:
[source,cypher]
----
// Add index if not exists
CREATE INDEX product_price FOR (p:Product) ON (p.price)
----

**Query C**: Leave it alone - 30ms is excellent performance!

**Key lesson**: Optimize by **total impact** (frequency × duration), not just by how slow or how frequent. A moderately slow query running frequently can have bigger impact than a very slow query running rarely.
====

