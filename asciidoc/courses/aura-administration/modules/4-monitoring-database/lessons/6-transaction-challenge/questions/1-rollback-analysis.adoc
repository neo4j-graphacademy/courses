[.question]
= High Rollback Rate Diagnosis

Users report "random save failures" when creating records.

Transaction metrics:

. Committed: 200/minute (normal)
. Rollbacks: 40/minute (20% of commits - HIGH)
. Failed queries: 35/minute (matches rollback rate)

Query logs (status: failed):
----
CREATE (p:Product {id: $productId, name: $name, sku: $sku})
Error: Constraint violation: Node with property 'id' = '12345' already exists
----

Application logs show users clicking "Save" multiple times when the form is slow to respond.

What's causing this and how should you fix it?

* [ ] Database constraint is too strict - remove it

* [ ] Instance is too slow - scale up

* [x] Application doesn't prevent duplicate submissions - fix the UI

* [ ] Network latency causing duplicate requests

[TIP,role=hint]
.Hint
====
Look at the error message and user behavior. Is this a database problem or an application problem?
====

[TIP,role=solution]
.Solution
====
**Application doesn't prevent duplicate submissions - fix the UI** is correct.

**Root cause analysis**:

**What's happening**:
1. User clicks "Save" on form
2. Response is slow (processing...)
3. User clicks "Save" again (impatient)
4. Application sends both requests
5. First request succeeds (creates Product id=12345)
6. Second request fails (id=12345 already exists!)
7. User sees error message

**Why 20% rollback rate**: Not all users double-click, but many do, which explains the 20% rate (1 in 5 submissions duplicated). This matches the failed query rate exactly, and the constraint is working correctly to prevent duplicates.

**The fix is APPLICATION-SIDE**:

**Option 1**: Disable button after click
[source,javascript]
----
button.onclick = async () => {
  button.disabled = true;  // Prevent double-click
  await saveProduct();
  button.disabled = false;
}
----

**Option 2**: Use idempotent operations
[source,cypher]
----
// Instead of CREATE (fails on duplicate)
MERGE (p:Product {id: $productId})
ON CREATE SET p.name = $name, p.sku = $sku
ON MATCH SET p.updated = timestamp()
----

**Option 3**: Add loading state
[source,javascript]
----
if (isSubmitting) return;  // Prevent double-submission
----

**Why this is correct**: The error message clearly shows a constraint violation, user behavior (double-clicking) causes duplicates, the database is working correctly, and the application needs to handle user behavior.

The other options are wrong: **Removing constraint** would allow duplicate data (bad!), **Scaling** doesn't prevent duplicate submissions, and **Network** issues would cause other symptoms, not just duplicates.

**Key principle**: High rollback rates usually indicate application logic issues, not database problems. The constraint is protecting data integrity - fix the application to prevent duplicate submissions.
====

