[.question]
= Percentile-Based Optimization

Users complain "reports are slow."

Database metrics (last 24 hours):

. Queries/min: 800 (normal)
. Failed queries: 2-3/min (<1%, normal)
. 50th percentile: 45ms (acceptable)
. 75th percentile: 120ms (acceptable)
. 99th percentile: 8,500ms (concerning)

Query logs filtered for duration >5000ms show the same 3 dashboard queries repeatedly, each returning 50,000+ rows.

How should you address this?

* [ ] Scale instance - overall performance is degraded

* [x] Optimize the 3 specific slow queries identified in logs

* [ ] Reduce query frequency to lower load

* [ ] Add more indexes across the database

[TIP,role=hint]
.Hint
====
Compare the median query time to the 99th percentile. What does the gap tell you about whether this is a systemic or specific issue?
====

[TIP,role=solution]
.Solution
====
**Optimize the 3 specific slow queries identified in logs** is correct.

**Reading the percentiles**:

**The story the metrics tell**: 50% of queries are <45ms (EXCELLENT), 75% of queries are <120ms (GOOD), and 99% of queries are <8,500ms (but that 1% are VERY slow).

**Gap analysis**: Median to 99th percentile shows 45ms â†’ 8,500ms (189x difference!). This massive gap means most queries are fine, but specific queries are terrible.

**Evidence**: Query logs show 3 specific dashboard queries, the same queries repeatedly appearing, each returning 50,000+ rows. These are the slow 1%.

**Optimization strategy**:
1. **Identify**: Already done - 3 dashboard queries
2. **Analyze**: Likely issues:
   ```cypher
   // Probably returning too much data
   MATCH (u:User)-[:PURCHASED]->(p:Product)
   RETURN u, p  // Returns 50,000+ rows!
   ```
3. **Fix**: Add pagination
   ```cypher
   MATCH (u:User)-[:PURCHASED]->(p:Product)
   RETURN u, p
   ORDER BY p.date DESC
   SKIP $offset LIMIT 100
   ```
4. **Measure**: Verify improvement in 99th percentile

**Expected results after fix**: 99th percentile drops from 8,500ms to 200ms, user complaints stop, and the 99% of users who were already happy are joined by the last 1% who are now fixed.

The other options miss the point: Scaling won't fix poorly written queries, 99% of queries are already fast (instance is fine), reducing frequency doesn't help users who need reports, and random indexing is a shotgun approach (target the specific queries instead).

**Key lesson**: When 99th percentile >> median, you have specific query problems, not systemic performance issues. Fix the outliers.
====

