= Practice multipartite projection
:type: lesson
:order: 7

[.transcript]
== Introduction

Now that you understand bipartite and multipartite graphs, it's time to practice creating projections that preserve multiple node types.

In this lesson, you'll work with the Movies dataset to create various bipartite projections and run node similarity on them—the same algorithm you used in the previous lesson.

By the end of this lesson, you will be able to:

* Create bipartite projections with preserved labels
* Run node similarity on different bipartite structures
* Understand how projection patterns affect algorithm results


== The movies dataset

Your database contains:

- `Actor` nodes with properties like `name` and `born`
- `Movie` nodes with properties like `title` and `released`
- `User` nodes with properties like `name`
- `Genre` nodes with properties like `name`
- `ACTED_IN` relationships (Actor -> Movie)
- `RATED` relationships (User -> Movie)
- `IN_GENRE` relationships (Movie -> Genre)


== Projection 1: User-movie bipartite

Remember this projection you created in the previous lesson? Run this command again to create a bipartite user-movie network:

[source,cypher]
----
MATCH (source:User)-[r:RATED]->(target:Movie)
WITH gds.graph.project(
  'user-movie',
  source,
  target,
  {
    sourceNodeLabels: labels(source),
    targetNodeLabels: labels(target),
    relationshipType: type(r)
  },
  {}
) AS g
RETURN g.graphName AS graph, 
  g.nodeCount AS nodes, 
  g.relationshipCount AS rels
----

This projection creates:

- A bipartite network with User and Movie labels preserved
- Users connected to movies through RATED relationships
- A structure perfect for node similarity

NOTE: In this lesson, you'll use `.write()` mode to persist algorithm results to your database. Module 3 will teach all execution modes in detail—for now, follow the patterns shown in each example.

Now run node similarity on this projection:

[source,cypher]
----
CALL gds.nodeSimilarity.write(
  'user-movie',
  {
    writeRelationshipType: 'SIMILAR',
    writeProperty: 'score'
  })
YIELD nodesCompared, relationshipsWritten
----

Remember from the previous lesson: node similarity connects nodes on the same side of the bipartite graph.

Verify the results:

[source,cypher]
----
MATCH path = (:User)-[:SIMILAR]->(:User)-[:SIMILAR]-(:User)
RETURN path
LIMIT 10
----

**What this reveals:** Users with similar movie rating patterns.


=== Actor-Movie Bipartite

Now, let's create a different bipartite projection: actors and movies with preserved labels.

Copy the code below into the query window and replace `????` with the correct values.

[source,cypher]
----
MATCH (source:????)-[r:????]->(target:????)
WITH ????(
  'actor-movie',
  source,
  target,
  {
    ????,
    ????,
    ????
  },
  {}
) AS g
RETURN g.graphName AS graph, 
  g.nodeCount AS nodes, 
  g.relationshipCount AS rels
----

If you need help finding the solution, you'll find the full projection command in the dropdown below:

[%collapsible]
====

[source,cypher]
----
MATCH (source:Actor)-[r:ACTED_IN]->(target:Movie)
WITH gds.graph.project(
  'actor-movie',
  source,
  target,
  {
    sourceNodeLabels: labels(source),
    targetNodeLabels: labels(target),
    relationshipType: type(r)
  },
  {}
) AS g
RETURN g.graphName AS graph, 
  g.nodeCount AS nodes, 
  g.relationshipCount AS rels
----

====

This projection creates:

- A bipartite network with Actor and Movie labels preserved
- Actors connected to movies through ACTED_IN relationships

Now run node similarity on this projection.

[source,cypher]
----
CALL gds.nodeSimilarity.write(
  'actor-movie',
  {
    writeRelationshipType: 'SIMILAR',
    writeProperty: 'score'
  })
YIELD nodesCompared, relationshipsWritten
----

Verify the results:

[source,cypher]
----
MATCH path = (:Actor)-[:SIMILAR]->(:Actor)-[:SIMILAR]->(:Actor)
RETURN path
LIMIT 10
----

**What this reveals:** Actors who collaborate.


=== Movie-genre bipartite

Now create a bipartite projection of movies and genres, then run node similarity on it—this time, complete both steps yourself.

**Step 1:** Create the projection by replacing the `?????` placeholders:

[source,cypher]
----
MATCH (source:?????)-[r:?????]->(target:?????)
WITH ????(
  '?????',
  source,
  target,
  {
    ????,
    ????,
    ????
  },
  {}
) ????
RETURN ????, 
  ????, 
  ????
----

**Step 2:** Run node similarity on your projection. Replace the graph name and choose a relationship type:

[source,cypher]
----
CALL gds.nodeSimilarity.write(
  'movie-genre',
  {
    writeRelationshipType: 'SIMILAR',
    writeProperty: 'score'
  })
YIELD nodesCompared, relationshipsWritten
----

If you need to see the full command, feel free to open the dropdown below.

[%collapsible]
====
**Step 1: Create the projection**

[source,cypher]
----
MATCH (source:Movie)-[r:IN_GENRE]->(target:Genre)
WITH gds.graph.project(
  'movie-genre',
  source,
  target,
  {
    sourceNodeLabels: labels(source),
    targetNodeLabels: labels(target),
    relationshipType: type(r)
  },
  {}
) AS g
RETURN g.graphName AS graph, 
  g.nodeCount AS nodes, 
  g.relationshipCount AS rels
----

**Key points:**

- Match `Movie` nodes to `Genre` nodes via `IN_GENRE` relationships
- Name the projection `'movie-genre'`
- Preserve labels with `labels(source)` and `labels(target)`
- Run `nodeSimilarity.write` with `'SIMILAR'` as the relationship type
====

Check which movies are similar based on shared genres:

[source,cypher]
----
MATCH (m1:Movie)-[s:SIMILAR]->(m2:Movie)
RETURN m1.title, m2.title, s.score
ORDER BY s.score DESC
LIMIT 10
----

**What this reveals:** Movies that belong to similar genre combinations.


== Comparing algorithm results

Each bipartite projection you created produces different node similarity results because the structure determines what "similarity" means.

**User-Movie projection:** Similarity is based on shared movie ratings (collaborative filtering)

**Actor-Movie projection:** Similarity is based on shared cast members (collaboration patterns)

**Movie-Genre projection:** Similarity is based on shared genre classifications (content-based similarity)

The same algorithm—node similarity—reveals completely different insights depending on your projection structure.

Understanding bipartite and multipartite graphs helps you design projections that answer specific analytical questions.


== What's next

You've now practiced creating multiple bipartite projections from the Movies dataset and running node similarity on each one—consolidating your understanding of how label preservation enables different types of analysis.

Each projection transformed the same data into different analytical contexts:
- User-Movie (collaborative filtering)
- Actor-Movie (collaboration patterns)
- Movie-Genre (content-based similarity)

In the next lesson, you'll put this knowledge to the test with a challenge that requires you to create your own bipartite projection and run node similarity independently.


[.quiz]
== Check your understanding

include::questions/1-projection-affects-similarity.adoc[leveloffset=+1]


[.summary]
== Summary

Bipartite projections with preserved labels enable node similarity to connect nodes on the same side of the graph based on shared neighbors.

You practiced creating three bipartite projections:
- **User-Movie:** Found similar users based on rating patterns
- **Actor-Movie:** Found similar actors based on collaboration patterns  
- **Movie-Genre:** Found similar movies based on genre classifications

The same algorithm—node similarity—reveals completely different insights depending on your projection structure. Understanding how to design meaningful bipartite projections is a fundamental GDS skill for relationship inference and recommendation systems.

