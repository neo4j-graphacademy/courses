= Project a graph
:type: lesson
:order: 2

[.transcript]
== Introduction

In the previous lesson, you learned the three-step GDS workflow: **Project → Run → Write**. You saw how this pattern enables fast, safe, iterative analysis by separating your source data from algorithmic operations.

This lesson focuses exclusively on **Step 1: Projection**—the foundation of all GDS work.

By the end of this lesson, you will understand:

* How Cypher projections work in detail
* What graph structures you're creating when you project
* Why different projection types matter for algorithms


== Cypher Projection Anatomy

Let's revisit the example from the previous lesson and break it down completely.

[source,cypher]
----
MATCH (source:Actor)-[r:ACTED_IN]->(target:Movie)
WITH gds.graph.project(
  'actors-graph',
  source,
  target
) AS g
RETURN g.graphName AS graph, 
  g.nodeCount AS nodes, 
  g.relationshipCount AS rels
----

This projection has three main components:


=== 1. The Cypher Pattern

[source,cypher]
----
MATCH (source:Actor)-[r:ACTED_IN]->(target:Movie)
----

This is standard Cypher. You're matching a pattern in your database:

- `source` nodes with the `Actor` label
- `target` nodes with the `Movie` label  
- `ACTED_IN` relationships connecting them

The variable names `source` and `target` are important—you'll reference them in the projection. 

However, just like the `writeProperty` value we created in the previous lesson, these variables are inherently arbitrary.

We could run the following, equally valid projection:

[source,cypher]
----
MATCH (bananas:Actor)-[:ACTED_IN]->(cabbages:Movie)
WITH gds.graph.project(
  'actors-graph',
  bananas,
  cabbages
) AS g
RETURN g.graphName AS graph, 
  g.nodeCount AS nodes, 
  g.relationshipCount AS rels
----

The variables you use for the nodes in your Cypher query, are the variables you will call as nodes in the graph projection.

image::images/bananas_and_cabbages.png[a Cypher projection, in which the node variables are named 'bananas' and 'cabbages']

As a general standard we use `source` and `target` only because many other projection configuration settings will refer to the first variable as `source` and the second as `target`. 

Defaulting to `source` and `target` for the initial variables just makes it easier to keep track.



=== 2. The projection call

[source,cypher]
----
WITH gds.graph.project(
  'actors-graph',
  source,
  target,
  {},
  {}
) AS g
----

The `WITH` clause pipes your matched pattern into `gds.graph.project()`:

**`'actors-graph'`**: The name you'll use to reference this projection when running algorithms

**`source`**: Nodes matched by your source variable become nodes in the projection

**`target`**: Nodes matched by your target variable also become nodes in the projection

**Relationships**: Automatically inferred from the pattern between source and target

The curly brackets are there to house your other configuration settings. To create a simple projection, you do not need them. In fact, you could rewrite the same projection command without even referencing them.

[source,cypher]
----
WITH gds.graph.project(
  'actors-graph',
  source,
  target
) AS g
----

We include them here just to acknowledge them, and remind you that they still exist in the background.


=== 3. The return statement

You have already dealt with this -- it's really no different from your normal return query when using pure Cypher. 

[source,cypher]
----
RETURN g.graphName AS graph, 
  g.nodeCount AS nodes, 
  g.relationshipCount AS rels
----

This returns metadata about your projection:

- How many nodes were projected
- How many relationships were created
- The graph name for verification


== Try it yourself

Now that you understand how projections work, complete the query below to create a projection of Actors and Movie nodes.

Replace the `?????` placeholders with the correct values:

[source,cypher]
----
MATCH (source:?????)-[r:ACTED_IN]->(target:?????)
WITH gds.graph.project(
  'my-projection',
  ?????,
  ?????
) AS g
RETURN g.graphName AS graph, 
  g.nodeCount AS nodes, 
  g.relationshipCount AS rels
----

Once you've completed the query, run it to verify your projection was created successfully.

If you need help filling in the query, open the dropdown below for the full solution.

[%collapsible]
====
[source,cypher,role=nocopy noplay]
----
MATCH (source:Actor)-[r:ACTED_IN]->(target:Movie)
WITH gds.graph.project(
  'my-projection',
  source,
  target
) AS g
RETURN g.graphName AS graph, 
  g.nodeCount AS nodes, 
  g.relationshipCount AS rels
----

**Key points:**

- `source:Actor` matches Actor nodes
- `target:Movie` matches Movie nodes  
- Pass `source` and `target` variables into `gds.graph.project()`
- The ACTED_IN relationships are automatically inferred from your MATCH pattern
====

== What's next

You now understand how Cypher projections work: you match a pattern with standard Cypher, then pipe it into `gds.graph.project()` to create an in-memory graph.

But there's an important detail about what you've just projected that might surprise you. 

In the next lesson, you'll learn about different graph structure types and discover what type of graph your actors-movies projection actually created.


[.quiz]
== Check your understanding

include::questions/1-projection-components.adoc[leveloffset=+1]


[.summary]
== Summary

Cypher projections use standard MATCH patterns to define which nodes and relationships to project into memory. The basic syntax is: `MATCH (source)-[r]->(target) WITH gds.graph.project('name', source, target)`.

A projection has three components:

1. **Cypher pattern** - Standard MATCH defining which nodes and relationships to include
2. **Projection call** - `WITH gds.graph.project()` piping the matched pattern into GDS
3. **Return statement** - Returns metadata about the created projection

In the next lesson, you'll learn about different graph structure types and how GDS handles them.
