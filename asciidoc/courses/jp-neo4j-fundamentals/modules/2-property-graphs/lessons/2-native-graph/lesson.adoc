= ネイティブ・グラフの優位性
// :type: video
:type: quiz
:order: 2

// [.video]
// video::uU_v4e9_qgE[youtube,width=560,height=315]

[.transcript]
== Neo4jはネイティブ・グラフ・データベースです。

Neo4jはネイティブ・グラフ・データベースです。つまり、データの保存からクエリ言語まで、すべてトラバーサルを念頭に置いて特別に設計されています。
他のエンタープライズDBMSと同じように、Neo4jは**ACID**に準拠しています。トランザクション内の一連の変更は、すべてコミットするか、失敗するかです。

ネイティブグラフデータベースが他のデータベースと異なる点は、**インデックスフリーの隣接性(IFA,index-free adjacency)**という概念です。
データベーストランザクションがコミットされると、関係の開始と終了の両方にあるノードとともに関係への参照が保存されます。
各ノードは、そのノードに接続されているすべての入出力リレーションシップを認識しているため、基盤となるグラフエンジンは、コンピュータが得意とするメモリ内のポインタを追いかけるだけとなります。

=== インデックスフリーの隣接性(IFA)

Neo4jのグラフ・データベースがRDBMSと異なる重要な特徴の一つは、Neo4jが以下を実装していることです。
*インデックスフリーの隣接性*を実装していることです。

==== RDBMSクエリ

image::images/RelationalTable1.png[RelationalTable1,height=100,role=right]

インデックスフリーの隣接性の利点をよりよく理解するために、RDBMSでクエリがどのように実行されるかを見てみましょう。

RDBMSにこのようなテーブルがあるとします。

IDが3のグループの3親等以内の親を見つけるために、このSQLクエリを実行します。

[source,SQL,role=noplay nocopy]
----
SELECT PARENT_ID
FROM GROUPS
WHERE ID = (SELECT PARENT_ID
    FROM GROUPS
    WHERE ID = (SELECT PARENT_ID
        FROM GROUPS
        WHERE ID = 3))
----

このクエリの結果は1ですが、この結果を決定するために、SQL Serverは以下のことを行う必要がありました。

.最も内側の節を見つける。
.そのサブセクションのクエリプランを構築する。
.副節のクエリプランを実行する。
.次の最も内側の節を見つける。
.ステップ2-4を繰り返す。

結果的に

* 3回の計画サイクル
* 3回のインデックス検索
* 3回のDB読み込み

==== Neo4jストレージ

インデックスフリーの隣接関係により、Neo4jはノードと関係を、ポインタを介して互いにリンクされたオブジェクトとして保存します。
概念的には、グラフは次のようになります。

image::images/IFA-1-new.png[IFA-1-new,width=500,align=center]

これらのノードとリレーションシップは、次のように格納される:

image::images/IFA-2-new.png[IFA-2-new,width=600,align=center]

==== Neo4j Cypherステートメント

下のようなクエリをCypherで作成したとします:

[source,Cypher,role=noplay nocopy]
----
MATCH (n) <-- (:Group) <-- (:Group) <-- (:Group {id: 3})
RETURN n.id
----

IFAを使うと、Neo4jのグラフエンジンは、クエリのアンカー、つまりIDが3のグループノードからスタートします。
そして、リレーションシップとノード・オブジェクトに格納されているリンクを使って、グラフ・パターンを走査（トラバース）します。

image::images/IFA-3-new.png[IFA-3-new,width=400,align=center]

このクエリを実行するために、Neo4jのグラフエンジンは必要でした。

.指定されたアンカーに基づいてクエリーを計画する。
.アンカー・ノードを取得するためにインデックスを使用する。
.ポインタをたどって目的の結果ノードを取得する。

リレーショナルDBMSアクセスと比較した場合のIFAの利点は以下の通り。

* インデックス検索が少ない。
* テーブルスキャンがない。
* データの重複を減らす。

== 理解度の確認

include::questions/1-ifa.adoc[leveloffset=+1]

[.summary]
== 概要

このレッスンでは、Neo4jのインデックスフリーの隣接性の実装が、いかにクエリーを超高速にするかについて学びました。
次に、いくつかの非グラフデータモデルがどのようにグラフとして表現されるかを学びます。