= Using Resources
:type: lesson
:order: 7


So far, you have provided access to your Neo4j database through tools, which allow the LLM to query the database dynamically based on a fixed set of parameters.

Now you'll learn about **resources** - a way to expose data through static URIs, similar to a REST API. 
// Resources give the client application direct control over what data gets loaded into the LLM's context.

== What are Resources?

**Resources** are data that can be loaded into the LLM's context by the client application.

Unlike tools (which the LLM decides to call), resources are **application-controlled** - the client decides what to load.


== Tools vs Resources

Understanding when to use each is key to effective MCP server design:


**Use Tools when:**

* The LLM should decide when to access the data
* You need to perform computation or filtering
* The operation might have side effects
* You want the LLM to discover capabilities dynamically


**Example:** `search_movies_by_genre(genre: str)` - The LLM decides when to search


**Use Resources when:**

* The client/application decides what data to load
* You're exposing reference data or documentation
* The data should be loaded into context upfront
* You want to provide specific pieces of data by ID


**Example:** `movie://123` - The client directly requests a specific movie


== Creating Resources with FastMCP

FastMCP provides the `@mcp.resource()` decorator to expose resources. Let's look at a static resource that provides reference data:

[source,python]
----
import os
from mcp.server.fastmcp import FastMCP
from collections.abc import AsyncIterator
from contextlib import asynccontextmanager
from dataclasses import dataclass

from neo4j import AsyncGraphDatabase, AsyncDriver


@dataclass
class AppContext:
    """Application context with Neo4j driver and database."""
    driver: AsyncDriver
    database: str


@asynccontextmanager
async def app_lifespan(server: FastMCP) -> AsyncIterator[AppContext]:
    """Manage application lifecycle."""
    # Get connection details from environment
    uri = os.getenv("NEO4J_URI", "bolt://localhost:7687")
    username = os.getenv("NEO4J_USERNAME", "neo4j")
    password = os.getenv("NEO4J_PASSWORD", "password")
    database = os.getenv("NEO4J_DATABASE", "neo4j")

    driver = AsyncGraphDatabase.driver(uri, auth=(username, password))
    try:
        yield AppContext(driver=driver, database=database)
    finally:
        await driver.close()


mcp = FastMCP("Movies GraphRAG Server", lifespan=app_lifespan)


@mcp.resource("catalog://genres")
async def get_genres(ctx: Context) -> dict:
    """Get all available movie genres with their counts."""
    
    context = ctx.request_context.lifespan_context
    records, _, _ = await context.driver.execute_query(
        """
        MATCH (g:Genre)
        RETURN g.name AS name,
               count((g)<-[:IN_GENRE]-()) AS movieCount
        ORDER BY g.name
        """,
        database_=context.database
    )
    
    return {
        "genres": [
            {"name": r["name"], "movieCount": r["movieCount"]}
            for r in records
        ]
    }
----

Let's break down this example:

1. **URI Pattern** - `catalog://genres`
   * Uses `catalog://` to indicate this is a reference list
   * No parameters needed since it returns all genres
   * Static URI that clients can reliably reference

2. **Function Signature**
   * `async` function since it queries the database
   * Takes `ctx: Context` to access the Neo4j driver
   * Returns `dict` for structured data

3. **Database Query**
   * Finds all Genre nodes
   * Counts how many movies are in each genre
   * Orders alphabetically for consistency

4. **Return Format**
   * Returns a dictionary with a "genres" list
   * Each genre has its name and movie count
   * Structured format makes it easy for clients to process

This resource is perfect for providing reference data that clients can load upfront to understand what genres are available.

[TIP]
.Return structured data
====
Resources should return structured data (objects or dictionaries) that clients can parse programmatically. This makes it easy for applications to:

* Process the data consistently
* Extract specific fields
* Handle the data in a type-safe way
====


== Dynamic Resource URIs

While static resources are great for reference data, sometimes you need to access specific entities. This is where dynamic URIs come in, using **parameters** in curly braces:

[source,python]
----
from mcp.server.fastmcp import Context

@mcp.resource("movie://{id}")
async def get_movie(id: str, ctx: Context) -> dict:
    """Get details about a specific movie by ID."""
    
    context = ctx.request_context.lifespan_context
    records, _, _ = await context.driver.execute_query(
        """
        MATCH (m:Movie {tmdbId: $id})
        OPTIONAL MATCH (m)-[:IN_GENRE]->(g:Genre)
        RETURN m.title AS title,
               m.tagline AS tagline,
               m.released AS released,
               m.plot AS plot,
               collect(g.name) AS genres
        """,
        id=id,
        database_=context.database
    )
    
    if not records:
        return {"error": f"Movie {id} not found"}
    
    return records[0].data()
----

Let's examine this dynamic resource:

1. **Dynamic URI Pattern** - `movie://{id}`
   * Uses `movie://` to indicate this returns a specific movie
   * The `{id}` parameter lets clients request any movie
   * FastMCP automatically extracts the ID from the URI

2. **Parameter Handling**
   * The `id` parameter in the function matches the `{id}` in the URI
   * FastMCP passes the value from the URI to your function
   * Type hints ensure proper parameter typing

3. **Database Query**
   * Uses the ID to find a specific movie
   * `OPTIONAL MATCH` ensures we get genres if they exist
   * Returns multiple properties for a rich response

4. **Error Handling**
   * Checks if the movie was found
   * Returns a structured error response
   * Clients can easily detect error conditions

5. **Structured Response**
   * Returns all data as a dictionary
   * Includes both movie details and related genres
   * Consistent with JSON API practices

The URI patterns demonstrate two common resource types:

* `catalog://genres` - A static resource that returns reference data (all available genres)
* `movie://{id}` - A dynamic resource template that returns specific movie details

The dynamic pattern allows clients to:
* Request `movie://603` to get The Matrix
* Request `movie://605` to get The Matrix Reloaded
* The `id` parameter is automatically passed to your function

The protocol scheme (`catalog://` vs `movie://`) helps clients understand the type of resource:
* `catalog://` indicates a list or catalog of available items
* `movie://` indicates a specific movie entity


== When to Use Resources

**Ideal use cases:**

* **Reference data** - Movie details, person profiles, genre information
* **Documentation** - API docs, server capabilities, usage examples
* **Configuration** - Server settings, available options
* **Static content** - About pages, help text, terms of service
* **Specific entities** - Get one item by ID


**Not ideal for:**

* **Dynamic searches** - Use tools instead
* **Filtered lists** - Use tools with parameters
* **Computed results** - Use tools for computation
* **Operations with side effects** - Definitely use tools


== Resources in the MCP Protocol

When a client connects to your server, it can:

1. **List resources** - See what's available
2. **Read a resource** - Load specific content by URI

The client decides what to load into the LLM's context **before** the conversation starts.


[.summary]
== Summary

In this lesson, you learned about MCP resources:

* **Resources vs Tools** - Application-controlled vs LLM-controlled data access
* **`@mcp.resource()` decorator** - Create resources with URI patterns
* **Dynamic URIs** - Use parameters like `movie://{id}` for flexibility
* **Structured content** - Return JSON for programmatic access
* **Use cases** - Reference data, documentation, specific entities

Resources are perfect for exposing specific pieces of data that the client wants to load into context.

In the next challenge, you'll create a resource that exposes movie details by ID.
