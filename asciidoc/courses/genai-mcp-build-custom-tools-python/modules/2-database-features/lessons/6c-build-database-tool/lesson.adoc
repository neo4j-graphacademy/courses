= Build a GraphRAG Tool
:type: challenge
:order: 6


In the previous lessons, you learned about building tools with the `@mcp.tool()` decorator and using the Context object to access lifespan resources and provide logging.

In this challenge, you will build a tool that searches for movies in a specific genre, using nodes and relationships from the graph to provide relevant context to the LLM - the essence of **GraphRAG**.


== Challenge Goals

To complete this challenge, you will:

1. Create a tool that accepts a genre parameter
2. Use the Context object to access the Neo4j driver
3. Query Neo4j for movies in the specified genre
4. Add logging to provide feedback during execution
5. Return structured output with movie information
6. Test the tool with the interactive client


[TIP]
.Solution Available
====
If you get stuck, you can review the complete solution in the repository at `solutions/6c-build-database-tool/main.py`.

To see the solution in action, run:

[source,bash]
----
uv --directory solutions/6c-build-database-tool run main.py
----
====


== Step 1: Create the Tool Function

Add a new tool to your `server/main.py` file:

[source,python]
.server/main.py
----
include::{repository-raw}/main/solutions/6c-build-database-tool/main.py[tag=get_movies_by_genre]
----


[TIP]
.Structured Output:
====
Notice that the tool returns a `list[dict]`.
FastMCP will automatically convert this to structured output that clients can parse and use programmatically.

The type hints help the LLM understand what the tool returns!
====


== Step 2: Test with the Interactive Client

Start your server in one terminal:

[source,bash]
----
uv --directory server run main.py
----

In a separate terminal, run the interactive client from the project root:

[source,bash]
----
uv --directory client run main.py
----

Select the `get_movies_by_genre` tool from the menu. The client will prompt you for parameters:

[source,role=nocopy]
----
genre (required)
  Type: string
  Enter value: Action

limit (optional, default: 10)
  Type: integer
  Enter value: 5
----

The tool will be called, and the results will be displayed in the client terminal:

[source,role=nocopy]
----
âœ¨ Result:
------------------------------------------------------------
{
  "title": "Band of Brothers",
  "imdbRating": 9.6,
  "released": "2001-09-09"
}
{
  "title": "Cowboy Bebop",
  "imdbRating": 9.0,
  "released": "2001-09-02"
}
{
  "title": "Dark Knight, The",
  "imdbRating": 9.0,
  "released": "2008-07-18"
}
{
  "title": "From the Earth to the Moon",
  "imdbRating": 8.9,
  "released": "1998-04-05"
}
{
  "title": "Lord of the Rings: The Return of the King, The",
  "imdbRating": 8.9,
  "released": "2003-12-17"
}
------------------------------------------------------------
----

Try experimenting with different genres, for example [copy]#Action#, [copy]#Comedy#, or [copy]#Sci-Fi#, and change the [copy]#limit# to see how it affects the results.


read::My tool is working![]


[TIP]
.Experiment Further
====
Try enhancing your tool:

* Add progress reporting for large queries
* Include more movie properties (director, actors, rating)
* Create additional tools for other queries (by year, by rating, etc.)
====


[.summary]
== Summary

In this challenge, you successfully built a Neo4j-backed tool using the Context object:

* **Context parameter** - Added `ctx: Context` to access MCP capabilities
* **Driver access** - Retrieved the Neo4j driver from `ctx.request_context.lifespan_context`
* **Logging** - Used `ctx.info()`, `ctx.debug()`, `ctx.warning()`, and `ctx.error()` for feedback
* **Structured output** - Returned typed data (`list[dict]`) for client consumption
* **Error handling** - Caught and logged exceptions appropriately

Your tool now provides a great user experience with informative logging and structured data output.

In the next lesson, you'll learn about resources and how to expose Neo4j data in a different way.

