= Building Tools
:type: lesson
:order: 5


You've learned about the Context object and how to access resources and provide logging.

Now it's time to build database-backed tools that query Neo4j and return structured results.


== What is a Tool?

**Tools** are functions that the LLM can call to perform actions or retrieve data.

They are the primary way to extend the LLM's capabilities with custom functionality.


== Using the `@mcp.tool()` Decorator

FastMCP makes it easy to turn any function into an MCP tool using the `@mcp.tool()` decorator:

[source,python]
----
from mcp.server.fastmcp import FastMCP

mcp = FastMCP("Movie Server")


@mcp.tool()
def search_movies(genre: str, limit: int = 10) -> list[dict]:
    """
    Search for movies by genre.
    
    Args:
        genre: The genre to search for (e.g., "Action", "Comedy")
        limit: Maximum number of results (default: 10)
    
    Returns:
        List of movies with title, released, and rating
    """
    # Tool implementation
    return results
----

**Key points:**

* The decorator automatically registers the function as a tool
* Function parameters become tool parameters
* Type hints define the parameter types for the LLM
* The docstring describes what the tool does
* Return type hints define the output structure


== Structured Outputs

FastMCP automatically converts your return values to structured outputs:

[source,python]
----
@mcp.tool()
def get_movie(title: str) -> dict:
    """Get details about a specific movie."""
    return {
        "title": "The Matrix",
        "released": 1999,
        "tagline": "Welcome to the Real World"
    }
----

**Supported return types:**

* `dict` - Key-value pairs
* `list` - Arrays of items
* Pydantic models - Rich structured data with validation
* TypedDict - Type-safe dictionaries
* Primitives (str, int, float, bool) - Automatically wrapped


== Tool Best Practices

**1. Clear naming and descriptions:**

[source,python]
----
@mcp.tool()
def search_movies_by_genre(genre: str) -> list[dict]:
    """
    Search for movies in a specific genre.
    
    Use this tool when the user wants to find movies by category.
    """
    # Implementation
----

**2. Type everything:**

[source,python]
----
@mcp.tool()
def recommend_similar(movie_id: int, limit: int = 5) -> list[dict]:
    """Recommend similar movies based on a movie ID."""
    # Return type is list[dict] - the LLM knows what to expect
----

**3. Provide defaults for optional parameters:**

[source,python]
----
@mcp.tool()
def search(query: str, limit: int = 10, min_rating: float = 7.0) -> list[dict]:
    """Search movies with optional filters."""
    # Users can omit limit and min_rating
----

**4. Use the Context for database access:**

[source,python]
----
from mcp.server.fastmcp import Context

@mcp.tool()
async def query_database(query: str, ctx: Context) -> list[dict]:
    """Execute a database query."""
    driver = ctx.request_context.lifespan_context.driver
    # Use driver to query Neo4j
----


[.summary]
== Summary

In this lesson, you learned how to build tools with FastMCP:

* **`@mcp.tool()` decorator** - Converts functions into MCP tools automatically
* **Type hints** - Define parameter and return types for the LLM
* **Docstrings** - Describe what the tool does and when to use it
* **Structured outputs** - Return typed data that clients can parse
* **Best practices** - Clear naming, typing, defaults, and Context usage

In the next challenge, you'll build a tool that queries Neo4j for movies by genre.