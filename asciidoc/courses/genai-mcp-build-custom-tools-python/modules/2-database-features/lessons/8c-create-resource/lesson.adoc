= Create a Movie Resource
:type: challenge
:order: 8


In the previous lesson, you learned about resources and how they differ from tools.


In this challenge, you will add a resource to your _Movies GraphRAG Server_ that exposes detailed movie information by its `tmdbId` property,


== Challenge Goals

To complete this challenge, you will:

1. Add a movie resource with a dynamic URI pattern
2. Query Neo4j for comprehensive movie details
3. Return structured data in a consistent format
4. Include cast, genres, directors, and metadata
5. Test the resource with the MCP Inspector


== Step 1: Understanding the Resource URI

Resources use URI patterns to identify what data to fetch.

For a movie resource, we'll use the pattern: `movie://{tmdb_id}`


**Examples:**

* `movie://603` - The Matrix
* `movie://605` - The Matrix Reloaded
* `movie://13` - Forrest Gump


This allows clients to request specific movies by their TMDB ID.


== Step 2: Create the Resource Function

Add this resource to your `server/main.py` file, after your existing tools:

[source,python]
----
include::code/solution.py[tag=get_movie_resource]
----


**Key points in this code:**

1. **URI pattern**: `movie://{tmdb_id}` - The `tmdb_id` parameter is extracted from the URI
2. **Comprehensive query**: Fetches movie details, genres, cast, and directors in one query
3. **Structured data**: Returns a consistent JSON-compatible dictionary
4. **Error handling**: Handles missing movies gracefully


== Step 3: Test with MCP Inspector

Start your server with the Inspector:

[source,bash]
----
npx @modelcontextprotocol/inspector uv --directory $PWD/server run main.py
----


=== Test Popular Movies

Try these TMDB IDs in the MCP Inspector:

* `603` - The Matrix (1999)
* `13` - Forrest Gump (1994)
* `550` - Fight Club (1999)
* `680` - Pulp Fiction (1994)


**To test:**

1. Connect to your server in the Inspector
2. Go to the **Resources** tab
3. You should see your resource template: `movie://{tmdb_id}`
4. Enter a TMDB ID (e.g., `603`)
5. Click **Read Resource**


You should see structured output like:

[source,json]
----
{
    "title": "The Matrix",
    "released": 1999,
    "tagline": "Welcome to the Real World",
    "rating": 8.7,
    "runtime": 136,
    "genres": ["Action", "Science Fiction"],
    "directors": ["Lilly Wachowski", "Lana Wachowski"],
    "plot": "Set in the 22nd century, The Matrix tells the story of a computer hacker...",
    "cast": [
        {"name": "Keanu Reeves", "role": "Neo"},
        {"name": "Laurence Fishburne", "role": "Morpheus"},
        {"name": "Carrie-Anne Moss", "role": "Trinity"},
        {"name": "Hugo Weaving", "role": "Agent Smith"},
        {"name": "Gloria Foster", "role": "Oracle"}
    ]
}
----

This structured format makes it easy to use the data programmatically and is perfect for sampling in advanced features.



read::My movie resource is working![]



[.summary]
== Summary

In this challenge, you successfully created a movie resource:

* **Dynamic URI pattern** - `movie://{tmdb_id}` for flexible resource access
* **Comprehensive query** - Fetched movie details, cast, genres, and directors
* **Structured data** - Returned consistent, JSON-compatible output
* **Error handling** - Gracefully handled missing movies
* **Resource design** - Understood when to use resources vs tools

Your server now exposes data in two ways: tools for searches and resources for specific entities.

In the next lesson, you'll learn about pagination for handling large datasets.
