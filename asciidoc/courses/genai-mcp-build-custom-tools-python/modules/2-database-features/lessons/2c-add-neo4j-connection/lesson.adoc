= Add Neo4j Connection
:type: challenge
:order: 2


In the previous lesson, you learned about lifespan management and how it helps you properly manage resources like database connections.

In this challenge, you will build a _Movies GraphRAG Server_ that uses lifespan management to establish and maintain a connection to a Neo4j database.


== Challenge Goals

To complete this challenge, you will:

1. Install required Python packages
2. Configure environment variables for Neo4j connection details
3. Create a lifespan function that initializes a Neo4j driver on startup
4. Update your server to use the lifespan function
5. Verify the connection works


== Step 1: Install Required Packages

First, create a new directory for your MCP server, and use the `uv add` command to install the required packages to your project:

[source,bash]
----
mkdir server
cd server
uv add neo4j python-dotenv
----


== Step 2: Configure Environment Variables

Create a `.env` file in your `server/` directory with your Neo4j connection details:

[source,bash,subs="attributes+"]
.server/.env
----
NEO4J_URI={instance-scheme}://{instance-ip}:{instance-boltPort}
NEO4J_USERNAME={instance-username}
NEO4J_PASSWORD={instance-password}
NEO4J_DATABASE={instance-database}
----


[NOTE]
====
The `.env` file is already in `.gitignore` so your credentials won't be committed to version control.
====


== Step 3: Implement Lifespan Management

Let's build the lifespan management step by step. First, create a new file `main.py` in your server directory and add the required imports:

[source,python]
.server/main.py
----
import os
from collections.abc import AsyncIterator
from contextlib import asynccontextmanager
from dataclasses import dataclass

from neo4j import AsyncGraphDatabase, AsyncDriver
from mcp.server.fastmcp import FastMCP

# Load environment variables from .env file
from dotenv import load_dotenv
load_dotenv()
----


Next, create a context class to hold the Neo4j driver and database configuration:

[source,python]
.server/main.py
----
@dataclass
class AppContext:
    """Application context with Neo4j driver."""
    driver: AsyncDriver
    database: str
----


Now, implement the lifespan function that will manage the Neo4j driver:

[source,python]
.server/main.py
----
@asynccontextmanager
async def app_lifespan(server: FastMCP) -> AsyncIterator[AppContext]:
    """Manage Neo4j driver lifecycle."""
    
    # Read connection details from environment
    uri = os.getenv("NEO4J_URI", "bolt://localhost:7687")
    username = os.getenv("NEO4J_USERNAME", "neo4j")
    password = os.getenv("NEO4J_PASSWORD", "password")
    database = os.getenv("NEO4J_DATABASE", "neo4j")
    
    # Initialize driver on startup
    driver = AsyncGraphDatabase.driver(uri, auth=(username, password))
    
    try:
        # Yield context with driver
        yield AppContext(driver=driver, database=database)
    finally:
        # Close driver on shutdown
        await driver.close()
----


Then define a new `FastMCP` server instance with the name [copy]#Movies GraphRAG Server# and pass the `app_lifespan` function as the lifespan parameter.

[source,python]
.server/main.py
----
# Create server with lifespan
mcp = FastMCP("Movies GraphRAG Server", lifespan=app_lifespan)

if __name__ == "__main__":
    mcp.run()
----


== Step 4: Add a Graph Statistics Tool

Now that we have our lifespan management set up, let's create a tool to return the number of nodes and relationships in the graph. 


First, create a `graph_statistics` tool function, and pass the `Context` object as a parameter.

Use `ctx.request_context.lifespan_context` to access the driver and database from the lifespan context.

[source,python]
.server/main.py
----
from mcp.server.fastmcp import Context

@mcp.tool()
async def graph_statistics(ctx: Context) -> dict[str, int]:
    """Count the number of nodes and relationships in the graph."""
    
    # Access the driver from lifespan context
    driver = ctx.request_context.lifespan_context.driver
    database = ctx.request_context.lifespan_context.database
----

Next, use the driver to execute a Cypher query that counts nodes and relationships:

[source,python]
.server/main.py
----
    # Use the driver to query Neo4j with the correct database
    records, summary, keys = await driver.execute_query(
        r"RETURN COUNT {()} AS nodes, COUNT {()-[]-()} AS relationships",
        database_=database
    )
    
    # Process the results
    if records:
        return dict(records[0])
    return {"nodes": 0, "relationships": 0}
----

[TIP]
.Using the Database Configuration
====
The `database_` parameter is used to specify the database to execute the query on.
Any named arguments that do not end with an underscore will be passed as parameters to the Cypher query.
====

== Step 5: Configure VS Code and Test the Tool

Add the new server definition to your `.vscode/mcp.json` file to pass environment variables to the server:

[source,json,subs="attributes+"]
..vscode/mcp.json
----
{
    "servers": {
        "Movie Server": {
            "type": "stdio",
            "command": "uv",
            "args": [
                "--directory",
                "server",
                "run",
                "main.py"
            ],
            "env": {
                "NEO4J_URI": "{instance-scheme}://{instance-ip}:{instance-boltPort}",
                "NEO4J_USERNAME": "{instance-username}",
                "NEO4J_PASSWORD": "{instance-password}",
                "NEO4J_DATABASE": "{instance-database}"
            }
        }
    }
}
----

// Alternatively, you can reference your `.env` file using environment variables:

// [source,json]
// ..vscode/mcp.json (alternative)
// ----
// {
//     "servers": {
//         "Movie Server": {
//             "type": "stdio",
//             "command": "bash",
//             "args": [
//                 "-c",
//                 "cd server && source .env && uv run main.py"
//             ]
//         }
//     }
// }
// ----


Test it with the MCP Inspector:

[source,bash]
----
npx @modelcontextprotocol/inspector uv --directory $PWD/server run main.py
----

Run the `graph_statistics` tool. If it returns the node and relationship counts from your database, your lifespan management is working correctly!


== Verify Your Implementation

Once you've implemented the lifespan management:

1. The server should start without errors
2. The `graph_statistics` tool should return node and relationship counts from your database
3. The server should cleanly shut down when stopped (no connection warnings)

read::My lifespan management is working![]


[TIP]
.Troubleshooting
====
If you're having issues:

* Check that your `.env` file has the correct Neo4j credentials
* Verify the environment variables are being loaded (add print statements to debug)
* Ensure the Neo4j database is running and accessible
* Check the MCP Inspector's History tab for error messages
====


[.summary]
== Summary

In this challenge, you successfully added lifespan management to your MCP server:

* **Package installation** - Added the `neo4j` and `python-dotenv` packages to your project
* **Environment variables** - Stored credentials in `.env` file and loaded them with `python-dotenv`
* **Lifespan function** - Created an async context manager to initialize and clean up the Neo4j driver
* **Context access** - Used `ctx.request_context.lifespan_context` to access the driver in tools
* **Connection testing** - Verified the connection works with a simple test tool

Your server now properly manages the Neo4j driver lifecycle, creating it once on startup and reusing it across all tool calls.

In the next lesson, you'll learn about the MCP Inspector and how to use it to test your server's tools and resources.