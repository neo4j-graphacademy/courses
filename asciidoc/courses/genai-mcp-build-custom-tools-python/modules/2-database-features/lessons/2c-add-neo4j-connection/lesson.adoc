= Add Neo4j Connection
:type: challenge
:order: 2


In the previous lesson, you learned about lifespan management and how it helps you properly manage resources like database connections.

In this challenge, you will add lifespan management to your MCP server to establish and maintain a connection to a Neo4j database.


== Challenge Goals

To complete this challenge, you will:

1. Install the Neo4j Python driver
2. Create a lifespan function that initializes a Neo4j driver on startup
3. Configure environment variables for Neo4j connection details
4. Update your server to use the lifespan function
5. Verify the connection works


== Step 1: Install the Neo4j Driver

First, add the Neo4j Python driver to your project:

[source,bash]
----
cd server
uv add neo4j
----


== Step 2: Create Environment Variables

Create a `.env` file in your `server/` directory with your Neo4j connection details:

[source,bash,subs="attributes+"]
.server/.env
----
NEO4J_URI={instance-scheme}://{instance-ip}:{instance-boltPort}
NEO4J_USERNAME={instance-username}
NEO4J_PASSWORD={instance-password}
NEO4J_DATABASE={instance-database}
----


[NOTE]
====
The `.env` file is already in `.gitignore` so your credentials won't be committed to version control.
====


== Step 3: Create the Lifespan Function

Update your `main.py` file to include lifespan management:

[source,python]
.server/main.py
----
import os
from collections.abc import AsyncIterator
from contextlib import asynccontextmanager
from dataclasses import dataclass

from neo4j import AsyncGraphDatabase, AsyncDriver
from mcp.server.fastmcp import FastMCP

# load credentials from .env file
from dotenv import load_dotenv
load_dotenv()


# Define context to hold the Neo4j driver
@dataclass
class AppContext:
    """Application context with Neo4j driver."""
    driver: AsyncDriver
    database: str


@asynccontextmanager
async def app_lifespan(server: FastMCP) -> AsyncIterator[AppContext]:
    """Manage Neo4j driver lifecycle."""
    
    # Read connection details from environment
    uri = os.getenv("NEO4J_URI", "bolt://localhost:7687")
    username = os.getenv("NEO4J_USERNAME", "neo4j")
    password = os.getenv("NEO4J_PASSWORD", "password")
    database = os.getenv("NEO4J_DATABASE", "neo4j")
    
    # Initialize driver on startup
    driver = AsyncGraphDatabase.driver(uri, auth=(username, password))
    
    try:
        # Yield context with driver
        yield AppContext(driver=driver, database=database)
    finally:
        # Close driver on shutdown
        await driver.close()


# Create server with lifespan
mcp = FastMCP("Movies GraphRAG Server", lifespan=app_lifespan)


@mcp.tool()
def count_letters(text: str, search: str) -> int:
    """Count occurrences of a letter in the text"""
    return text.lower().count(search.lower())


if __name__ == "__main__":
    mcp.run()
----


== Step 4: Load Environment Variables

To load environment variables from the `.env` file, you need to install and use the `python-dotenv` package:

[source,bash]
----
uv add python-dotenv
----

Then update your `main.py` to load the environment variables:

[source,python]
.server/main.py
----
import os
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# ... rest of your code
----


== Step 5: Update VS Code Configuration

Update your `.vscode/mcp.json` to pass environment variables to the server:

[source,json,subs="attributes+"]
..vscode/mcp.json
----
{
    "servers": {
        "Movie Server": {
            "type": "stdio",
            "command": "uv",
            "args": [
                "--directory",
                "server",
                "run",
                "main.py"
            ],
            "env": {
                "NEO4J_URI": "{instance-scheme}://{instance-ip}:{instance-boltPort}",
                "NEO4J_USERNAME": "{instance-username}",
                "NEO4J_PASSWORD": "{instance-password}",
                "NEO4J_DATABASE": "{instance-database}"
            }
        }
    }
}
----

// Alternatively, you can reference your `.env` file using environment variables:

// [source,json]
// ..vscode/mcp.json (alternative)
// ----
// {
//     "servers": {
//         "Movie Server": {
//             "type": "stdio",
//             "command": "bash",
//             "args": [
//                 "-c",
//                 "cd server && source .env && uv run main.py"
//             ]
//         }
//     }
// }
// ----


== Step 6: Test the Connection

Create a tool to test the Neo4j connection by getting database statistics:

[source,python]
.server/main.py
----
from mcp.server.fastmcp import Context

@mcp.tool()
async def graph_statistics(ctx: Context) -> dict[str, int]:
    """Count the number of nodes and relationships in the graph."""
    
    # Access the driver from lifespan context
    driver = ctx.request_context.lifespan_context.driver
    
    # Use the driver to query Neo4j
    records, summary, keys = await driver.execute_query(
        "RETURN COUNT {()} AS nodes, COUNT {()-[]-()} AS relationships"
    )
    
    # Process the results
    if records:
        return dict(records[0])
    return {"nodes": 0, "relationships": 0}
----

// TODO: replace mcp inspector?

Test it with the MCP Inspector:

[source,bash]
----
npx @modelcontextprotocol/inspector uv --directory $PWD/server run main.py
----

Run the `graph_statistics` tool. If it returns the node and relationship counts from your database, your lifespan management is working correctly!


== Verify Your Implementation

Once you've implemented the lifespan management:

1. The server should start without errors
2. The `graph_statistics` tool should return node and relationship counts from your database
3. The server should cleanly shut down when stopped (no connection warnings)

read::My lifespan management is working![]


[TIP]
.Troubleshooting
====
If you're having issues:

* Check that your `.env` file has the correct Neo4j credentials
* Verify the environment variables are being loaded (add print statements to debug)
* Ensure the Neo4j database is running and accessible
* Check the MCP Inspector's History tab for error messages
====


[.summary]
== Summary

In this challenge, you successfully added lifespan management to your MCP server:

* **Neo4j driver installation** - Added the `neo4j` Python package to your project
* **Environment variables** - Stored credentials in `.env` file and loaded them with `python-dotenv`
* **Lifespan function** - Created an async context manager to initialize and clean up the Neo4j driver
* **Context access** - Used `ctx.request_context.lifespan_context` to access the driver in tools
* **Connection testing** - Verified the connection works with a simple test tool

Your server now properly manages the Neo4j driver lifecycle, creating it once on startup and reusing it across all tool calls.

In the next lesson, you'll learn about the MCP Inspector and how to use it to test your server's tools and resources.

