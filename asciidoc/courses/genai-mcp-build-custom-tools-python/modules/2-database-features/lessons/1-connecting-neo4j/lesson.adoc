= Connecting to Neo4j
:type: lesson
:order: 1


Now that you have a working MCP server, it's time to connect it to a database.

In this lesson, you will learn how to connect your MCP server to Neo4j using FastMCP's lifespan management feature to properly handle database connections.


== The Problem with Simple Connections

Consider this naive approach to connecting to Neo4j:

[source,python]
----
from neo4j import GraphDatabase

@mcp.tool()
def get_movies() -> list[dict]:
    """Get a list of movies"""
    # Creating a new driver for every tool call!
    driver = GraphDatabase.driver(uri, auth=(user, password))
    with driver.session() as session:
        result = session.run("MATCH (m:Movie) RETURN m LIMIT 10")
        return [record.data() for record in result]
    driver.close()
----

This approach has several problems:

* **Performance**: Creating a new driver connection for every tool call is slow and inefficient
* **Resource leaks**: If the tool fails, the driver may not be closed properly
* **Connection pooling**: Neo4j drivers maintain connection pools that should be reused across requests
* **Best practices**: The Neo4j driver should be created once and closed when the server shuts down


== Introducing Lifespan Management

FastMCP provides a **lifespan** feature that allows you to:

1. **Initialize resources** when the server starts (e.g., create database connections)
2. **Clean up resources** when the server shuts down (e.g., close connections)
3. **Share resources** across all tools and resources in your server


=== The Lifespan Context Manager

A lifespan function is an async context manager that yields a context object containing your initialized resources:

[source,python]
----
from collections.abc import AsyncIterator
from contextlib import asynccontextmanager
from dataclasses import dataclass
from neo4j import AsyncGraphDatabase

from mcp.server.fastmcp import FastMCP


# Define a context class to hold your resources
@dataclass
class AppContext:
    """Application context with shared resources."""
    driver: AsyncDriver


@asynccontextmanager
async def app_lifespan(server: FastMCP) -> AsyncIterator[AppContext]:
    """Manage application lifecycle."""
    
    # Startup: Initialize resources
    driver = AsyncGraphDatabase.driver(uri, auth=(user, password))
    
    try:
        # Yield the context with initialized resources
        yield AppContext(driver=driver)
    finally:
        # Shutdown: Clean up resources
        await driver.close()


# Pass lifespan to the server
mcp = FastMCP("Movie Server", lifespan=app_lifespan)
----

**Key points:**

* The `@asynccontextmanager` decorator creates an async context manager
* Code before `yield` runs at **server startup**
* The yielded value is the **context** that tools can access
* Code in the `finally` block runs at **server shutdown**


=== Using Environment Variables

You should **never** hardcode credentials in your code.
Instead, use environment variables to store sensitive information:

[source,python]
----
import os
from neo4j import AsyncGraphDatabase

@asynccontextmanager
async def app_lifespan(server: FastMCP) -> AsyncIterator[AppContext]:
    """Manage application lifecycle with environment variables."""
    
    # Read credentials from environment variables
    uri = os.getenv("NEO4J_URI", "bolt://localhost:7687")
    username = os.getenv("NEO4J_USERNAME", "neo4j")
    password = os.getenv("NEO4J_PASSWORD", "password")
    
    # Initialize driver
    driver = AsyncGraphDatabase.driver(uri, auth=(username, password))
    
    try:
        yield AppContext(driver=driver)
    finally:
        await driver.close()
----


=== Accessing Lifespan Context in Tools

Once you've set up lifespan management, your tools can access the shared resources through the `Context` object:

[source,python]
----
from mcp.server.fastmcp import Context, FastMCP

@mcp.tool()
async def get_movies(ctx: Context) -> list[dict]:
    """Get a list of movies from Neo4j."""
    
    # Access the driver from lifespan context
    driver = ctx.request_context.lifespan_context.driver
    
    # Use the driver to query Neo4j
    records, summary, keys = await driver.execute_query(
        "MATCH (m:Movie) RETURN m.title AS title LIMIT 10"
    )
    
    return [record.data() for record in records]
----


== Benefits of Lifespan Management

Using lifespan management provides several advantages:

* **Performance**: Database connections are created once and reused across all tool calls
* **Reliability**: Resources are properly cleaned up when the server shuts down
* **Best practices**: Follows Neo4j driver best practices for connection management
* **Type safety**: The context object can be strongly typed for better IDE support
* **Testability**: Makes it easier to mock database connections in tests


[.summary]
== Summary

In this lesson, you learned about FastMCP's lifespan management feature:

* **Lifespan context managers** - Use `@asynccontextmanager` to manage server startup and shutdown
* **Resource initialization** - Create database connections when the server starts
* **Resource cleanup** - Close connections when the server shuts down
* **Environment variables** - Use `os.getenv()` to read credentials from environment variables
* **Shared context** - Access initialized resources in tools via `ctx.request_context.lifespan_context`

In the next challenge, you will add lifespan management to your MCP server to properly manage a Neo4j driver connection.

