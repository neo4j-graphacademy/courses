= Next Steps
:type: lesson
:order: 4


Congratulations! You've completed the course and built a sophisticated GraphRAG MCP server.

In this final lesson, we'll review what you've accomplished, discuss best practices, and explore where to go from here.


== What You've Built

Over the course of these modules, you created a complete MCP server with:


=== Module 1: Getting Started

* **Basic MCP server** with FastMCP
* **Simple tools** (letter counting)
* **Testing workflow** with MCP Inspector
* **VS Code integration** with Agent mode


=== Module 2: Database-Connected Features

* **Neo4j connection** with lifespan management
* **Environment variables** for secure configuration
* **Context object** for logging and driver access
* **Database-backed tools** (search movies by genre)
* **Resources** (movie details by ID)
* **Pagination** (browse large datasets efficiently)
* **Prompts** (user-guided templates)


=== Module 3: Integration & Advanced

* **Integrated workflows** with AI assistance
* **Schema exploration** tools
* **Query testing** capabilities
* **Text-to-Cypher** natural language queries


**This is a production-ready foundation for GraphRAG applications!**


== Best Practices Summary

Throughout the course, you learned these key principles:


=== 1. Lifecycle Management

[source,python]
----
# GOOD: Use lifespan for database connections
@asynccontextmanager
async def app_lifespan(server: FastMCP) -> AsyncIterator[AppContext]:
    driver = AsyncGraphDatabase.driver(uri, auth=(username, password))
    try:
        yield AppContext(driver=driver)
    finally:
        await driver.close()

# AVOID: Creating connections in every tool
@mcp.tool()
def bad_example():
    driver = GraphDatabase.driver(...)  # ❌ New connection every time!
----


=== 2. Environment Variables

[source,python]
----
# GOOD: Never hardcode credentials
uri = os.getenv("NEO4J_URI")
username = os.getenv("NEO4J_USERNAME")
password = os.getenv("NEO4J_PASSWORD")

# AVOID: Hardcoding secrets
uri = "bolt://prod-server:7687"  # ❌ Security risk!
password = "mypassword"  # ❌ Never commit this!
----


=== 3. Context Usage

[source,python]
----
# GOOD: Use context for driver, logging, and progress
@mcp.tool()
async def good_tool(query: str, ctx: Context) -> list:
    await ctx.info(f"Processing: {query}")
    driver = ctx.request_context.lifespan_context.driver
    # Use driver...
    await ctx.report_progress(0.5, message="Half done")

# AVOID: Ignoring context capabilities
@mcp.tool()
def bad_tool(query: str):  # ❌ No context, no logging
    # Hard to debug, no visibility
----


=== 4. Error Handling

[source,python]
----
# GOOD: Handle errors gracefully
@mcp.tool()
async def good_tool(ctx: Context):
    try:
        result = await do_something()
        await ctx.info("Success!")
        return result
    except Exception as e:
        await ctx.error(f"Failed: {str(e)}")
        raise

# AVOID: Silent failures
@mcp.tool()
def bad_tool():
    result = do_something()  # ❌ What if this fails?
    return result
----


=== 5. Pagination

[source,python]
----
# GOOD: Paginate large results
@mcp.tool()
async def browse_data(cursor: str = "0", page_size: int = 20):
    skip = int(cursor)
    # Query with SKIP and LIMIT
    next_cursor = str(skip + page_size) if has_more else None
    return {"items": items, "next_cursor": next_cursor}

# AVOID: Returning unbounded results
@mcp.tool()
def bad_tool():
    return all_million_items  # ❌ Memory disaster!
----


== Production Considerations

Before deploying your MCP server to production:


=== Security

* **Authentication**: Consider adding OAuth or token-based auth for HTTP deployments
* **Input validation**: Validate and sanitize all user inputs
* **Query limits**: Add timeouts and result size limits
* **Read-only by default**: Only allow write operations where necessary
* **Environment isolation**: Use separate databases for dev/staging/prod


=== Performance

* **Connection pooling**: Neo4j driver handles this, but configure pool size
* **Query optimization**: Use indexes, limit results, avoid expensive operations
* **Caching**: Consider caching frequently accessed resources
* **Monitoring**: Add metrics and logging for production debugging
* **Rate limiting**: Protect against abuse with rate limits


=== Reliability

* **Error handling**: Comprehensive try/except blocks with proper logging
* **Graceful degradation**: Handle database downtime gracefully
* **Health checks**: Add tools to verify system health
* **Retry logic**: Implement retries for transient failures
* **Testing**: Write tests for your tools and resources


=== Example Production Configuration

[source,python]
----
@asynccontextmanager
async def production_lifespan(server: FastMCP) -> AsyncIterator[AppContext]:
    # Production-grade configuration
    driver = AsyncGraphDatabase.driver(
        os.getenv("NEO4J_URI"),
        auth=(
            os.getenv("NEO4J_USERNAME"),
            os.getenv("NEO4J_PASSWORD")
        ),
        max_connection_pool_size=50,  # Adjust based on load
        connection_timeout=30.0,
        max_transaction_retry_time=30.0
    )
    
    # Verify connection on startup
    await driver.verify_connectivity()
    
    try:
        yield AppContext(driver=driver)
    finally:
        await driver.close()
----


== Expanding Your Server

Ideas for extending what you've built:


=== More Tools

* **Recommendation engine**: "Movies similar to X"
* **Similarity search**: Vector embeddings for semantic search
* **Graph algorithms**: PageRank, community detection
* **Multi-hop queries**: "Actors who worked with actors who worked with X"
* **Aggregations**: "Most prolific directors by decade"


=== Better Text-to-Cypher

* **Use an LLM**: Instead of pattern matching, use GPT-4 or Claude
* **Few-shot learning**: Provide example queries to improve generation
* **Query validation**: Verify generated Cypher before execution
* **Query optimization**: Analyze and improve generated queries


=== Additional Features

* **Batch operations**: Process multiple queries efficiently
* **Subscription updates**: Notify when data changes
* **Export capabilities**: Generate reports or exports
* **Admin tools**: Database maintenance and monitoring
* **Analytics**: Usage tracking and insights


== Learning Resources

Continue your MCP and Neo4j journey:


=== MCP Resources

* link:https://modelcontextprotocol.io[Model Context Protocol Documentation^]
* link:https://spec.modelcontextprotocol.io[MCP Specification^]
* link:https://github.com/modelcontextprotocol/python-sdk[Python SDK GitHub Repository^]
* link:https://github.com/modelcontextprotocol/servers[Official MCP Servers^]


=== Neo4j Resources

* link:https://neo4j.com/docs/[Neo4j Documentation^]
* link:https://neo4j.com/developer/cypher/[Cypher Query Language^]
* link:https://graphacademy.neo4j.com[GraphAcademy Courses^]
* link:https://neo4j.com/developer/graph-data-science/[Graph Data Science^]


=== GraphRAG & LLMs

* link:https://neo4j.com/labs/genai-ecosystem/[Neo4j GenAI Ecosystem^]
* link:https://neo4j.com/developer/kb/explanation-of-graphrag/[What is GraphRAG?^]
* link:https://www.anthropic.com/news/model-context-protocol[MCP Announcement from Anthropic^]


== Community & Support

Get help and share your work:

* **Neo4j Community**: link:https://community.neo4j.com[community.neo4j.com^]
* **MCP Discord**: Join the Model Context Protocol community
* **GitHub Discussions**: link:https://github.com/modelcontextprotocol/python-sdk/discussions[Python SDK Discussions^]
* **Stack Overflow**: Tag questions with `neo4j` and `mcp`


== Your Next Project

Ready to build something amazing? Consider:


=== 1. Domain-Specific GraphRAG

Build an MCP server for a specific domain:

* **Healthcare**: Medical knowledge graphs
* **E-commerce**: Product recommendation system
* **Social networks**: Influence and community analysis
* **Finance**: Fraud detection and risk analysis
* **Scientific research**: Citation networks and collaboration


=== 2. Multi-Database Server

Connect to multiple data sources:

* Neo4j for graph data
* PostgreSQL for structured data
* Vector database for embeddings
* Combine insights from all sources


=== 3. Advanced AI Features

Enhance with cutting-edge AI:

* **Vector search**: Semantic similarity with embeddings
* **Knowledge graphs**: Build graphs from unstructured text
* **Agent systems**: Multi-agent workflows with MCP tools
* **RAG pipelines**: Retrieval augmented generation with graphs


== Final Words

You've learned to build production-ready MCP servers that combine the power of:

* **Neo4j graph databases** - Complex relationship queries
* **Model Context Protocol** - Standardized AI integration
* **Python's async capabilities** - High-performance servers
* **FastMCP framework** - Rapid development


**The foundation is yours.**


Now it's time to build something amazing.


What will you create?


[.summary]
== Summary

In this lesson, you reviewed:

* **What you built** - Complete GraphRAG server with 8+ tools
* **Best practices** - Lifecycle, security, error handling, pagination
* **Production considerations** - Security, performance, reliability
* **Expansion ideas** - More tools, better NLP, additional features
* **Resources** - Documentation, communities, learning paths
* **Next projects** - Domain-specific servers, multi-database, advanced AI


**Thank you for taking this course!**


We can't wait to see what you build with MCP and Neo4j.


Share your creations:

* Tag `@neo4j` and `#MCP` on social media
* Post in the Neo4j Community forum
* Contribute to the MCP ecosystem


**Happy building! 🚀**
