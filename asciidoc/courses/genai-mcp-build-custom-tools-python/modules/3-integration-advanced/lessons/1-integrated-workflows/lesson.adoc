= Integrated Workflows
:type: lesson
:order: 1


You've built a complete MCP server with tools, resources, prompts, and pagination. Now it's time to use these tools to build even better tools - a concept known as **meta-programming**. Your MCP server can query schemas, generate and validate Cypher queries, and help build new tools, making development faster and more sophisticated.

== Building Tools with AI Assistance

Instead of manually exploring schemas, writing queries, and debugging code, you can use your MCP tools with AI to automate the development process. For example, to create a tool that finds actors who worked with a specific director, simply ask the AI to help. It will use your tools to explore the schema, generate and validate the Cypher query, and write the complete Python function.


== Using Cursor Rules

link:https://cursor.sh[Cursor^] can leverage your MCP server through **Cursor Rules**. Create `.cursor/rules/mcp-neo4j.md` with instructions for using your tools:

[source,markdown]
----
# Neo4j MCP Server Integration

## Available Tools
- **neo4j_schema**: Get database schema (labels, relationships, properties)
- **neo4j_query**: Execute and validate Cypher queries

## Best Practices
- Start with schema exploration
- Test queries before implementation
- Avoid OPTIONAL MATCH unless absolutely necessary. Use list comprehension in the RETURN clause instead.
- Add ORDER BY and LIMIT clauses
- Use parameters ($param)
- Include logging and error handling

## Example Usage
"Create a tool to find movies with a specific actor"
1. Check schema: Person-[:ACTED_IN]->Movie
2. Test query: MATCH (p:Person {name: $name})-[r:ACTED_IN]->(m:Movie) RETURN m.title AS title, r.role AS role
3. Generate Python function with proper structure
----

Now Cursor can use your MCP tools to explore schemas, validate queries, and generate code automatically.


== Iterative Development with MCP

MCP enables rapid iteration through AI assistance. Here's how a tool evolves:

[source,python]
----
@mcp.tool()
async def find_directors_for_actor(actor_name: str, ctx: Context) -> list[dict]:
    """Find directors who worked with an actor."""
    
    await ctx.info(f"Finding directors who worked with {actor_name}")
    driver = ctx.request_context.lifespan_context.driver
    
    try:
        # Check if actor exists
        check_records, _, _ = await driver.execute_query(
            "MATCH (p:Person {name: $name}) RETURN count(p) AS count",
            name=actor_name
        )
        
        if check_records[0]["count"] == 0:
            await ctx.warning(f"Actor '{actor_name}' not found in database")
            return []
        
        # Find directors and their collaborations
        records, _, _ = await driver.execute_query(
            """
            MATCH (p:Person {name: $actor_name})-[:ACTED_IN]->(m:Movie)<-[:DIRECTED]-(d:Person)
            RETURN d.name AS director, 
                   collect(m.title) AS movies,
                   count(m) AS collaboration_count
            ORDER BY collaboration_count DESC
            """,
            actor_name=actor_name
        )
        
        results = [r.data() for r in records]
        await ctx.info(f"Found {len(results)} directors who worked with {actor_name}")
        return results
        
    except Exception as e:
        await ctx.error(f"Query failed: {str(e)}")
        raise
----

Each improvement (adding movie information, error handling, logging) can be requested from the AI, which uses your MCP tools to validate and implement the changes.


== The Power of MCP: From Probabilistic to Deterministic Graph Development

The ultimate example of MCP's power is using MCP servers to build reliable graph tools. Instead of relying on probabilistic AI responses, you can create a deterministic workflow:

1. Use `neo4j_schema` to understand the exact graph structure
2. Use `neo4j_query` to write and validate Cypher statements
3. Write the validated code into your project

For example, to build a movie search feature:

[source,python]
----
# 1. Get schema to understand relationships
schema = neo4j_schema()  # Shows Movie-[:IN_GENRE]->Genre exists

# 2. Validate the Cypher query
result = neo4j_query("""
    MATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: $genre})
    WHERE m.released >= $year_start AND m.released < $year_end
    RETURN m.title, m.released, m.rating
    ORDER BY m.rating DESC
""")

# 3. Write the validated query into your tool
write_to_project(validated_query)
----

This approach ensures reliable results - as long as you use the right tools in the right order. You'll build this exact workflow in the next challenge!


[.summary]
== Summary

In this lesson, you learned about integrated workflows with MCP:

* **Meta-programming** - Using MCP tools to build MCP tools
* **Cursor Rules** - Configure AI assistants to use your MCP server
* **Iterative development** - Rapidly improve tools with AI assistance
* **AI-assisted queries** - Generate and validate Cypher with MCP
* **Text-to-Cypher** - Build tools that understand natural language

MCP isn't just about the tools you create - it's about empowering the development process itself.

In the next challenge, you'll build a text-to-Cypher tool that brings this all together.
