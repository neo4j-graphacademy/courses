= Integrated Workflows
:type: lesson
:order: 1


You've built a complete MCP server with tools, resources, prompts, and pagination.

Now you'll learn how to integrate your MCP server into your development workflow to build even more sophisticated tools.


== The Meta-Programming Opportunity

Here's a powerful idea: **You can use MCP tools to help you build MCP tools**.


Your MCP server can:

1. Query the Neo4j schema
2. Generate Cypher queries
3. Validate those queries
4. Help you build new tools


This is **meta-programming** - using your tools to build better tools.


== Building Tools with AI Assistance

Let's walk through a real workflow for building a new MCP tool.


=== The Challenge

You want to create a tool that finds actors who have worked with a specific director.


=== Traditional Approach

1. Manually explore the Neo4j schema
2. Write Cypher query by hand
3. Test query in Neo4j Browser
4. Debug issues
5. Write Python function
6. Test in MCP Inspector
7. Iterate until it works


**Time:** 30-60 minutes


=== AI-Assisted Approach with MCP

1. Ask AI: "I need a tool to find actors who worked with a director"
2. AI uses your MCP Neo4j tools to explore the schema
3. AI generates and validates the Cypher query
4. AI writes the complete Python function with proper error handling
5. You review and test


**Time:** 5-10 minutes


== Using Cursor Rules for MCP Integration

link:https://cursor.sh[Cursor^] is an AI-powered code editor that can leverage MCP servers.

You can create **Cursor Rules** that tell the AI how to use your MCP server.


=== Create a Cursor Rule

Create `.cursor/rules/mcp-neo4j.md` in your project:

[source,markdown]
----
# Neo4j MCP Server Integration

When working with Neo4j queries for this project:

## Available MCP Tools

1. **neo4j_schema** - Get the current database schema
   - Shows node labels, relationship types, and properties
   - Use this FIRST before writing any Cypher

2. **neo4j_query** - Execute read-only Cypher queries
   - Validates query syntax
   - Returns results or error messages
   - Use this to TEST queries before adding to code

## Workflow for Creating Neo4j Tools

1. **Always start with schema**
   ```
   Use neo4j_schema tool to understand the data model
   ```

2. **Write and test the Cypher**
   ```
   Use neo4j_query tool to test query
   Iterate until it works correctly
   ```

3. **Generate the Python function**
   ```python
   @mcp.tool()
   async def tool_name(param: type, ctx: Context) -> return_type:
       """Clear docstring."""
       driver = ctx.request_context.lifespan_context.driver
       # Use the validated Cypher query
   ```

## Best Practices

- Use OPTIONAL MATCH for relationships that might not exist
- Limit results with LIMIT clause
- Add ORDER BY for consistent results
- Use parameters ($param) never string interpolation
- Add logging with ctx.info() and ctx.debug()
- Handle errors gracefully with try/except

## Example

"Create a tool to find movies with a specific actor"

Steps:
1. Check schema to see Person-[:ACTED_IN]->Movie relationships
2. Write query: MATCH (p:Person {name: $name})-[:ACTED_IN]->(m:Movie)
3. Test with neo4j_query tool
4. Generate complete Python tool function
----


=== Using the Rule

Now when you ask Cursor:

> "Create a tool to find directors who worked with Keanu Reeves"

Cursor will:

1. Use your MCP server to get the schema
2. Understand the Person and DIRECTED relationships
3. Generate and test a Cypher query
4. Write the complete Python function with proper structure


== Iterative Development with MCP

MCP enables an iterative workflow:


=== Iteration 1: Basic Query

[source,python]
----
@mcp.tool()
async def find_directors_for_actor(actor_name: str, ctx: Context) -> list[dict]:
    """Find directors who worked with an actor."""
    
    driver = ctx.request_context.lifespan_context.driver
    
    records, _, _ = await driver.execute_query(
        """
        MATCH (p:Person {name: $actor_name})-[:ACTED_IN]->(m:Movie)<-[:DIRECTED]-(d:Person)
        RETURN DISTINCT d.name AS director
        """,
        actor_name=actor_name
    )
    
    return [r.data() for r in records]
----


=== Iteration 2: Add Movie Information

Ask AI: "Include which movies they worked together on"

[source,python]
----
@mcp.tool()
async def find_directors_for_actor(actor_name: str, ctx: Context) -> list[dict]:
    """Find directors who worked with an actor."""
    
    records, _, _ = await driver.execute_query(
        """
        MATCH (p:Person {name: $actor_name})-[:ACTED_IN]->(m:Movie)<-[:DIRECTED]-(d:Person)
        RETURN d.name AS director, 
               collect(m.title) AS movies
        ORDER BY size(movies) DESC
        """,
        actor_name=actor_name
    )
    
    return [r.data() for r in records]
----


=== Iteration 3: Add Error Handling and Logging

Ask AI: "Add proper error handling and logging"

[source,python]
----
@mcp.tool()
async def find_directors_for_actor(actor_name: str, ctx: Context) -> list[dict]:
    """Find directors who worked with an actor."""
    
    await ctx.info(f"Finding directors who worked with {actor_name}")
    
    driver = ctx.request_context.lifespan_context.driver
    
    try:
        # First check if actor exists
        check_records, _, _ = await driver.execute_query(
            "MATCH (p:Person {name: $name}) RETURN count(p) AS count",
            name=actor_name
        )
        
        if check_records[0]["count"] == 0:
            await ctx.warning(f"Actor '{actor_name}' not found in database")
            return []
        
        # Find directors
        records, _, _ = await driver.execute_query(
            """
            MATCH (p:Person {name: $actor_name})-[:ACTED_IN]->(m:Movie)<-[:DIRECTED]-(d:Person)
            RETURN d.name AS director, 
                   collect(m.title) AS movies,
                   count(m) AS collaboration_count
            ORDER BY collaboration_count DESC
            """,
            actor_name=actor_name
        )
        
        results = [r.data() for r in records]
        await ctx.info(f"Found {len(results)} directors who worked with {actor_name}")
        
        return results
        
    except Exception as e:
        await ctx.error(f"Query failed: {str(e)}")
        raise
----


## Building a Text-to-Cypher Tool

One of the most powerful tools you can build is one that generates Cypher queries from natural language.


This tool would:

1. Accept a natural language question
2. Use the Neo4j schema to understand what's possible
3. Generate an appropriate Cypher query
4. Execute and return results


**Example usage:**

> "Show me action movies from the 1990s"

The tool would:

1. Understand you want Movies
2. Know there's a Genre relationship
3. Generate: `MATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: 'Action'}) WHERE m.released >= 1990 AND m.released < 2000 RETURN m`
4. Execute and return results


**This is exactly what you'll build in the next challenge!**


== The Power of MCP in Development

MCP transforms your development workflow:


**Without MCP:**

* Manual schema exploration
* Trial and error with queries
* Repetitive code patterns
* Slow iteration cycles


**With MCP:**

* AI-assisted query generation
* Automated testing with your tools
* Faster iteration
* More sophisticated features


**The result:** You can build more complex tools in less time with higher quality.


[.summary]
== Summary

In this lesson, you learned about integrated workflows with MCP:

* **Meta-programming** - Using MCP tools to build MCP tools
* **Cursor Rules** - Configure AI assistants to use your MCP server
* **Iterative development** - Rapidly improve tools with AI assistance
* **AI-assisted queries** - Generate and validate Cypher with MCP
* **Text-to-Cypher** - Build tools that understand natural language

MCP isn't just about the tools you create - it's about empowering the development process itself.

In the next challenge, you'll build a text-to-Cypher tool that brings this all together.
