= Advanced MCP Features
:type: lesson
:order: 3


The MCP Python SDK offers two advanced features for building more sophisticated servers: **Sampling** and **Completions**. These optional features enable more dynamic interactions with LLMs and improved user experiences.

== Sampling: Dynamic LLM Interactions

Sampling allows tools to interact with the LLM during execution, enabling tools to:

* Generate natural language from structured data
* Transform query results into readable text
* Get recommendations based on data analysis
* Create dynamic summaries

Here's how sampling works:

[source,python]
----
@mcp.tool()
async def explain_movie_data(movie_title: str, ctx: Context) -> str:
    """Get a natural language explanation of movie data."""
    
    # Get movie data from Neo4j
    movie_data = await get_movie_details(movie_title, ctx)
    
    # Ask LLM to explain the data
    result = await ctx.session.create_message(
        messages=[
            SamplingMessage(
                role="user",
                content=TextContent(
                    text=f"Describe {movie_data['title']} ({movie_data['released']}) " +
                         f"starring {', '.join(movie_data['actors'])}. " +
                         "Write 2-3 engaging sentences."
                )
            )
        ],
        max_tokens=200
    )
    
    return result.content.text if result.content.type == "text" else str(result.content)
----

[NOTE]
====
Sampling requires client support and adds processing overhead. Use it when the dynamic content generation justifies the complexity.
====


== Completions: Smart Parameter Suggestions

Completions provide autocomplete suggestions for tool parameters and resource URIs. For example, in a movie database:

* Suggest genre names when filtering movies
* Autocomplete movie titles in searches
* Provide actor names based on previous selections

Here's a basic example:

[source,python]
----
@server.complete()
async def handle_completion(
    ref: types.PromptReference | types.ResourceReference,
    argument: types.CompleteArgument
) -> CompleteResult:
    """Provide genre completions."""
    
    if argument.name == "genre":
        records, _, _ = await driver.execute_query(
            """
            CALL db.labels() YIELD label
            WHERE label STARTS WITH $prefix
            RETURN label LIMIT 10
            """,
            prefix=argument.value
        )
        
        return CompleteResult(
            completion=Completion(
                values=[record["label"] for record in records]
            )
        )
    
    return CompleteResult(completion=Completion(values=[]))
----

[NOTE]
====
Completions require using the low-level `Server` API instead of FastMCP's decorator-based approach.
====


== When to Use Advanced Features

Consider these features when:

* **Sampling** - Need dynamic content generation from structured data
* **Completions** - Want to improve UX with smart parameter suggestions

Skip them when:

* Building simple query-based tools
* Client doesn't support the features
* Performance is critical (both add overhead)

[TIP]
====
Always check client capabilities before using advanced features:
`if ctx.session.client_params.capabilities.sampling:`
====


[.summary]
== Summary

Advanced MCP features can enhance your server's capabilities:

* **Sampling** - Dynamic content generation through LLM interactions
* **Completions** - Smart parameter suggestions for better UX
* **Implementation Notes** - Check client support and consider performance impact

In the next lesson, you'll review what you've learned and discover next steps for building production-ready MCP servers.

