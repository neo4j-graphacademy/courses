= Build a Text-to-Cypher Tool
:type: challenge
:order: 2


In the previous lesson, you learned about integrated workflows and how MCP tools can help you build other MCP tools.

In this final challenge, you will build a sophisticated **text-to-cypher** tool that converts natural language questions into Cypher queries.

This brings together everything you've learned: lifespan management, context, tools, schema exploration, and error handling.


== Challenge Goals

To complete this challenge, you will:

1. Create a tool to retrieve the Neo4j schema
2. Create a tool to execute test queries
3. Build a text-to-cypher tool that combines these capabilities
4. Test it with various natural language questions
5. See how AI can use this tool to answer complex questions


== Why This Matters

A text-to-cypher tool is powerful because:

* **Users don't need to know Cypher** - They ask questions in natural language
* **AI assistants can explore your data** - Without hardcoded queries
* **Dynamic capabilities** - The tool adapts to your schema
* **Foundation for GraphRAG** - Combine graph data with LLM reasoning


== Step 1: Create the Schema Tool

First, add a tool that retrieves your Neo4j database schema:

[source,python]
----
include::code/solution.py[tag=get_schema]
----


**What this tool does:**

* Retrieves all node labels and their properties
* Gets all relationship types
* Finds common relationship patterns
* Returns structured schema information


This tool is essential because it allows the AI (or your text-to-cypher tool) to understand what's possible in your database.


== Step 2: Create the Query Testing Tool

Add a tool to safely execute and test Cypher queries:

[source,python]
----
include::code/solution.py[tag=query_neo4j]
----


**Key features:**

* Validates queries are read-only (basic security)
* Accepts parameters for safe query execution
* Returns results with metadata
* Handles errors gracefully
* Prevents write operations


This tool lets you (or AI) test queries before incorporating them into your code.


== Step 3: Build the Text-to-Cypher Tool

Now for the main event - the text-to-cypher conversion tool:

[source,python]
----
include::code/solution.py[tag=text_to_cypher]
----


**How it works:**

1. **Get schema** - Understands the database structure
2. **Analyze question** - Identifies key patterns (genre, year, actor, etc.)
3. **Generate Cypher** - Creates appropriate query based on patterns
4. **Execute query** - Runs the generated Cypher
5. **Return results** - Provides query, parameters, and results


**Supported question patterns:**

* Genre + Year: "What action movies came out in 1999?"
* Actor: "What movies did Keanu Reeves star in?"
* Genre only: "Show me some comedy movies"
* Top rated: "What are the best rated movies?"
* And more!


== Step 4: Test with Natural Language Questions

Start your server and test with the MCP Inspector:

[source,bash]
----
npx @modelcontextprotocol/inspector uv --directory $PWD/server run main.py
----


Try these questions with the `text_to_cypher` tool:


=== Example 1: Genre + Year

**Question:** "What action movies were released in 1999?"

**Expected:**

* Generated Cypher matches movies by genre and year
* Parameters: `{genre: "Action", year: 1999}`
* Results include The Matrix and other 1999 action films


=== Example 2: Actor Query

**Question:** "What movies did Tom Hanks star in?"

**Expected:**

* Generated Cypher matches actor and their movies
* Parameters: `{actor_name: "Tom Hanks"}`
* Results include Forrest Gump, Cast Away, etc.


=== Example 3: Top Rated

**Question:** "What are the highest rated movies?"

**Expected:**

* Generated Cypher orders by rating
* No parameters needed
* Results show top 10 movies by IMDb rating


=== Example 4: Genre Only

**Question:** "Show me some science fiction movies"

**Expected:**

* Generated Cypher matches genre
* Parameters: `{genre: "Science Fiction"}`
* Results include The Matrix, Inception, etc.


== Step 5: Using in an AI Conversation

This tool really shines when used by an AI assistant.


**In Cursor or Claude Desktop:**

> User: "Can you find me some good action movies from the 90s?"

The AI will:

1. Call your `text_to_cypher` tool
2. Get the question: "action movies from the 90s"
3. Tool generates and executes appropriate Cypher
4. AI presents results in a conversational way


**The conversation might go:**

> Assistant: "I found some great action movies from the 90s! Here are the top ones:
> 
> 1. The Matrix (1999) - Rating: 8.7/10
> 2. Die Hard with a Vengeance (1995) - Rating: 7.6/10
> 3. The Rock (1996) - Rating: 7.4/10
> 
> Would you like more details about any of these?"


== Step 6: Understanding the Limitations

This is a simplified text-to-cypher implementation.

A production version would need:


**Better NLP:**

* More sophisticated entity extraction
* Handle complex queries: "Movies with Tom Hanks that aren't comedies"
* Support aggregations: "How many movies were made in each decade?"


**Expanded Coverage:**

* More relationship patterns
* Complex graph traversals
* Multi-hop queries


**AI Integration:**

* Use an LLM to generate Cypher instead of pattern matching
* Validate generated queries before execution
* Learn from past queries


**This course gives you the foundation - you can expand from here!**


== Step 7: See the Complete Server

Your `server/main.py` now has:

[source,python]
----
include::code/solution.py[tag=previous_tools]
----


You've built a complete GraphRAG server with:

* ✅ Letter counting (Module 1)
* ✅ Neo4j connection management (Module 2)
* ✅ Genre search tool (Module 2)
* ✅ Movie resource by ID (Module 2)
* ✅ Paginated browsing (Module 2)
* ✅ Schema exploration (Module 3)
* ✅ Query testing (Module 3)
* ✅ Text-to-Cypher (Module 3)


== Verify Your Implementation

Your text-to-cypher tool should:

1. ✅ Successfully retrieve the Neo4j schema
2. ✅ Generate Cypher queries from natural language
3. ✅ Execute queries and return results
4. ✅ Handle multiple question patterns
5. ✅ Provide clear explanations of what it did
6. ✅ Work with AI assistants like Claude or Cursor
7. ✅ Gracefully handle questions it can't parse


read::My text-to-cypher tool is working![]


[TIP]
.Extending the Tool
====
Ways to improve your text-to-cypher tool:

**Add more patterns:**
* Director queries
* Year ranges (1990s, 2000s)
* Ratings filters ("movies rated above 8")
* Runtime queries ("movies under 2 hours")

**Use an LLM:**
```python
# Instead of pattern matching, use an LLM
prompt = f"Convert this question to Cypher: {question}"
# Use sampling to generate Cypher
cypher = await ctx.session.create_message(...)
```

**Add validation:**
* Verify generated Cypher syntax
* Check query doesn't exceed time limits
* Validate against schema

**Learn from feedback:**
* Store successful queries
* Improve pattern recognition
* Build a query cache
====


[.summary]
== Summary

In this challenge, you built a sophisticated text-to-cypher tool:

* **Schema exploration** - Tool to understand database structure
* **Query testing** - Safe execution of Cypher queries
* **Text-to-Cypher** - Convert natural language to Cypher
* **Pattern recognition** - Identify intents in questions
* **Query generation** - Create appropriate Cypher queries
* **AI integration** - Enable AI assistants to explore your graph

This tool demonstrates the power of MCP for building GraphRAG applications that combine graph databases with large language models.

**Congratulations!** You've built a complete, production-ready MCP server with advanced capabilities.

In the next lesson, you'll learn about next steps and best practices for taking your MCP servers further.
