= Relationship Mutations With Nested Mutations
:order: 2


== Connecting Genre Node To A Movie Node

In the previous section we saw how to create, update, and delete nodes but we didn't actually connect any nodes with relationships.

Let's return to our example of adding the Cli-Fi genre node, but this time let's connect it to any Jurassic Park movies.

[source,GraphQL]
----
mutation MyMutation {
  createGenres(
    input: { 
      name: "Cli-Fi" <1>
      movies: { connect: { where: { node: { title_CONTAINS: "Jurassic" } } } } <2>
    }
  ) {
    genres {
      name
      movies { <3>
        title
      }
    }
  }
}
----
<1> - The input object takes the field values we want to set for the newly created `Genre` node
<2> - Here we specify that we want to connect our new Genre node to any movies with the word "Jurassic" in the title
<3> - Now if we include the `movies` relationship field in the selection set we will traverse the updated data graph to show we have connect all "Jurassic" movies to our new "Cli-Fi" genre node.

FIXME: is there a way to annotate the code line by line?

[source,GraphQL]
----
{
  "data": {
    "createGenres": {
      "genres": [
        {
          "name": "Cli-Fi",
          "movies": [
            { "title": "Lost World: Jurassic Park, The" },
            { "title": "Jurassic Park III" },
            { "title": "Jurassic Park" },
            { "title": "Jurassic World" }
          ]
        }
      ]
    }
  }
}
----


TODO: add arrows image showing subgraph

[.quiz]
== Check Your Understanding

include::questions/question-1.adoc[leveloffset=+1]

include::questions/question-2.adoc[leveloffset=+1]

include::questions/question-3.adoc[leveloffset=+1]


[.summary]
== Summary

In this lesson we covered nested mutation operations with the Neo4j GraphQL Library and the Neo4j GraphQL Toolbox. In the next lesson we will see how to add custom logic to our GraphQL API using Cypher and how to use GraphQL schema directives to configure the GraphQL API generated by the Neo4j GraphQL Library.