= Relationship Mutations With Nested Mutations
:order: 2

In the previous lessons you have learnt how to create, update, and delete single nodes. In this lesson you will connect nodes using relationships.

== Connecting Nodes

Let's return to the example of adding the "Cli-Fi" genre node. This query will use the `movies` relationship in `Genre` and connect any "Jurassic" movie.

[source,GraphQL]
----
mutation MyMutation {
  createGenres(
    input: { 
      name: "Cli-Fi" <1>
      movies: { connect: { where: { node: { title_CONTAINS: "Jurassic" } } } } <2>
    }
  ) {
    genres {
      name
      movies { <3>
        title
      }
    }
  }
}
----
Run the query and observe in the response that the new genre is created and that a relationship is created between the genre and the existing "Jurassic" movies:


[source,GraphQL]
----
{
  "data": {
    "createGenres": {
      "genres": [
        {
          "name": "Cli-Fi",
          "movies": [
            { "title": "Lost World: Jurassic Park, The" },
            { "title": "Jurassic Park III" },
            { "title": "Jurassic Park" },
            { "title": "Jurassic World" }
          ]
        }
      ]
    }
  }
}
----

There are 3 key points to identify in this query:

. The `input` object takes the field values for the created `Genre` node
+
[source,GraphQL]
----
    input: { 
      name: "Cli-Fi" <1>
    }
----
. The `movies` field is populated using the `connect` argument and the "Jurassic" nodes return by a `where` clause.
+
[source,GraphQL]
----
    input: { 
      movies: { connect: { where: { node: { title_CONTAINS: "Jurassic" } } } } <2>
    }
----
. The `movies` relationship field is included in the selection set and will return the updated data graph to show all the "Jurassic" movies are connected to our new "Cli-Fi" genre node.
+ 
[source,GraphQL]
----
    genres {
      name
      movies {
        title
      }
    }
----

[.quiz]
== Check Your Understanding

include::questions/question-1.adoc[leveloffset=+1]

[.summary]
== Summary

This lesson covered nested mutation operations with the Neo4j GraphQL Library and the Neo4j GraphQL Toolbox. In the next lesson you will see how to add custom logic to our GraphQL API using Cypher and how to use GraphQL schema directives to configure the GraphQL API generated by the Neo4j GraphQL Library.