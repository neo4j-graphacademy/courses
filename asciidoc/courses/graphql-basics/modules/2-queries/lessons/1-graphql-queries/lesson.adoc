= GraphQL Queries
:order: 1
// :sandbox: https://graphql-toolbox.neo4j.io/?connectURL=neo4j%2Bs://neo4j:felt-airport-manuals@d8086e75a731979f82f10f93e02eadd2.neo4jsandbox.com:7687
:disable-cache: true

The Neo4j GraphQL Library is a GraphQL to Cypher query execution layer for Neo4j and JavaScript GraphQL implementations.

In the previous section we said the four main goals of the Neo4j GraphQL Library are to:

1. Support GraphQL First Development
2. Auto Generate GraphQL API Operations
3. Generate Cypher From GraphQL Operations
4. Extend GraphQL With Cypher

Let's see how the Neo4j GraphQL Library enables GraphQL First Development!


== GraphQL First Development

// link:./1-setup/[Setup the Repository â†’, role=btn]

To start off be sure to use the default GraphQL type definitions that are defining a simple `Movie` type with only one property `title`. 

> Replace the contents of the type definition editor with the following snippet:

[source,GraphQL]
----
type Movie {
  title: String
}
----

Our database contains other data, but for now we'll start with just this simple type definition. The Neo4j GraphQL Library uses the convention of mapping GraphQL types to Neo4j node labels in the property graph model.

The single movie type defined above maps to a Neo4j property graph model with a single node label `Movie` and a single node property `title`.

// TODO: add arrows image of data model

If we click on the "Build Schema" button we can see the following operations are generated for us:


* `Query.movies`
* `Query.moviesAggregate`
* `Query.moviesConnection`

Similarly, the following mutation operations are generated as part of the GraphQL API:

* `Mutation.createMovies`
* `Mutation.deleteMovies`
* `Mutation.updateMovies`

That's quite a few operations available for just one single type! Let's ignore the other generated operations and focus on `Query.movies` for now.

[source,GraphQL]
----
query MyQuery {
  movies(options: { limit: 10 }) {
    title
  }
}
----

[source,JSON]
----
{
  "data": {
    "movies": [
      { "title": "Toy Story" },
      { "title": "Jumanji" },
      { "title": "Grumpier Old Men" },
      { "title": "Waiting to Exhale" },
      { "title": "Father of the Bride Part II" },
      { "title": "Heat" },
      { "title": "Sabrina" },
      { "title": "Tom and Huck" },
      { "title": "Sudden Death" },
      { "title": "GoldenEye" }
    ]
  }
}
----

Let's learn a bit more about the generated GraphQL API provided by the Neo4j GraphQL Library.

== The Generated GraphQL API

The second main goal of the Neo4j GraphQL Library is to auto-generate

Let's see the third goal in action, generating Cypher from GraphQL requests.

== Queries

As we saw above, by default, a Query field is generated for each type / node label defined in the GraphQL type definitions (technically three fields, as we see above, one for top-level query access (`Query.movies`), one for aggregations (`Query.moviesAggregate`), and another for Relay-style connection type (`Query.moviesConnection`) - more on those latter two later).

This query field allow for top-level query access to search for data and begin the data graph traversal from this type/node label (remember that node labels map to GraphQL types defined in the type definitions when using the Neo4j GraphQL Library).

this generated query field takes two optional arguments: 

* `options` - used to specify sorting, offset, and limit arguments, to enable for example pagination
* `where` - use to filter search results by matching predicates for field / node property values

We've already used the `options` argument! Let's add sorting to our example GraphQL query to see more ways of using the `options` argument.


[source,GraphQL]
----
query MyQuery {
  movies(options: { limit: 10, sort: { title: ASC } }) {
    title
  }
}
----

Note that in addition to editing the GraphQL type definitions in the type definitions editor you can use the Explorer feature integrated in the Neo4j GraphQL Toolbox to interactively explore the schema documentation and toggle fields on and off in the selection set:

image::images/explorer2.png[Neo4j GraphQL Toolbox Explorer feature,width=500,align=center]

== Filtering With The `where` Argument

Now that we've seen how to use the `options` argument, let's explore the filtering functionality exposed by the `where` argument.

If we expand the `where` input object toggle in Explorer we can see the various fields available on the input object. We can see that these input fields correspond to various string comparison operations with the `title` field on our `Movie` type.

image::images/explorer.png[Neo4j GraphQL Toolbox Explorer feature,width=500,align=center]

Since the only field we have is `Movie.title` we can filter for movies that contain a certain substring, for example. He we search for any movies with "Matrix" in the title.

[source,GraphQL]
----
query MyQuery {
  movies(where: { title_CONTAINS: "Matrix" }) {
    title
  }
}
----

And we can see that we have three Matrix movies in the database.


[source,JSON]
----
{
  "data": {
    "movies": [
      { "title": "Matrix Reloaded, The" },
      { "title": "Matrix Revolutions, The" },
      { "title": "Matrix, The" }
    ]
  }
}
----

We can also use GraphQL variables to write our query, passing parameter values in the `params.json` pane in Neo4j GraphQL Toolbox.

FIXME: should I also include the code snippet here (as well as the image?)?

image::images/variables.png[Using GraphQL variables with the Neo4j GraphQL Toolbox,width=500,align=center]

In the next section we will see some of the other filtering functionality as we add more fields and types to our GraphQL schema.

[.quiz]
== Check Your Understanding

include::questions/question-1.adoc[leveloffset=+1]

include::questions/question-2.adoc[leveloffset=+1]

include::questions/question-3.adoc[leveloffset=+1]


[.summary]
== Summary

In this lesson, we introduced the Query API of the Neo4j GraphQL Library and the Neo4j GraphQL Toolbox. In the next lesson we will see how to build a more complex data graph using our GraphQL schema's type definitions and the Neo4j GraphQL Toolbox.







