= Create a retriever
:order: 8
:type: challenge

To incorporate a retriever and Neo4j vector into a Langchain application, you can create a _retrieval_ chain.

== Retrieval chain

The `Neo4jVector` class has a `as_retriever()` method that returns a retriever.

By incorporating `Neo4jVector` into a `RetrievalQA` chain, you can use data and vectors in Neo4j in a Langchain application.

Review this program incorporating the `moviePlots` vector index into a retrieval chain.

[source,python]
----
include::{repository-raw}/main/2-llm-rag-python-langchain/retriever_chain.py[]
----

When the program runs, the `RetrievalQA` chain will use the `movie_plot_vector` retriever to retrieve documents from the `moviePlots` index and pass them to the `chat_llm` language model.

[TIP]
.Understanding the results
====
It can be challenging, to understand how the model generated the response and how the retriever affected it.

By setting the optional `verbose` and `return_source_documents` arguments to `True` when creating the `RetrievalQA` chain, you can see the source documents and the retriever's score for each document.

[source, python]
----
plot_retriever = RetrievalQA.from_llm(
    llm=chat_llm,
    retriever=movie_plot_vector.as_retriever(),
    verbose=True,
    return_source_documents=True
)
----
====

== Agent

You can add the `plot_retriever` chain as a tool to the `chat_agent.py` program you created earlier.
The agent can use the chain to find similar movie plots.

To complete this optional challenge, you will need to update the `2-llm-rag-python-langchain/chat_agent.py` program to:

. Create the `Neo4jVector` from the `moviePlots` vector index.
. Create the `RetrievalQA` chain using the `Neo4jVector` as the retriever.
. Update the `tools` to use the `RetrievalQA` chain.

[TIP]
.Running a RetrievalQA chain from a tool
====
Tools expect a single `query` input and a single output key.

The `RetrievalQA` chain returns multiple output keys.

As a result, the agent's tool executor cannot call the `RetrievalQA` chain directly e.g. using `func=retrievalQA.run`.

You could wrap the `RetrievalQA` chain in a function that takes a single string input, formats the results, and returns a single string.

[source,python]
----
# Create a function to invoke the retriever
include::{repository-raw}/main/2-llm-rag-python-langchain/solutions/chat_agent_retriever.py[tag=run_retriever]

# Append the tool to the tools array
tools = [
    # ...
    Tool.from_function(
        ...
        func=run_retriever,
        ...
    )
]
----
====

You may need to change the `name` and `description` of the `tools` so the LLM can distinguish between them.

[%collapsible]
.Click to reveal the solution
====
There is no right or wrong way to complete this challenge. Here is one potential solution.

[source, python]
----
include::{repository-raw}/main/2-llm-rag-python-langchain/solutions/chat_agent_retriever.py[]
----
====

== Continue

When you are ready, you can move on to the next task.

read::Move on[]

[.summary]
== Lesson Summary

You learned how to create a retriever chain and to incorporate it into a Langchain application.

Next you will learn about Cypher generation.