name: Deploy to AWS ECS

on:
  push:
    branches:
      - main
      - development

jobs:
  set_environment:
    runs-on: ubuntu-latest
    steps:
      - name: Set up environment based on branch
        id: environment_check
        run: |          
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          
          if [[ "$BRANCH_NAME" = "main" ]]; then
            ENVIRONMENT="production"
          else
            ENVIRONMENT="development"
          fi
          
          echo "environment=${ENVIRONMENT,,}" >> $GITHUB_OUTPUT
    outputs:
      environment: ${{ steps.environment_check.outputs.environment }}

  assets:
      runs-on: ubuntu-latest
      needs: set_environment
      permissions:
        id-token: write
        contents: read
      env:
        AWS_REGION: us-east-1
        ENVIRONMENT: ${{ needs.set_environment.outputs.environment }}
      steps:
        - name: Checkout
          uses: actions/checkout@v4

        - name: Set env variables for secrets
          run: |
            echo "N_AWS_DEPLOY_ROLE_ARN=${ENVIRONMENT}_GH_OIDC_ROLE_ARN" >> $GITHUB_ENV

        - name: Use Node.js 20
          uses: actions/setup-node@v4
          with:
            node-version: '20'

        - name: Configure AWS credentials
          uses: aws-actions/configure-aws-credentials@v4
          with:
            role-to-assume: ${{ vars[env.N_AWS_DEPLOY_ROLE_ARN] }}
            aws-region: ${{ env.AWS_REGION }}

        - name: Install NPM Dependencies
          run: npm install

        - name: Build CSS
          run: npm run build:css

        - name: Build Front-end JS
          run: npm run build:ui

        - name: Sync Assets
          run: |
            if [ "${{ env.ENVIRONMENT }}" = "development" ]; then
              aws s3 sync public/ s3://${{ env.ENVIRONMENT }}-graphacademy-assets/assets/ --acl public-read
            elif [ "${{ env.ENVIRONMENT }}" = "production" ]; then
              aws s3 sync public/ s3://cdn.graphacademy.neo4j.com --acl public-read
            fi

#  deploy:
#    runs-on: ubuntu-latest
#    needs: [set_environment, assets]
#    permissions:
#      id-token: write
#      contents: read
#    env:
#      AWS_REGION: us-east-1
#      ENVIRONMENT: ${{ needs.set_environment.outputs.environment }}
#    steps:
#      - name: Checkout
#        uses: actions/checkout@v4
#
#      - name: Set env variables for secrets
#        run: |
#          echo "N_AWS_DEPLOY_ROLE_ARN=${ENVIRONMENT}_GH_OIDC_ROLE_ARN" >> $GITHUB_ENV
#
#      - name: Configure AWS credentials
#        uses: aws-actions/configure-aws-credentials@v4
#        with:
#          role-to-assume: ${{ vars[env.N_AWS_DEPLOY_ROLE_ARN] }}
#          aws-region: ${{ env.AWS_REGION }}
#
#      - name: Login to Amazon ECR Private
#        id: login-ecr
#        uses: aws-actions/amazon-ecr-login@v2
#
#      - name: Build and push
#        uses: docker/build-push-action@v6
#        with:
#          context: .
#          push: true
#          tags: "${{ env.IMAGE }}:${{ github.sha }},${{ env.IMAGE }}:latest"
#        env:
#          IMAGE: "${{ steps.login-ecr.outputs.registry }}/${{ env.ENVIRONMENT }}-graphacademy-repository"
#
#      - name: Deploying services with an env file
#        uses: brunocascio/ecs-deploy@v2.2.0
#        with:
#          args: deploy ${{ env.ENVIRONMENT }}-graphacademy-cluster ${{ env.ENVIRONMENT }}-graphacademy-service

  update-eventbridge:
    runs-on: ubuntu-latest
#    needs: [set_environment, assets, deploy]
    needs: [set_environment]
    permissions:
      id-token: write
      contents: read
    env:
      AWS_REGION: us-east-1
      ENVIRONMENT: ${{ needs.set_environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set env variables for secrets
        run: |
          echo "N_AWS_DEPLOY_ROLE_ARN=${ENVIRONMENT}_GH_OIDC_ROLE_ARN" >> $GITHUB_ENV

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars[env.N_AWS_DEPLOY_ROLE_ARN] }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install jq and yq
        run: |
          sudo apt-get update
          sudo apt-get install -y wget
          sudo wget -qO- https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64 | sudo tee /usr/bin/jq > /dev/null
          sudo chmod +x /usr/bin/jq
          sudo wget -qO- https://github.com/mikefarah/yq/releases/download/4.44.2/yq_linux_amd64 | sudo tee /usr/bin/yq > /dev/null
          sudo chmod +x /usr/bin/yq

      - name: Get CRON config from the file
        id: cronConfig
        uses: mikefarah/yq@master
        with:
          cmd: yq -p yaml -o json '.crons' deployment-config/cron-config-${{ env.ENVIRONMENT }}.yaml

      - name: Read YAML configurations, update EventBridge Schedules and Targets
        shell: bash
        run: |
          set -o xtrace
          
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ENV_NAME=${{ env.ENVIRONMENT }}
          
          echo ${{ steps.cronConfig.outputs.result }}
          
          yq -p yaml -o json deployment-config/cron-config-${ENV_NAME}.yaml
          yq -p yaml -o json '.crons' deployment-config/cron-config-${ENV_NAME}.yaml
          tasks=$(yq -o=json '.crons' deployment-config/cron-config-${ENV_NAME}.yaml)
          echo "$tasks" | jq -c '.[]' | while read -r task; do
            NAME=$(echo $task | jq -r '.name')
            COMMAND=$(echo $task | jq -c '.command')
            CRON=$(echo "$task" | jq -r '.cron')
            ENV_VARS=$(echo $task | jq -c '.env')
            TASK_NAME="${ENV_NAME}-graphacademy-${NAME}-task-cron"
            RULE_NAME="${ENV_NAME}-graphacademy-${NAME}-rule"
            ENV_VARS_ARRAY=($(echo $ENV_VARS | jq -r '.[]'))

            output="["
            for var in "${ENV_VARS_ARRAY[@]}"; do
              secret_name="${ENV_NAME}/graphacademy/$var"
              
              if [[ ! $secret_name =~ ^[a-zA-Z0-9/_+=.@-]+$ ]]; then
                echo "Invalid secret name: $secret_name ðŸš«"
                exit 1
              fi
              
              secret=$(aws secretsmanager get-secret-value --secret-id "$secret_name" --region us-east-1 --query SecretString --output text)
              if [ $? -ne 0 ]; then
                echo "Failed to fetch secret: $secret_name ðŸš«"
                exit 1
              fi
          
              value=$(echo $secret | jq -r ".\"$var\"")
              if [ $? -ne 0 ]; then
                echo "Failed to parse json value for: $var ðŸš«"
                exit 1
              fi
          
              env_var="{\"name\":\"$var\",\"value\":\"$value\"}"
              output+="$env_var,"
            done
            output="${output%,}]"
          
            EVENTBRIDGE_ROLE="arn:aws:iam::${AWS_ACCOUNT_ID}:role/${ENV_NAME}-graphacademy-ecs-events-role"
            DEF=$(aws ecs describe-task-definition --task-definition ${ENV_NAME}-graphacademy-task)
          
            NEW_DEF=$(echo $DEF | jq --argjson command "$COMMAND" --argjson environment "$output" \
                  '.taskDefinition |
                  del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy) |
                  .containerDefinitions[0].command = $command |
                  .containerDefinitions[0].environment = $environment |
                  .containerDefinitions[0].logConfiguration.options["awslogs-stream-prefix"] = "cron-'$NAME'" |
                  .family = "'$TASK_NAME'"
                ')
          
            echo "$NEW_DEF" > "new-task-def-${NAME}.json"
            cat new-task-def-${NAME}.json
          
            if [ "${ENV_NAME}" = "development" ]; then
              IFS=',' read -ra private_subnets <<< "${{ vars.DEVELOPMENT_PRIVATE_SUBNETS }}"
              export security_group_id="${{ vars.DEVELOPMENT_SECURITY_GROUP }}"
              export private_subnets
            elif [ "${ENV_NAME}" = "production" ]; then
              IFS=',' read -ra private_subnets <<< "${{ vars.PRODUCTION_PRIVATE_SUBNETS }}"
              export security_group_id="${{ vars.PRODUCTION_SECURITY_GROUP }}"
              export private_subnets
            fi
            
            cluster_name=${ENV_NAME}-graphacademy-cluster
            response=$(aws ecs register-task-definition --cli-input-json file://new-task-def-${NAME}.json)
            revision=$(echo $response | jq -r '.taskDefinition.revision')
            task_arn=$(echo $response | jq -r '.taskDefinition.taskDefinitionArn')
            target_arn="arn:aws:ecs:us-east-1:${AWS_ACCOUNT_ID}:cluster/${cluster_name}"  
          
            aws events put-rule --name $RULE_NAME --schedule-expression "$CRON"
                
            put_targets_response=$(aws events put-targets --rule $RULE_NAME --targets "Id=${ENV_NAME}-${NAME}-task-cron,Arn=${target_arn},RoleArn=${EVENTBRIDGE_ROLE},EcsParameters={TaskDefinitionArn=${task_arn},LaunchType=FARGATE,NetworkConfiguration={awsvpcConfiguration={Subnets=[\"${private_subnets[0]}\",\"${private_subnets[1]}\",\"${private_subnets[2]}\"],SecurityGroups=[\"$security_group_id\"],AssignPublicIp=DISABLED}}}")            
          
            if [ "$(echo $put_targets_response | jq -r '.FailedEntryCount')" -ne 0 ]; then
              echo "Failed to set targets"
              exit 1
            else
              echo "Target was added successfully âœ…"
            fi
          done
